"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[5674],{25475:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"modules/trie","title":"Trie module","description":"Deprecation warning","source":"@site/docs/modules/trie.md","sourceDirName":"modules","slug":"/modules/trie","permalink":"/docs.rspamd.com/branches/docs/antivirus-update/ru/modules/trie","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/modules/trie.md","tags":[],"version":"current","frontMatter":{"title":"Trie module"},"sidebar":"docs","previous":{"title":"SURBL module","permalink":"/docs.rspamd.com/branches/docs/antivirus-update/ru/modules/surbl"},"next":{"title":"URL redirector module","permalink":"/docs.rspamd.com/branches/docs/antivirus-update/ru/modules/url_redirector"}}');var i=s(74848),n=s(28453);const o={title:"Trie module"},a="Trie plugin",l={},d=[{value:"Deprecation warning",id:"deprecation-warning",level:3},{value:"Module description",id:"module-description",level:2},{value:"Configuration",id:"configuration",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"trie-plugin",children:"Trie plugin"})}),"\n",(0,i.jsx)(t.h3,{id:"deprecation-warning",children:"Deprecation warning"}),"\n",(0,i.jsxs)(t.p,{children:["This plugin is obsolete as all its functionality is now provided by the ",(0,i.jsx)(t.a,{href:"/modules/multimap",children:"multimap module"}),". The multimap module supports regular expressions and pattern-based rules that fully encompass the features listed below. Additionally, using the regular expressions module for the same purposes is safe, as these expressions are typically accelerated by a multi-pattern lookup engine. However, this module can still be valuable for certain platforms, such as arm/mips or non-x86 systems. Therefore, there are no plans to remove it from Rspamd."]}),"\n",(0,i.jsx)(t.h2,{id:"module-description",children:"Module description"}),"\n",(0,i.jsx)(t.p,{children:"The Trie plugin is specifically designed for efficiently searching multiple strings within raw messages or text parts. It achieves this with remarkable speed by utilizing the aho-corasick algorithm, which performs exceptionally well even with large texts and numerous input strings."}),"\n",(0,i.jsx)(t.p,{children:"This module offers a user-friendly interface for working with the search trie structure."}),"\n",(0,i.jsx)(t.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(t.p,{children:"Here is an example of trie configuration:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-hcl",children:'trie {\n\t# Each subsection defines a single rule with associated symbol\n\tSYMBOL1 {\n\t\t# Define rules in the file (it is *NOT* a map)\n\t\tfile = "/some/path";\n\t\t# Raw rules search within the whole undecoded messages\n\t\traw = true;\n\t\t# If we have multiple occurrences of strings from this rule\n\t\t# then we insert a symbol multiple times\n\t\tmulti = true;\n\t}\n\tSYMBOL2 {\n\t\tpatterns = [\n\t\t\t"pattern1",\n\t\t\t"pattern2",\n\t\t\t"pattern3"\n\t\t]\n\t}\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Despite the Aho-Corasick trie's impressive speed, it only supports plain strings and lacks the ability to differentiate word boundaries. For instance, the string ",(0,i.jsx)(t.code,{children:"test"})," would be found in texts such as ",(0,i.jsx)(t.code,{children:"test"}),", ",(0,i.jsx)(t.code,{children:"tests"})," or even ",(0,i.jsx)(t.code,{children:"123testing"}),". As a result, it is more suitable for searching for specific and relatively precise patterns, rather than for matching whole words."]})]})}function u(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>a});var r=s(96540);const i={},n=r.createContext(i);function o(e){const t=r.useContext(n);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);