"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[5443],{4698:(e,s,o)=>{o.r(s),o.d(s,{assets:()=>l,contentTitle:()=>t,default:()=>a,frontMatter:()=>c,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"configuration/composites","title":"Composite symbols","description":"{:.no_toc}","source":"@site/docs/configuration/composites.md","sourceDirName":"configuration","slug":"/configuration/composites","permalink":"/docs.rspamd.com/branches/master/ru/configuration/composites","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/configuration/composites.md","tags":[],"version":"current","frontMatter":{"title":"Composite symbols"},"sidebar":"docs","previous":{"title":"Common options","permalink":"/docs.rspamd.com/branches/master/ru/configuration/options"},"next":{"title":"Rspamd maps","permalink":"/docs.rspamd.com/branches/master/ru/configuration/maps"}}');var i=o(4848),r=o(8453);const c={title:"Composite symbols"},t="Rspamd composite symbols",l={},d=[{value:"Configuration",id:"configuration",level:2},{value:"Composite expressions",id:"composite-expressions",level:2},{value:"Composite weight rules",id:"composite-weight-rules",level:2},{value:"Composites with symbol groups",id:"composites-with-symbol-groups",level:2},{value:"Disabling composites",id:"disabling-composites",level:2},{value:"Composites on symbol options",id:"composites-on-symbol-options",level:2}];function h(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"rspamd-composite-symbols",children:"Rspamd composite symbols"})}),"\n",(0,i.jsx)(s.p,{children:"{:.no_toc}"}),"\n",(0,i.jsxs)(s.p,{children:["Rspamd composites are used to combine rules and create more complex rules. Composite rules are defined in the ",(0,i.jsx)(s.code,{children:"composites"})," section of the configuration."]}),"\n",(0,i.jsx)(s.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(s.p,{children:["You could use ",(0,i.jsx)(s.code,{children:"local.d/composites.conf"})," (which effects changes ",(0,i.jsx)(s.strong,{children:"inside"})," the ",(0,i.jsx)(s.code,{children:"composites"})," section) to define new composites or to change/override existing composites. Names of keys here define the name of the composite; the value of the key should be an object that defines the composite's properties & expression, which is a combination of rules."]}),"\n",(0,i.jsxs)(s.p,{children:["For example, you can define a composite that fires when two specific symbols are found and ",(0,i.jsx)(s.strong,{children:"replace"})," these symbols weights with its score:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'TEST_COMPOSITE {\n    expression = "SYMBOL1 and SYMBOL2";\n    score = 5.0;\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["In this case, if a message contains both ",(0,i.jsx)(s.code,{children:"SYMBOL1"})," and ",(0,i.jsx)(s.code,{children:"SYMBOL2"}),", they will be replaced by the ",(0,i.jsx)(s.code,{children:"TEST_COMPOSITE"})," symbol. The weights of ",(0,i.jsx)(s.code,{children:"SYMBOL1"})," and ",(0,i.jsx)(s.code,{children:"SYMBOL2"})," will be subtracted from the metric accordingly."]}),"\n",(0,i.jsx)(s.h2,{id:"composite-expressions",children:"Composite expressions"}),"\n",(0,i.jsx)(s.p,{children:"You can use the following operations in a composite expression:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"AND"})," ",(0,i.jsx)(s.code,{children:"&"})," - matches true only if both operands are true"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"OR"})," ",(0,i.jsx)(s.code,{children:"|"})," - matches true if any operands are true"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"NOT"})," ",(0,i.jsx)(s.code,{children:"!"})," - matches true if operand is false"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"You can use braces to specify the priority of operations in composite rules. If braces are not used, the operators will be evaluated from left to right. For example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'TEST {\n    expression = "SYMBOL1 and SYMBOL2 and ( not SYMBOL3 | not SYMBOL4 | not SYMBOL5 )";\n    score = 10.0;\n    group = "Some group";\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"Composite rule can include another composites in the body. There is no restriction on the order in which composite rules are defined:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'TEST1 {\n    expression = "SYMBOL1 AND TEST2";\n}\nTEST2 {\n    expression = "SYMBOL2 OR NOT SYMBOL3";\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"Composites should not be recursive, but Rspamd usually detects and prevents this automatically."}),"\n",(0,i.jsxs)(s.p,{children:["Note that symbols are removed ",(0,i.jsx)(s.strong,{children:"after"})," composites are applied. Therefore, you cannot rely on one composite to remove a symbol that is used in another composite."]}),"\n",(0,i.jsxs)(s.p,{children:["You can also set up policies for composites regarding the symbols that are included in their expression. By default, Rspamd ",(0,i.jsx)(s.strong,{children:"removes"})," the symbols and weights that trigger the composite and replaces them with the symbol and weight of the composite itself. However, you can change this behavior in two ways."]}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["Set up removal policy for each symbol:\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"~"}),": remove symbol only (weight is preserved)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"-"}),": do not remove anything (both weight and the symbol itself are preserved)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"^"}),": force removing of symbol and weight (by default, Rspamd prefers to leave symbols when some composite wants to remove and another composite wants to leave any of score/name pair)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Set the default policy for all elements in the expression using ",(0,i.jsx)(s.code,{children:"policy"})," option:\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"default"}),": default policy - remove weight and symbol"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"remove_weight"}),": remove weight only"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"remove_symbol"}),": remove symbol only"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"leave"}),": leave both symbol and score"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"E.g."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'TEST_COMPOSITE {\n    expression = "SYMBOL1 and SYMBOL2";\n    policy = "leave";\n}\nTEST_COMPOSITE2 {\n    expression = "SYMBOL3 and SYMBOL4";\n    policy = "remove_weight";\n}\n'})}),"\n",(0,i.jsx)(s.h2,{id:"composite-weight-rules",children:"Composite weight rules"}),"\n",(0,i.jsxs)(s.p,{children:["Composites can record symbols in a metric, which can be used to create non-captive composites. For example, you have symbol ",(0,i.jsx)(s.code,{children:"A"})," and ",(0,i.jsx)(s.code,{children:"B"})," with weights ",(0,i.jsx)(s.code,{children:"W_a"})," and ",(0,i.jsx)(s.code,{children:"W_b"})," and a composite ",(0,i.jsx)(s.code,{children:"C"})," with weight ",(0,i.jsx)(s.code,{children:"W_c"}),"."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["If ",(0,i.jsx)(s.code,{children:"C"})," is ",(0,i.jsx)(s.code,{children:"A & B"})," then if rule ",(0,i.jsx)(s.code,{children:"A"})," and rule ",(0,i.jsx)(s.code,{children:"B"})," matched then these symbols are ",(0,i.jsx)(s.em,{children:"removed"})," and their weights are removed as well, leading to a single symbol ",(0,i.jsx)(s.code,{children:"C"})," with weight ",(0,i.jsx)(s.code,{children:"W_c"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["If ",(0,i.jsx)(s.code,{children:"C"})," is ",(0,i.jsx)(s.code,{children:"-A & B"}),", then rule ",(0,i.jsx)(s.code,{children:"A"})," is preserved, but the symbol ",(0,i.jsx)(s.code,{children:"C"})," is inserted. The weight of ",(0,i.jsx)(s.code,{children:"A"})," is preserved as well, so the total weight of ",(0,i.jsx)(s.code,{children:"-A & B"})," will be ",(0,i.jsx)(s.code,{children:"W_a + W_c"})," (weight of ",(0,i.jsx)(s.code,{children:"B"})," is still removed)."]}),"\n",(0,i.jsxs)(s.li,{children:["If ",(0,i.jsx)(s.code,{children:"C"})," is ",(0,i.jsx)(s.code,{children:"~A & B"}),", then rule ",(0,i.jsx)(s.code,{children:"A"})," is removed, but it's weight is preserved,\nleading to the total weight of ",(0,i.jsx)(s.code,{children:"W_a + W_c"})]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"If you have multiple composites that include the same symbol, and one composite wants to remove the symbol while another composite wants to preserve it, the symbol will be preserved by default. Here are some more examples:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'COMP1 {\n    expression = "BLAH | !DATE_IN_PAST";\n}\nCOMP2 {\n    expression = "!BLAH | DATE_IN_PAST";\n}\nCOMP3 {\n    expression = "!BLAH | -DATE_IN_PAST";\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["Both ",(0,i.jsx)(s.code,{children:"BLAH"})," and ",(0,i.jsx)(s.code,{children:"DATE_IN_PAST"})," exist in the message's check results. However, ",(0,i.jsx)(s.code,{children:"COMP3"})," wants to preserve ",(0,i.jsx)(s.code,{children:"DATE_IN_PAST"})," so it will be saved in the output."]}),"\n",(0,i.jsxs)(s.p,{children:["If we rewrite the previous example but replace ",(0,i.jsx)(s.code,{children:"-"})," with ",(0,i.jsx)(s.code,{children:"~"})," then ",(0,i.jsx)(s.code,{children:"DATE_IN_PAST"})," will be removed (however, its weight won't be removed):"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'COMP1 {\n    expression = "BLAH | !DATE_IN_PAST";\n}\nCOMP2 {\n    expression = "!BLAH | DATE_IN_PAST";\n}\nCOMP3 {\n    expression = "!BLAH | ~DATE_IN_PAST";\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["When we want to remove a symbol, despite other composites combinations, it is possible to add the prefix ",(0,i.jsx)(s.code,{children:"^"})," to the symbol:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'COMP1 {\n    expression = "BLAH | !DATE_IN_PAST";\n}\nCOMP2 {\n    expression = "!BLAH | ^DATE_IN_PAST";\n}\nCOMP3 {\n    expression = "!BLAH | -DATE_IN_PAST";\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["In this example ",(0,i.jsx)(s.code,{children:"COMP3"})," wants to save ",(0,i.jsx)(s.code,{children:"DATE_IN_PAST"})," once again, however ",(0,i.jsx)(s.code,{children:"COMP2"})," overrides this and removes ",(0,i.jsx)(s.code,{children:"DATE_IN_PAST"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"composites-with-symbol-groups",children:"Composites with symbol groups"}),"\n",(0,i.jsxs)(s.p,{children:["It is possible to include a group of symbols in a composite rule. This effectively means ",(0,i.jsx)(s.strong,{children:"any"})," matched symbol of the specified group:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"g:<group>"})," - matches ",(0,i.jsx)(s.strong,{children:"any"})," symbol"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"g+:<group>"})," - matches any symbol with ",(0,i.jsx)(s.strong,{children:"positive"})," score"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"g-:<group>"})," - matches any symbol with ",(0,i.jsx)(s.strong,{children:"negative"})," score"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Removal policies are applied only to the matched symbols and not to the entire group."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'TEST2 {\n    expression = "SYMBOL2 & !g:mua & g+:fuzzy";\n}\n'})}),"\n",(0,i.jsx)(s.h2,{id:"disabling-composites",children:"Disabling composites"}),"\n",(0,i.jsxs)(s.p,{children:["You can disable a composite rule by adding ",(0,i.jsx)(s.code,{children:"enabled = false"})," to its definition. For example, to disable the ",(0,i.jsx)(s.code,{children:"DKIM_MIXED"})," composite defined in the stock configuration, you can add the following to ",(0,i.jsx)(s.code,{children:"local.d/composites.conf"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:"DKIM_MIXED {\n    enabled = false;\n}\n"})}),"\n",(0,i.jsxs)(s.p,{children:["You can also disable composites from the ",(0,i.jsx)(s.a,{href:"/configuration/settings",children:"users settings"})," from Rspamd ",(0,i.jsx)(s.code,{children:"1.9"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"composites-on-symbol-options",children:"Composites on symbol options"}),"\n",(0,i.jsxs)(s.p,{children:["Starting from version 2.0, it is also possible to augment the conditions of composite rules by adding required symbol options. For example, if a symbol ",(0,i.jsx)(s.code,{children:"SYM"})," can insert options ",(0,i.jsx)(s.code,{children:"opt1"})," and ",(0,i.jsx)(s.code,{children:"opt2"}),", you can create a composite expression that only triggers if the ",(0,i.jsx)(s.code,{children:"opt2"})," option is presented:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'TEST2 {\n    expression = "SYM[opt2]";\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[opt2]"})," syntax means a list of options allowed for a symbol to match. You can also add multiple options:"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[opt1,opt2]"})," - it means that ",(0,i.jsx)(s.strong,{children:"both"})," ",(0,i.jsx)(s.code,{children:"opt1"})," and ",(0,i.jsx)(s.code,{children:"opt2"})," must be added by a symbol,"]}),"\n",(0,i.jsx)(s.p,{children:"or even regular expressions:"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[/opt\\d/i]"})," - this must not include comma, even escaped..."]}),"\n",(0,i.jsx)(s.p,{children:"or a mix of both:"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.code,{children:"[/opt\\d/i, foo]"})}),"\n",(0,i.jsxs)(s.p,{children:["In all cases, ",(0,i.jsx)(s.strong,{children:"all"})," matches are required (not just in a single option, but in an options list for a symbol)."]}),"\n",(0,i.jsx)(s.p,{children:"In the future, this feature may be extended to support fully functional expressions if needed."})]})}function a(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,s,o)=>{o.d(s,{R:()=>c,x:()=>t});var n=o(6540);const i={},r=n.createContext(i);function c(e){const s=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);