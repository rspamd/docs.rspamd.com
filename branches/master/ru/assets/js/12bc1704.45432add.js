"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[7027],{7410:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"modules/multimap","title":"Multimap module","description":"{:.no_toc}","source":"@site/docs/modules/multimap.md","sourceDirName":"modules","slug":"/modules/multimap","permalink":"/docs.rspamd.com/branches/master/ru/modules/multimap","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/modules/multimap.md","tags":[],"version":"current","frontMatter":{"title":"Multimap module"},"sidebar":"docs","previous":{"title":"Mime types modules","permalink":"/docs.rspamd.com/branches/master/ru/modules/mime_types"},"next":{"title":"MX Check module","permalink":"/docs.rspamd.com/branches/master/ru/modules/mx_check"}}');var l=s(4848),i=s(8453);const r={title:"Multimap module"},d="Multimap module",c={},a=[{value:"Quick Start Guide",id:"quick-start-guide",level:2},{value:"How Multimap Processing Works",id:"how-multimap-processing-works",level:2},{value:"Principles of work",id:"principles-of-work",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Best Configuration Practices",id:"best-configuration-practices",level:2},{value:"Map Attributes",id:"map-attributes",level:3},{value:"Map field syntax",id:"map-field-syntax",level:3},{value:"Map Type Prefixes",id:"map-type-prefixes",level:3},{value:"Maps content",id:"maps-content",level:3},{value:"Map types",id:"map-types",level:2},{value:"Email-related Types",id:"email-related-types",level:3},{value:"Content-related Types",id:"content-related-types",level:3},{value:"Connection-related Types",id:"connection-related-types",level:3},{value:"Regexp maps",id:"regexp-maps",level:2},{value:"Map filters",id:"map-filters",level:2},{value:"Content filters",id:"content-filters",level:3},{value:"Content Filter Scoring Behavior",id:"content-filter-scoring-behavior",level:3},{value:"Filename filters",id:"filename-filters",level:3},{value:"From, rcpt and header filters",id:"from-rcpt-and-header-filters",level:3},{value:"Helo, hostname filters",id:"helo-hostname-filters",level:3},{value:"Mempool filters",id:"mempool-filters",level:3},{value:"Received filters",id:"received-filters",level:3},{value:"Selector options filters",id:"selector-options-filters",level:3},{value:"Symbol options filters",id:"symbol-options-filters",level:3},{value:"URL filters",id:"url-filters",level:3},{value:"Pre-filter maps",id:"pre-filter-maps",level:2},{value:"Multiple symbol maps",id:"multiple-symbol-maps",level:2},{value:"Get all matches",id:"get-all-matches",level:3},{value:"Conditional maps",id:"conditional-maps",level:2},{value:"Redis for maps",id:"redis-for-maps",level:2},{value:"Combined maps",id:"combined-maps",level:2},{value:"Dependent maps",id:"dependent-maps",level:2},{value:"Examples",id:"examples",level:2},{value:"SpamAssassin-like Rules",id:"spamassassin-like-rules",level:2},{value:"Configuration",id:"configuration-1",level:3},{value:"Rule Format",id:"rule-format",level:3},{value:"Regular Expression Rules",id:"regular-expression-rules",level:4},{value:"Meta Rules",id:"meta-rules",level:4},{value:"Score Rules",id:"score-rules",level:4},{value:"Description Rules",id:"description-rules",level:4},{value:"Supported Operators",id:"supported-operators",level:3},{value:"Regular Expression Formats",id:"regular-expression-formats",level:3},{value:"Example Configuration",id:"example-configuration",level:3},{value:"Features",id:"features",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Limitations",id:"limitations",level:3}];function o(e){const n={a:"a",center:"center",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"multimap-module",children:"Multimap module"})}),"\n",(0,l.jsx)(n.p,{children:"{:.no_toc}"}),"\n",(0,l.jsxs)(n.p,{children:["The Multimap module has been specifically designed to handle rules that are based on various types of lists which are dynamically updated by Rspamd, and are referred to as ",(0,l.jsx)(n.code,{children:"maps"}),". This module is particularly useful for organizing whitelists, blacklists, and other lists via files. Additionally, it is capable of loading remote lists using the ",(0,l.jsx)(n.code,{children:"HTTP"})," and ",(0,l.jsx)(n.code,{children:"HTTPS"})," protocols or the ",(0,l.jsx)(n.code,{children:"RESP"})," (REdis Serialization Protocol). This article provides a detailed explanation of all the configuration options and features available in this module."]}),"\n",(0,l.jsx)(n.h2,{id:"quick-start-guide",children:"Quick Start Guide"}),"\n",(0,l.jsx)(n.p,{children:"Here are common use cases for the Multimap module with basic examples:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Block specific email senders:"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'BLOCKED_SENDERS {\n  # Note that it is SMTP from\n  type = "from";\n  # For MIME (or displayed) from, one can use `extract_from = "mime";`\n  extract_from = "smtp";\n  map = "/etc/rspamd/maps/blocked_senders.map";\n  score = 10.0;\n  description = "Blocked sender addresses";\n}\n'})}),"\n",(0,l.jsxs)(n.ol,{start:"2",children:["\n",(0,l.jsx)(n.li,{children:"Whitelist trusted IPs:"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'TRUSTED_IPS {\n  type = "ip";\n  map = "/etc/rspamd/maps/trusted_ips.map";\n  prefilter = true;\n  action = "accept";\n  description = "Trusted IP addresses";\n}\n'})}),"\n",(0,l.jsxs)(n.ol,{start:"3",children:["\n",(0,l.jsx)(n.li,{children:"Block dangerous file extensions:"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'BLOCKED_EXTENSIONS {\n  type = "filename";\n  filter = "extension";\n  map = "/etc/rspamd/maps/blocked_extensions.map";\n  score = 8.0;\n  description = "Blocked file extensions";\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"how-multimap-processing-works",children:"How Multimap Processing Works"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Data Extraction \u2192 2. Filtering \u2192 3. Map Lookup \u2192 4. Action/Scoring"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:'Example flow for a "from" type map:'}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:['Extract: "John Smith ',(0,l.jsx)(n.a,{href:"mailto:john@example.com",children:"john@example.com"}),'"']}),"\n",(0,l.jsx)(n.li,{children:'Filter (email:domain): "example.com"'}),"\n",(0,l.jsx)(n.li,{children:'Lookup: Check if "example.com" exists in map'}),"\n",(0,l.jsx)(n.li,{children:"Result: Apply score or action if found"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Common combinations:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Use Case"}),(0,l.jsx)(n.th,{children:"Type"}),(0,l.jsx)(n.th,{children:"Filter"}),(0,l.jsx)(n.th,{children:"Example Map Entry"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Block domains"}),(0,l.jsx)(n.td,{children:"from"}),(0,l.jsx)(n.td,{children:"email:domain"}),(0,l.jsx)(n.td,{children:"example.com"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Block users"}),(0,l.jsx)(n.td,{children:"from"}),(0,l.jsx)(n.td,{children:"email:user"}),(0,l.jsx)(n.td,{children:"spammer"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Block file types"}),(0,l.jsx)(n.td,{children:"filename"}),(0,l.jsx)(n.td,{children:"extension"}),(0,l.jsx)(n.td,{children:".exe"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Block URLs"}),(0,l.jsx)(n.td,{children:"url"}),(0,l.jsx)(n.td,{children:"tld"}),(0,l.jsx)(n.td,{children:"badsite.com"})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"principles-of-work",children:"Principles of work"}),"\n",(0,l.jsxs)(n.p,{children:["This module defines rules that allows to extract multiple types of data (defined by ",(0,l.jsx)(n.code,{children:"type"}),"). The data extracted is transformed in the desired way (defined by ",(0,l.jsx)(n.code,{children:"filter"}),") and is checked against the list of strings that is usually referred as ",(0,l.jsx)(n.code,{children:"map"}),":"]}),"\n",(0,l.jsx)(n.center,{children:(0,l.jsx)(n.img,{className:"img-fluid",src:"/img/multimap_dia.png",width:"75%"})}),"\n",(0,l.jsxs)(n.p,{children:["It is a common mistake to use ",(0,l.jsx)(n.code,{children:"type"})," instead of ",(0,l.jsx)(n.code,{children:"filter"})," and vice-versa. To avoid confusing, please bear in mind that ",(0,l.jsx)(n.code,{children:"type"})," is the main property of the map that defines which exact data is extracted."]}),"\n",(0,l.jsx)(n.p,{children:"Maps in Rspamd refer to files or HTTP links that are automatically monitored and reloaded if any changes occur. The following are examples of how maps can be defined:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'map = "http://example.com/file";\nmap = "file:///etc/rspamd/file.map";\nmap = "/etc/rspamd/file.map";\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Rspamd offers the option to save traffic for HTTP maps using cached maps, while also respecting ",(0,l.jsx)(n.code,{children:"304 Not modified responses"}),", Cache-Control headers, and ETags. Additionally, the maps data is shared between workers, and only the first controller worker is allowed to fetch remote maps."]}),"\n",(0,l.jsxs)(n.p,{children:["By default, the configuration of this module actively utilises compound maps, which define a map as an array of sources with a local fallback location. While this redundancy may be unnecessary for user-defined maps, further details are available in the following ",(0,l.jsx)(n.a,{href:"/faq#what-are-maps",children:"FAQ section"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,l.jsx)(n.p,{children:"Common issues and solutions:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Map not matching as expected\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Check map format matches type (IP maps need CIDR notation)"}),"\n",(0,l.jsxs)(n.li,{children:["Verify filter is appropriate (use ",(0,l.jsx)(n.code,{children:"email:domain"})," vs ",(0,l.jsx)(n.code,{children:"email:addr"}),")"]}),"\n",(0,l.jsxs)(n.li,{children:["Enable debug logging: ",(0,l.jsx)(n.code,{children:"local.d/logging.inc"}),":"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'  debug_modules = ["multimap"];\n'})}),"\n",(0,l.jsxs)(n.ol,{start:"2",children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Scores not working as expected"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Check if using prefilter (prefilters don't use scores)"}),"\n",(0,l.jsx)(n.li,{children:"For content maps, consider multiple part matching"}),"\n",(0,l.jsx)(n.li,{children:"Verify symbol isn't overridden in metrics"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Regular expressions not matching"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Verify ",(0,l.jsx)(n.code,{children:"regexp = true"})," is set"]}),"\n",(0,l.jsx)(n.li,{children:"Check regex syntax is Hyperscan-compatible"}),"\n",(0,l.jsx)(n.li,{children:"Test regex separately"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,l.jsx)(n.p,{children:"The module includes a set of rules in the following format:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'MAP_SYMBOL1 { \n  type = "type"; \n  map = "url"; \n  # [optional params...] \n}\nMAP_SYMBOL2 { \n  type = "type"; \n  map = "from"; \n  # [optional params...] \n}\n\n...\n'})}),"\n",(0,l.jsxs)(n.p,{children:["To define your own rules, it is advisable to do so in the ",(0,l.jsx)(n.code,{children:"/etc/rspamd/local.d/multimap.conf"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"best-configuration-practices",children:"Best Configuration Practices"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Map Organization"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Use meaningful filenames (e.g., blocked_senders.map vs list1.map)"}),"\n",(0,l.jsx)(n.li,{children:"Keep related maps in dedicated directories"}),"\n",(0,l.jsx)(n.li,{children:"Use comments in maps to document entries"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Performance Considerations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Use prefilters for early accept/reject decisions"}),"\n",(0,l.jsx)(n.li,{children:"Prefer simple matches over complex regexes"}),"\n",(0,l.jsx)(n.li,{children:"Use CDB maps for large datasets"}),"\n",(0,l.jsx)(n.li,{children:"Consider Redis for frequently updated maps"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Security Recommendations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Regularly audit map contents"}),"\n",(0,l.jsx)(n.li,{children:"Use HTTPS for remote maps"}),"\n",(0,l.jsx)(n.li,{children:"Implement redundancy for critical maps"}),"\n",(0,l.jsx)(n.li,{children:"Monitor map update frequency"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"map-attributes",children:"Map Attributes"}),"\n",(0,l.jsx)(n.p,{children:"Mandatory attributes are:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"type"})," - map ",(0,l.jsx)(n.a,{href:"#map-types",children:"type"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"map"})," - ",(0,l.jsx)(n.a,{href:"#map-field-syntax",children:"map data"})]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Optional map configuration attributes:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"prefilter"})," - defines if the map is used in ",(0,l.jsx)(n.a,{href:"#pre-filter-maps",children:"prefilter mode"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"action"})," - for prefilter maps defines action set by map match"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"regexp"})," - set to ",(0,l.jsx)(n.code,{children:"true"})," if your map contain ",(0,l.jsx)(n.a,{href:"#regexp-maps",children:"regular expressions"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"symbols"})," - array of symbols that this map can insert (for key-value pairs), ",(0,l.jsx)(n.a,{href:"#multiple-symbol-maps",children:"learn more"}),". Please bear in mind, that if you define this attribute, your map must have entries in form ",(0,l.jsx)(n.code,{children:"key<spaces>value"})," to match a specific symbol."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"score"})," - score of the symbol (can be redefined in the ",(0,l.jsx)(n.code,{children:"metric"})," section)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"description"})," - map description"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"message"})," - message returned to MTA on prefilter reject action being triggered"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"group"})," - group for the symbol (can be redefined in ",(0,l.jsx)(n.code,{children:"metric"}),")"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"require_symbols"})," - expression of symbols that have to match for a specific message: ",(0,l.jsx)(n.a,{href:"#conditional-maps",children:"learn more"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"filter"})," - match specific part of the input (for example, email domain): ",(0,l.jsx)(n.a,{href:"#map-filters",children:"here"})," is the complete definition of maps filters"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"extract_from"})," - attribute extracts values of the sender/recipient from the SMTP dialog or the From/To header. To achieve this, set the value to ",(0,l.jsx)(n.code,{children:"smtp"}),", ",(0,l.jsx)(n.code,{children:"mime"}),", or ",(0,l.jsx)(n.code,{children:"both"})," to match both sources. It's important to note that ",(0,l.jsx)(n.code,{children:"extract_from"})," is solely utilized in conjunction with the ",(0,l.jsx)(n.code,{children:"from"})," or ",(0,l.jsx)(n.code,{children:"rcpt"})," map ",(0,l.jsx)(n.a,{href:"#map-types",children:"type"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["When using header maps, it is essential to specify the exact ",(0,l.jsx)(n.code,{children:"header"})," by utilizing the header option."]}),"\n",(0,l.jsxs)(n.p,{children:["It is important to note that there is often confusion between the ",(0,l.jsx)(n.code,{children:"type"})," and ",(0,l.jsx)(n.code,{children:"filter"})," parameters for the multimap module. The general rule of thumb is that ",(0,l.jsx)(n.code,{children:"type"})," refers to ",(0,l.jsx)(n.em,{children:"what information"})," is checked in the map, such as URLs, IPs, and headers. On the other hand, the ",(0,l.jsx)(n.code,{children:"filter"})," attribute refers to ",(0,l.jsx)(n.em,{children:"how this information is transformed"})," before being checked, such as extracting domains."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Selector"})," maps are using ",(0,l.jsx)(n.a,{href:"/configuration/selectors",children:"selectors"}),", which defines both extraction and transformation. Consequently, this type of map can be considered as the most basic and flexible. All other types of maps can be expressed using a selector map. Furthermore, it is possible to store ",(0,l.jsx)(n.a,{href:"#dependent-maps",children:"dependent maps"})," in Redis using the selectors framework."]}),"\n",(0,l.jsx)(n.h3,{id:"map-field-syntax",children:"Map field syntax"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Example"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"http://example.com/list"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["HTTP map, reloaded using ",(0,l.jsx)(n.code,{children:"If-Modified-Since"}),", can be signed"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"https://example.com/list"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"HTTPS map - same as HTTP but with TLS enabled (with certificate check)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"file:///path/to/list"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"file map, reloaded on change, can be signed"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"/path/to/list"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"shorter form of a file map"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"cdb://path/to/list.cdb"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,l.jsx)(n.a,{href:"https://www.corpit.ru/mjt/tinycdb.html",children:"CDB"})," map in file, cannot be signed"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"redis://<hashkey>"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Redis map, read field in the hash stored at key"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"redis+selector://selector"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["(from version 2.0) similar to the former one Redis map where a hash key is acquired by application of some ",(0,l.jsx)(n.a,{href:"/configuration/selectors",children:"selector"})," that allows to create dependent maps"]})]})]})]}),"\n",(0,l.jsx)(n.p,{children:"A combination of files and HTTP can be used to create a resulting map that is a joint list of its elements, as shown in the following example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'map = [\n  "https://maps.rspamd.com/rspamd/mime_types.inc.zst",\n  "${DBDIR}/mime_types.inc.local",\n  "fallback+file://${CONFDIR}/mime_types.inc"\n]\n'})}),"\n",(0,l.jsx)(n.p,{children:"It is important to note that redis or cdb maps cannot be combined with generic maps."}),"\n",(0,l.jsx)(n.h3,{id:"map-type-prefixes",children:"Map Type Prefixes"}),"\n",(0,l.jsx)(n.p,{children:"Map content can be explicitly typed by prefixing the map path with a format specifier. For example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'map = "regexp;/path/to/file.re"    # Treat content as regular expressions\nmap = "regexp_multi;/path/to/map"  # Treat as regexps, match all possible entries\n'})}),"\n",(0,l.jsx)(n.p,{children:"Available format specifiers:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"regexp;"})," or ",(0,l.jsx)(n.code,{children:"re;"})," - Content contains regular expressions"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"regexp_multi;"})," or ",(0,l.jsx)(n.code,{children:"re_multi;"})," - Content contains regular expressions, match all possible entries"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"glob;"})," - Content contains glob patterns"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"glob_multi;"})," - Content contains glob patterns, match all possible entries"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"radix"}),"; or ",(0,l.jsx)(n.code,{children:"ipnet;"})," - Content contains IP/CIDR entries"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"set"}),"; - Content treated as set members"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"hash;"})," or ",(0,l.jsx)(n.code,{children:"plain;"})," - Content treated as hash table entries"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Note: Format specifiers are different from the ",(0,l.jsx)(n.code,{children:"regexp = true;"})," and ",(0,l.jsx)(n.code,{children:"multi = true;"})," options in map configuration. While they achieve similar results, format specifiers take precedence over configuration options."]}),"\n",(0,l.jsx)(n.h3,{id:"maps-content",children:"Maps content"}),"\n",(0,l.jsx)(n.p,{children:"Maps can contain keys:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"key1\nkey2\n"})}),"\n",(0,l.jsx)(n.p,{children:"key-value pairs (for multi-symbols maps):"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"key1 value1\nkey2 value2\nkey3 value3:score\n"})}),"\n",(0,l.jsx)(n.p,{children:"any comments:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"key1\n# Single line comment\nkey2 # Embedded comment\n"})}),"\n",(0,l.jsx)(n.p,{children:"IP maps can also contain IPs or IP/network in CIDR notation"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"192.168.1.1\n10.0.0.0/8\n"})}),"\n",(0,l.jsx)(n.h2,{id:"map-types",children:"Map types"}),"\n",(0,l.jsx)(n.p,{children:"Type attribute means what is matched with this map. The following types are supported:"}),"\n",(0,l.jsx)(n.h3,{id:"email-related-types",children:"Email-related Types"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"from"}),": Filter senders (spam sources, newsletters)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"rcpt"}),": Protect internal addresses, catch typos"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"header"}),": Custom header processing (X-Spam, List-Id)"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"content-related-types",children:"Content-related Types"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"content"}),": Pattern matching in message bodies"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"filename"}),": Attachment filtering"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"url"}),": Filtering of the URLs in the messages"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"connection-related-types",children:"Connection-related Types"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ip"}),": IP/network filtering"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"asn"}),": Geographic/provider filtering"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"hostname"}),": HELO/SMTP validation"]}),"\n"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"asn"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches ASN number passed by ",(0,l.jsx)(n.a,{href:"/modules/asn",children:"ASN module"})]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"content"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches specific content of a message (e.g. headers, body or even a full message) against some map, usually regular expressions map"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"country"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches country code of AS passed by ",(0,l.jsx)(n.a,{href:"/modules/asn",children:"ASN module"})]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"dnsbl"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches IP of the host that performed message handoff against some DNS blacklist (consider using ",(0,l.jsx)(n.a,{href:"/modules/rbl",children:"RBL"})," module for this)"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"filename"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches attachment filenames and filenames in archives against map. It also includes detected filename match from version 2.0. For example, if some attachment has ",(0,l.jsx)(n.code,{children:".png"})," extension but it has real type detected as ",(0,l.jsx)(n.code,{children:"image/jpeg"})," then two checks would be performed: for the original attachment and for the detected one. This does not include files in archives as Rspamd does not extract them."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"from"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches ",(0,l.jsx)(n.strong,{children:"envelope"})," from (or header ",(0,l.jsx)(n.code,{children:"From"})," if envelope from is absent)"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"header"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches any header specified (must have ",(0,l.jsx)(n.code,{children:'header = "Header-Name"'})," configuration attribute)"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"helo"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches HELO of the message handoff session"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"hostname"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches reverse DNS name of the host that performed message handoff"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"ip"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches IP of the host that performed message handoff (against radix map)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"mempool"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches contents of a mempool variable (specified with ",(0,l.jsx)(n.code,{children:"variable"})," parameter)"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"received"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["(new in 1.5) matches elements of ",(0,l.jsx)(n.code,{children:"Received"})," headers"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"rcpt"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches any of  ",(0,l.jsx)(n.strong,{children:"envelope"})," rcpt or header ",(0,l.jsx)(n.code,{children:"To"})," if envelope info is missing"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"selector"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["applies generic ",(0,l.jsx)(n.a,{href:"/configuration/selectors",children:"selector"})," and check data returned in the specific map. This type must have ",(0,l.jsx)(n.code,{children:"selector"})," option and an optional ",(0,l.jsx)(n.code,{children:"delimiter"})," option that defines how to join multiple selectors (an empty string by default). If a selector returns multiple values, e.g. ",(0,l.jsx)(n.code,{children:"urls"}),", then all values are checked. Normal filter logic can also be applied to the selector's results."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"symbol_options"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["(new in 1.6.3) match 'options' yielded by whichever symbol of interest (requires ",(0,l.jsx)(n.code,{children:"target_symbol"})," parameter)"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"url"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches URLs in messages against maps; this excludes image URLs and URLs extracted from content parts (e.g., PDF parts). To match them, use ",(0,l.jsx)(n.code,{children:'type = "selector"'})," with ",(0,l.jsx)(n.code,{children:"specific_urls({need_content = true, limit = 10})"})]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"user"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches authenticated username against maps"})]})]})]}),"\n",(0,l.jsxs)(n.p,{children:["DNS maps are considered legacy and it is not encouraged to use them in new projects. Instead, ",(0,l.jsx)(n.a,{href:"/modules/rbl",children:"rbl"})," should be used for that purpose."]}),"\n",(0,l.jsxs)(n.p,{children:["Maps can also be specified as ",(0,l.jsx)(n.a,{href:"https://www.corpit.ru/mjt/tinycdb.html",children:"CDB"})," databases, which might be useful for large maps:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'SOME_SYMBOL {\n    map = "cdb:///path/to/file.cdb";\n    type = "from";\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"regexp-maps",children:"Regexp maps"}),"\n",(0,l.jsxs)(n.p,{children:["All maps, except for ",(0,l.jsx)(n.code,{children:"ip"})," and ",(0,l.jsx)(n.code,{children:"dnsbl"})," maps, support the ",(0,l.jsx)(n.code,{children:"regexp"})," mode. In this mode, all keys in maps are treated as regular expressions. For example:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"# Sole key\n/example\\d+\\.com/i\n# Key + value (test)\n/other\\d+\\.com/i test\n# Comments are still enabled\n"})}),"\n",(0,l.jsxs)(n.p,{children:["For performance considerations, it is recommended to use only expressions supported by ",(0,l.jsx)(n.a,{href:"https://intel.github.io/hyperscan/dev-reference/compilation.html#pattern-support",children:"Hyperscan"})," as this engine provides fast performance without any additional cost. Currently, there is no way to distinguish which particular regexp was matched in case of multiple regexps being matched."]}),"\n",(0,l.jsxs)(n.p,{children:["To enable the ",(0,l.jsx)(n.code,{children:"regexp"})," mode, you should set the ",(0,l.jsx)(n.code,{children:"regexp"})," option to ",(0,l.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'# local.d/multimap.conf\nSENDER_FROM_WHITELIST {\n  type = "from";\n  map = "file:///tmp/from.map";\n  regexp = true;\n}\n\nURL_MODIFIER_REGEX {\n  type = "selector";\n  selector = "specific_urls({need_content = true, limit = 10})";\n  map = "file:///tmp/urls.map";\n  regexp = true;\n  score = 1.0;\n  one_shot = true;\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"map-filters",children:"Map filters"}),"\n",(0,l.jsxs)(n.p,{children:["In Rspamd, it is also possible to apply filtering expressions before checking the value against a particular map. This is particularly useful for ",(0,l.jsx)(n.code,{children:"header"})," rules. Filters can be specified using the ",(0,l.jsx)(n.code,{children:"filter"})," option, and the following filters are supported:"]}),"\n",(0,l.jsx)(n.h3,{id:"content-filters",children:"Content filters"}),"\n",(0,l.jsx)(n.p,{children:"For content maps, the following filters are supported:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Content filter"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"body"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"raw undecoded body content (with the exceptions of headers)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"full"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"raw undecoded content of a message (including headers)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"headers"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"undecoded headers"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"text"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"decoded and converted text parts (without HTML tags but with newlines)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"rawtext"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"decoded but not converted text parts (with HTML tags and newlines)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"oneline"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"decoded and stripped text content (without HTML tags and newlines)"})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"content-filter-scoring-behavior",children:"Content Filter Scoring Behavior"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"body"})," - applies regex over the whole raw message body with single scoring"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"text"})," - processes both text and HTML parts in multipart/alternative messages, which can result in double scoring"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"oneline"})," - similar to ",(0,l.jsx)(n.code,{children:"text"}),", processes each text part separately"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Note"}),": Before Rspamd 3.11, for ",(0,l.jsx)(n.code,{children:"text"})," and ",(0,l.jsx)(n.code,{children:"oneline"})," filters, the final score may be higher than defined if the message contains multiple text parts (e.g., both plain text and HTML). The ",(0,l.jsx)(n.code,{children:"one_shot = true;"})," option can be used to limit scoring to a single match, though this behaves per text part."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Note"}),": from Rspamd 3.11, this has been changed: only ",(0,l.jsx)(n.strong,{children:"distinct"})," parts are selected for matching. For example, if ",(0,l.jsx)(n.code,{children:"text/plain"})," and ",(0,l.jsx)(n.code,{children:"text/html"})," parts have the same text content, that content is matched only once."]}),"\n",(0,l.jsx)(n.h3,{id:"filename-filters",children:"Filename filters"}),"\n",(0,l.jsxs)(n.p,{children:["Since version 2.0, Filename maps also check for detected filename matches. For instance, if an attachment has a ",(0,l.jsx)(n.code,{children:".png"})," extension, but its real type is detected as ",(0,l.jsx)(n.code,{children:"image/jpeg"}),", two checks will be performed - one for the original attachment and one for the detected one. It is worth noting that Rspamd does not extract files in archives, so these files are not included in the checks."]}),"\n",(0,l.jsx)(n.p,{children:"Filename maps support the following set of filters:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Filter"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"extension"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches file extension"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"regexp:/re/"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"extract data from filename according to some regular expression"})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"from-rcpt-and-header-filters",children:"From, rcpt and header filters"}),"\n",(0,l.jsx)(n.p,{children:"These are generic emails and headers filters:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Filter"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,l.jsx)(n.code,{children:"email"})," or ",(0,l.jsx)(n.code,{children:"email:addr"})]}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["parse header value and extract email address from it (",(0,l.jsx)(n.code,{children:"Somebody <user@example.com>"})," -> ",(0,l.jsx)(n.code,{children:"user@example.com"}),")"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"email:user"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["parse header value as email address and extract user name from it (",(0,l.jsx)(n.code,{children:"Somebody <user@example.com>"})," -> ",(0,l.jsx)(n.code,{children:"user"}),")"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"email:domain"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["parse header value as email address and extract domain part from it (",(0,l.jsx)(n.code,{children:"Somebody <user@example.com>"})," -> ",(0,l.jsx)(n.code,{children:"example.com"}),")"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"email:domain:tld"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["parse header value as email address and extract effective second level domain from it (",(0,l.jsx)(n.code,{children:"Somebody <user@foo.example.com>"})," -> ",(0,l.jsx)(n.code,{children:"example.com"}),")"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"email:name"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["parse header value as email address and extract displayed name from it (",(0,l.jsx)(n.code,{children:"Somebody <user@example.com>"})," -> ",(0,l.jsx)(n.code,{children:"Somebody"}),")"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"regexp:/re/"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"extracts generic information using the specified regular expression"})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"helo-hostname-filters",children:"Helo, hostname filters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Filter"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"tld"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches eSLD (effective second level domain - a second-level domain or something that's effectively so like ",(0,l.jsx)(n.code,{children:"example.com"})," or ",(0,l.jsx)(n.code,{children:"example.za.org"}),")"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"tld:regexp:/re/"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"extracts generic information using the specified regular expression from the eSLD part"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"top"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches TLD (top level domain) part of the helo/hostname"})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"mempool-filters",children:"Mempool filters"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"regexp:/re/"})," - extract data from mempool variable according to some regular expression"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"received-filters",children:"Received filters"}),"\n",(0,l.jsxs)(n.p,{children:["If no filter is specified ",(0,l.jsx)(n.code,{children:"real_ip"})," is used by default."]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Filter"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"from_hostname"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"string that represents hostname provided by a peer"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"from_ip"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"IP address as provided by a peer"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"real_hostname"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"hostname as resolved by MTA"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"real_ip"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"IP as resolved by PTR request of MTA"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"by_hostname"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"MTA hostname"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"proto"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"protocol, e.g. ESMTP or ESMTPS"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"timestamp"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"received timestamp"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"for"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"for value (unparsed mailbox)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"tld:from_hostname"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"extract eSLD part from peer-provided hostname"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"tld:real_hostname"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"extract eSLD part from MTA-verified hostname"})]})]})]}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"real_ip"})," and ",(0,l.jsx)(n.code,{children:"from_ip"})," filters must be used in conjunction with IP maps."]}),"\n",(0,l.jsx)(n.p,{children:"Additionally to these filters, Received maps support the following configuration settings:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"min_pos"})," - Minimum position of Received header to match"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"max_pos"})," - Maximum position of Received header to match"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Negative values can be specified to match positions relative to the end of Received headers."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"flags"})," - One of more flags which MUST be present to match"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"nflags"})," - One or more flags which must NOT be present to match"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Currently available flags are ",(0,l.jsx)(n.code,{children:"ssl"})," (hop used SSL) and ",(0,l.jsx)(n.code,{children:"authenticated"})," (hop used SMTP authentication)."]}),"\n",(0,l.jsx)(n.h3,{id:"selector-options-filters",children:"Selector options filters"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"regexp:/re/"})," - extract data from selector's results according to some regular expression (usually not needed)"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"symbol-options-filters",children:"Symbol options filters"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"regexp:/re/"})," - extract data from symbol options according to some regular expression"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"url-filters",children:"URL filters"}),"\n",(0,l.jsxs)(n.p,{children:["URL maps allows another set of filters (by default, ",(0,l.jsx)(n.code,{children:"url"})," maps are matched using hostname part):"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Filter"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"full"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches the complete URL (not the hostname)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"full:regexp:/re/"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"extracts generic information using the specified regular expression from the full URL text"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"is_obscured"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches obscured URLs"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"is_phished"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches hostname but if and only if the URL is phished (e.g. pretended to be from another domain)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"is_redirected"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches redirected URLs"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"path"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"match path"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"query"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"match query string"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"regexp:/re/"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"extracts generic information using the specified regular expression from the hostname"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"tag:name"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches full hostnames that have URL tag with ",(0,l.jsx)(n.code,{children:"name"})]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"tld"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["matches eSLD (effective second level domain - a second-level domain or something that's effectively so like ",(0,l.jsx)(n.code,{children:"example.com"})," or ",(0,l.jsx)(n.code,{children:"example.za.org"}),")"]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"tld:regexp:/re/"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"extracts generic information using the specified regular expression from the eSLD part"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"top"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"matches TLD (top level domain) part of the hostname"})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"pre-filter-maps",children:"Pre-filter maps"}),"\n",(0,l.jsxs)(n.p,{children:["To enable pre-filter support, you should specify ",(0,l.jsx)(n.code,{children:"action"})," parameter which can take one of the\nfollowing values:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"accept"})," - accept the message (no action)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"add header"})," or ",(0,l.jsx)(n.code,{children:"add_header"})," - add a header to the message"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"rewrite subject"})," or ",(0,l.jsx)(n.code,{children:"rewrite_subject"})," - change the subject"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"greylist"})," - greylist the message"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"reject"})," - drop the message"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"If a map matches, no filters will be processed for a message. It is important to note that prefilter maps do not support multiple symbols or symbol conditions by design."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'# local.d/multimap.conf\nIP_WHITELIST { \n  type = "ip"; \n  map = "/tmp/ip.map"; \n  prefilter = true;\n  action = "accept";\n}\n# Better use RBL module instead\nSPAMHAUS_PBL_BLACKLIST { \n  type = "dnsbl"; \n  map = "pbl.spamhaus.org";\n  description = "PBL dns block list";\n  prefilter = true;\n  action = "reject";\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"multiple-symbol-maps",children:"Multiple symbol maps"}),"\n",(0,l.jsxs)(n.p,{children:["Starting from version 1.3.1, it is now possible to define multiple symbols, scores and symbols options using the multimap module. To achieve this, all possible symbols should be defined using the ",(0,l.jsx)(n.code,{children:"symbols"})," option in the multimap:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'# local.d/multimap.conf\nCONTENT_BLACKLISTED {\n  type = "content";\n  filter = "body"; # can be headers, full, oneline, text, rawtext\n  map = "${LOCAL_CONFDIR}/content.map";\n  symbols = ["CONTENT_BLACKLISTED1", "CONTENT_BLACKLISTED2"];\n  regexp = true;\n  score = 1.0;\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"In this example, you can use 3 symbols:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"CONTENT_BLACKLISTED"}),"\n",(0,l.jsx)(n.li,{children:"CONTENT_BLACKLISTED1"}),"\n",(0,l.jsx)(n.li,{children:"CONTENT_BLACKLISTED2"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"the map:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"# Symbol + score (final score is rule.score * element score = 1 * 10 = 10)\n/re1/ CONTENT_BLACKLISTED1:10\n# Symbol with default score (final score is rule.score = 1.0)\n/re2/ CONTENT_BLACKLISTED2\n# Just a default symbol with a default score.\n/re3/\n# Options specified after the score (opt1, opt2 etc) will be displayed in square brackets in the log output and can be used to provide additional context about the match. For example:\n/phishing.com/ CONTENT_BLACKLISTED2:10:financial,urgent\n"})}),"\n",(0,l.jsxs)(n.p,{children:["If symbols used in a map are not defined in the ",(0,l.jsx)(n.code,{children:"symbols"})," attribute, they will be ignored and replaced with the default map symbol. In case the value of a key-value pair is missing, Rspamd will insert the default symbol with a dynamic weight of ",(0,l.jsx)(n.code,{children:"1.0"}),". This weight is then multiplied by the metric score (which is set by ",(0,l.jsx)(n.code,{children:"score"})," parameter or implicitly set to zero if this parameter is missing). ",(0,l.jsx)(n.strong,{children:"Note"})," if multimap rule has no score, then all dynamic weights will be multiplied by a default implicit score zero, meaning that all symbols can have only ",(0,l.jsx)(n.strong,{children:"zero"})," weight."]}),"\n",(0,l.jsxs)(n.p,{children:["If the symbol names are unknown/dynamic, you can use the option ",(0,l.jsx)(n.code,{children:"dynamic_symbols = true"})," to add all possible symbols from that map:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'DYN_MULTIMAP {\n  type = "hostname";\n  map = "/maps/dynamic_symbols.map";\n  dynamic_symbols = true;\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"And the map content:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"foo DYN_TEST1:10:opt1,opt2\nbar DYN_TEST2:20:opt3,opt4\n"})}),"\n",(0,l.jsx)(n.p,{children:"From Rspamd 3.11, the scoring rules for dynamic symbols are the same as for static. Before 3.11 there was a bug that the rule score was not taken into account."}),"\n",(0,l.jsx)(n.h3,{id:"get-all-matches",children:"Get all matches"}),"\n",(0,l.jsxs)(n.p,{children:["If you want to match all possible regexps/globs in that list, not a single one, then you need to define ",(0,l.jsx)(n.code,{children:"multi"})," flag for that map:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'# local.d/multimap.conf\nCONTENT_BLACKLISTED {\n  type = "content";\n  filter = "body"; # can be headers, full, oneline, text, rawtext\n  map = "${LOCAL_CONFDIR}/content.map";\n  symbols = ["CONTENT_BLACKLISTED1", "CONTENT_BLACKLISTED2"];\n  regexp = true;\n  multi = true;\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"conditional-maps",children:"Conditional maps"}),"\n",(0,l.jsx)(n.p,{children:"Starting from version 1.3.1, it is possible to create maps that depend on other rules and are only checked if certain conditions are met. For example, you may want to perform some whitelisting based on whether a message has a valid SPF policy, but not for messages that are sent to a mailing list. In this case, you can use the following map condition:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'# local.d/multimap.conf\nFROM_WHITELISTED {\n  require_symbols = "R_SPF_ALLOW & !MAILLIST";\n  type = "from";\n  map = "/some/list";\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["In the ",(0,l.jsx)(n.code,{children:"require_symbols"})," definition, any logical expression of other symbols can be used. Rspamd automatically adds a dependency for a multimap rule on all symbols required by that rule. Symbols added by post-filters cannot be used here, but pre-filter and normal filter symbols are allowed."]}),"\n",(0,l.jsx)(n.h2,{id:"redis-for-maps",children:"Redis for maps"}),"\n",(0,l.jsxs)(n.p,{children:["Starting from version 1.3.3, Rspamd allows working with maps stored in a Redis backend. Any external application can put data into the Redis database using the HSET command, for example:  ",(0,l.jsx)(n.code,{children:"HSET hashkey test@example.org 1"}),". Once the data is in Redis, you can define a map using the protocol ",(0,l.jsx)(n.code,{children:"redis://"})," and specify the hash key to read. Redis settings can be defined inside the ",(0,l.jsx)(n.code,{children:"multimap"})," module as well."]}),"\n",(0,l.jsx)(n.h2,{id:"combined-maps",children:"Combined maps"}),"\n",(0,l.jsx)(n.p,{children:"From version 2.0, you can create maps with multiple values to be checked and joint via expression:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'COMBINED_MAP_AND {\n  type = "combined";\n  rules {\n    ip = {\n      type = "radix";\n      map = "${TESTDIR}/configs/maps/ip.list";\n      selector = "ip";\n    }\n    from {\n      map = "${TESTDIR}/configs/maps/domains.list";\n      selector = "from:domain";\n    }\n  }\n  expression = "from & ip"\n}\nCOMBINED_MAP_OR {\n  type = "combined";\n  rules {\n    ip = {\n      type = "radix";\n      map = "${TESTDIR}/configs/maps/ip.list";\n      selector = "ip";\n    }\n    from {\n      map = "${TESTDIR}/configs/maps/domains.list";\n      selector = "from:domain";\n    }\n  }\n  expression = "from || ip"\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Combined maps support merely ",(0,l.jsx)(n.strong,{children:"selectors"})," syntax, not general multimap rules."]}),"\n",(0,l.jsx)(n.h2,{id:"dependent-maps",children:"Dependent maps"}),"\n",(0,l.jsx)(n.p,{children:"Version 2.0 introduces the capability to create dependent maps in Redis, where the map key is dependent on some other data extracted from the same message. This allows for the creation of per-user based whitelists, among other use cases."}),"\n",(0,l.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,l.jsx)(n.p,{children:"Here are some examples of multimap configurations:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'# local.d/multimap.conf\nBLACKLIST_FROM_DISPLAYNAME {\n  # To work with MIME From use `header` type\n  type = "header";\n  header = "from";\n  filter = "email:name";\n  map = "file:///tmp/example.map";\n  score = 10.0;\n}\n\nSENDER_FROM_WHITELIST_USER {\n  type = "from";\n  filter = "email:user";\n  extract_from = "smtp"; \n  map = "file:///tmp/from.map";\n  action = "accept"; # Prefilter mode\n}\n\n# With Redis backend, also you need specify servers for Redis.\nSENDER_FROM_WHITELIST_USER {\n  type = "from";\n  map = "redis://hashkey";\n}\n\nSENDER_FROM_REGEXP {\n  type = "header";\n  header = "from";\n  filter = \'regexp:/.*@/\'; # `"Jon" <jon@example.net>` -> `"Jon" <jon@`\n  map = "file:///tmp/from_re.map";\n}\n\nURL_MAP {\n  type = "url";\n  filter = "tld";\n  map = "file:///tmp/url.map";\n}\n\nURL_MAP_RE {\n  type = "url";\n  filter = \'tld:regexp:/\\.[^.]+$/\'; # Extracts the last component of URL\n  map = "file:///tmp/url.map";\n}\n\nFILENAME_BLACKLISTED {\n  type = "filename";\n  filter = "extension";\n  map = "${LOCAL_CONFDIR}/filename.map";\n  action = "reject";\n  message = "A restricted file type was found";\n}\n\nCONTENT_BLACKLISTED {\n  type = "content";\n  filter = "body"; # can be headers, full, oneline, text, rawtext\n  map = "${LOCAL_CONFDIR}/content.map";\n  symbols = ["CONTENT_BLACKLISTED1", "CONTENT_BLACKLISTED2"];\n  regexp = true;\n}\n\nASN_BLACKLIST {\n  type = "asn";\n  map = "${LOCAL_CONFDIR}/asnlist.map";\n}\n\nLAST_RECEIVED_HEADER_IP_IF_AUTHED {\n  type = "received";\n  map = "${LOCAL_CONFDIR}/rcvd_ip.map";\n  filter = "real_ip";\n  min_pos = -1;\n  flags = ["authenticated"];\n}\n\nSYMBOL_OPTIONS_DBL {\n  type = "symbol_options";\n  target_symbol = "DBL_ABUSE_REDIR";\n  symbols = ["INTERESTING_DOMAIN"];\n  map = "${LOCAL_CONFDIR}/dbl_redir_symbols.map";\n}\n\nWHITELIST_HELO_RCPT {\n  type = "combined";\n  prefilter = true;\n  action = "accept";\n  rules {\n    helo {\n      map = "${LOCAL_CONFDIR}/helo_smtp.map";\n      selector = "helo";\n    }\n    rcpt = {\n      map = "${LOCAL_CONFDIR}/rcpt_internal_subdomains.map";\n      selector = "rcpts:domain";\n    }\n  }\n  expression = "helo & rcpt"\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Example adopted from ",(0,l.jsx)(n.a,{href:"https://gist.github.com/kvaps/25507a87dc287e6a620e1eec2d60ebc1",children:"@kvaps"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"cd /etc/rspamd"})}),"\n",(0,l.jsxs)(n.li,{children:["create ",(0,l.jsx)(n.code,{children:"local.d"})," folder if not exists"]}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"cd local.d"})}),"\n",(0,l.jsxs)(n.li,{children:["create ",(0,l.jsx)(n.code,{children:"multimap.conf"})," in ",(0,l.jsx)(n.code,{children:"/etc/rspamd/local.d/"})," folder if it does not exists"]}),"\n",(0,l.jsx)(n.li,{children:"create lists:"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"touch local_bl_from.map.inc local_bl_ip.map.inc local_bl_rcpt.map.inc \\\nlocal_wl_from.map.inc local_wl_ip.map.inc local_wl_rcpt.map.inc\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"change permissions:"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"chmod o+w local_bl_from.map.inc local_bl_ip.map.inc local_bl_rcpt.map.inc \\\nlocal_wl_from.map.inc local_wl_ip.map.inc local_wl_rcpt.map.inc\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["edit ",(0,l.jsx)(n.code,{children:"multimap.conf"})," (you should be in ",(0,l.jsx)(n.code,{children:"/etc/rspamd/local.d/"})," folder)"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-hcl",children:'# local.d/multimap.conf\n\n# Blacklists\nlocal_bl_ip { type = "ip"; map = "$LOCAL_CONFDIR/local.d/local_bl_ip.map.inc"; symbol = "LOCAL_BL_IP"; description = "Local ip blacklist";score = 3;}\nlocal_bl_from { type = "from"; map = "$LOCAL_CONFDIR/local.d/local_bl_from.map.inc"; symbol = "LOCAL_BL_FROM"; description = "Local from blacklist";score = 3;}\nlocal_bl_rcpt { type = "rcpt"; map = "$LOCAL_CONFDIR/local.d/local_bl_rcpt.map.inc"; symbol = "LOCAL_BL_RCPT"; description = "Local rcpt blacklist";score = 3;}\n\n# Whitelists\nlocal_wl_ip { type = "ip"; map = "$LOCAL_CONFDIR/local.d/local_wl_ip.map.inc"; symbol = "LOCAL_WL_IP"; description = "Local ip whitelist";score = -5;}\nlocal_wl_from { type = "from"; map = "$LOCAL_CONFDIR/local.d/local_wl_from.map.inc"; symbol = "LOCAL_WL_FROM"; description = "Local from whitelist";score = -5;}\nlocal_wl_rcpt { type = "rcpt"; map = "$LOCAL_CONFDIR/local.d/local_wl_rcpt.map.inc"; symbol = "LOCAL_WL_RCPT"; description = "Local rcpt whitelist";score = -5;}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"spamassassin-like-rules",children:"SpamAssassin-like Rules"}),"\n",(0,l.jsx)(n.p,{children:"Starting from Rspamd 3.13, the multimap module supports SpamAssassin-like rule definitions with regular expressions and meta rules. This allows you to use familiar SpamAssassin syntax for creating complex rules with logical combinations."}),"\n",(0,l.jsx)(n.h3,{id:"configuration-1",children:"Configuration"}),"\n",(0,l.jsxs)(n.p,{children:["To use SpamAssassin-like rules, set the map type to ",(0,l.jsx)(n.code,{children:"regexp_rules"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ucl",children:'multimap {\n  # SpamAssassin-like rules\n  CUSTOM_SA_RULES {\n    type = "regexp_rules";\n    map = "/path/to/sa_rules.cf";\n    description = "Custom SpamAssassin-like rules";\n  }\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"rule-format",children:"Rule Format"}),"\n",(0,l.jsx)(n.p,{children:"The SpamAssassin-like map supports the following rule types:"}),"\n",(0,l.jsx)(n.h4,{id:"regular-expression-rules",children:"Regular Expression Rules"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"# Header rules\nheader CUSTOM_HEADER_RULE Subject =~ /spam|phishing/i\nheader FROM_FREEMAIL From =~ /\\@(gmail|yahoo|hotmail)\\.com$/i\n\n# Body rules  \nbody CUSTOM_BODY_RULE /viagra|cialis/i\nrawbody CUSTOM_RAW_BODY /\\bhidden\\s+text\\b/i\n\n# URI rules\nuri CUSTOM_URI_RULE /bit\\.ly|tinyurl/i\n\n# Full message rules\nfull CUSTOM_FULL_RULE /malicious\\s+content/i\n"})}),"\n",(0,l.jsx)(n.h4,{id:"meta-rules",children:"Meta Rules"}),"\n",(0,l.jsx)(n.p,{children:"Meta rules combine multiple atoms using logical expressions:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"# Define meta rules using logical combinations\nmeta SPAM_COMBO CUSTOM_HEADER_RULE & CUSTOM_BODY_RULE\nmeta PHISHING_RULE FROM_FREEMAIL & CUSTOM_URI_RULE\nmeta COMPLEX_RULE (CUSTOM_HEADER_RULE | CUSTOM_BODY_RULE) & !WHITELIST_RULE\n"})}),"\n",(0,l.jsx)(n.h4,{id:"score-rules",children:"Score Rules"}),"\n",(0,l.jsx)(n.p,{children:"Set custom scores for rules:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"# Set scores for individual rules\nscore CUSTOM_HEADER_RULE 2.5\nscore SPAM_COMBO 5.0\nscore PHISHING_RULE 8.0\n"})}),"\n",(0,l.jsx)(n.h4,{id:"description-rules",children:"Description Rules"}),"\n",(0,l.jsx)(n.p,{children:"Set custom descriptions for rules:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"# Set descriptions for individual rules\ndescribe CUSTOM_HEADER_RULE Detects suspicious header patterns\ndescribe SPAM_COMBO Combination rule for spam detection\ndescribe PHISHING_RULE Detects phishing attempts\n"})}),"\n",(0,l.jsx)(n.h3,{id:"supported-operators",children:"Supported Operators"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"&"})," - AND operation"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"|"})," - OR operation"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"!"})," - NOT operation"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"()"})," - Grouping"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"regular-expression-formats",children:"Regular Expression Formats"}),"\n",(0,l.jsx)(n.p,{children:"Regular expressions can be specified in several formats:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"# Standard format with flags\n/pattern/flags\n\n# Alternative format\nm{pattern}flags\n\n# Without delimiters (flags not supported)\npattern\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Supported flags: ",(0,l.jsx)(n.code,{children:"g"}),", ",(0,l.jsx)(n.code,{children:"i"}),", ",(0,l.jsx)(n.code,{children:"m"}),", ",(0,l.jsx)(n.code,{children:"x"}),", ",(0,l.jsx)(n.code,{children:"s"}),", ",(0,l.jsx)(n.code,{children:"u"})]}),"\n",(0,l.jsx)(n.h3,{id:"example-configuration",children:"Example Configuration"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ucl",children:'multimap {\n  # Main SA rules\n  CUSTOM_SA_CHECKS {\n    type = "regexp_rules";\n    map = "file:///etc/rspamd/custom_sa.cf";\n    description = "Custom SpamAssassin rules";\n  }\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Content of ",(0,l.jsx)(n.code,{children:"/etc/rspamd/custom_sa.cf"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"# Header checks\nheader SUSPICIOUS_SUBJECT Subject =~ /urgent|winner|lottery/i\nheader FROM_SUSPICIOUS From =~ /noreply@.+\\.tk$/i\n\n# Body checks\nbody BODY_SUSPICIOUS /click.*here.*now/i\nbody BODY_MONEY /\\$\\d+,?\\d*\\s*(million|thousand)/i\n\n# URI checks  \nuri URI_SUSPICIOUS /bit\\.ly|tinyurl|goo\\.gl/i\n\n# Meta combinations\nmeta SPAM_LIKELY SUSPICIOUS_SUBJECT & BODY_SUSPICIOUS\nmeta PHISH_LIKELY FROM_SUSPICIOUS & URI_SUSPICIOUS\nmeta MONEY_SCAM BODY_MONEY & URI_SUSPICIOUS\n\n# Descriptions\ndescribe SUSPICIOUS_SUBJECT Detects urgent/lottery type subjects\ndescribe BODY_SUSPICIOUS Detects click-here type body content\ndescribe SPAM_LIKELY Combination of suspicious subject and body\ndescribe PHISH_LIKELY Suspicious sender with URL shorteners\ndescribe MONEY_SCAM Money-related content with suspicious URLs\n\n# Scores\nscore SUSPICIOUS_SUBJECT 1.5\nscore BODY_SUSPICIOUS 2.0\nscore SPAM_LIKELY 5.0\nscore PHISH_LIKELY 7.0\nscore MONEY_SCAM 8.5\n"})}),"\n",(0,l.jsx)(n.h3,{id:"features",children:"Features"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Regular Expression Caching"}),": All regular expressions are cached for optimal performance"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Meta Rule Support"}),": Complex logical combinations of rules"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Dynamic Symbol Creation"}),": Meta rules automatically create new symbols"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Score Management"}),": Flexible scoring system"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Named Results"}),": Full support for Rspamd's named results system"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Negation Support"}),": Header rules support ",(0,l.jsx)(n.code,{children:"!~"})," for negation"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Regular expressions are compiled once and cached"}),"\n",(0,l.jsx)(n.li,{children:"Meta rules are evaluated lazily"}),"\n",(0,l.jsx)(n.li,{children:"Rules are processed line-by-line during map loading"}),"\n",(0,l.jsx)(n.li,{children:"All rules use Rspamd's optimized regexp engine"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Function-based SpamAssassin rules (eval:) are not supported"}),"\n",(0,l.jsx)(n.li,{children:"Some advanced SpamAssassin features may not be available"}),"\n",(0,l.jsx)(n.li,{children:"Rules are processed in the order they appear in the file"}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Symbol Removal"}),": When symbols are removed between map updates, they remain in the symbol table until restart. Automatic cleanup of removed symbols will be implemented in a future version."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>d});var t=s(6540);const l={},i=t.createContext(l);function r(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);