"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[3311],{8453:(e,s,r)=>{r.d(s,{R:()=>o,x:()=>a});var t=r(6540);const i={},n=t.createContext(i);function o(e){const s=t.useContext(n);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(n.Provider,{value:s},e.children)}},8635:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"configuration/upstream","title":"Upstreams configuration","description":"This document describes upstreams: list of servers that are selected by Rspamd using the specific algorithm to establish a connection.","source":"@site/docs/configuration/upstream.md","sourceDirName":"configuration","slug":"/configuration/upstream","permalink":"/docs.rspamd.com/branches/master/ru/configuration/upstream","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/configuration/upstream.md","tags":[],"version":"current","frontMatter":{"title":"Upstreams configuration"},"sidebar":"docs","previous":{"title":"Redis configuration","permalink":"/docs.rspamd.com/branches/master/ru/configuration/redis"},"next":{"title":"Universal configuration language (UCL)","permalink":"/docs.rspamd.com/branches/master/ru/configuration/ucl"}}');var i=r(4848),n=r(8453);const o={title:"Upstreams configuration"},a="Upstreams configuration in Rspamd",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Master-slave algorithm",id:"master-slave-algorithm",level:3},{value:"Round-robin algorithm",id:"round-robin-algorithm",level:3},{value:"Random algorithm",id:"random-algorithm",level:3},{value:"Hash algorithm",id:"hash-algorithm",level:3},{value:"Upstreams lifetime",id:"upstreams-lifetime",level:2},{value:"Name resolution",id:"name-resolution",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"upstreams-configuration-in-rspamd",children:"Upstreams configuration in Rspamd"})}),"\n",(0,i.jsxs)(s.p,{children:["This document describes ",(0,i.jsx)(s.strong,{children:"upstreams"}),": list of servers that are selected by Rspamd using the specific algorithm to establish a connection."]}),"\n",(0,i.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(s.p,{children:"A list of upstreams is a commonly used structure in various Rspamd configuration options when setting up connections to remote servers. For instance, upstreams are used to connect to a Redis server, select a DNS server, or establish a connection via Rspamd proxy. Servers in the upstream list can be defined using IP addresses (IPv6 addresses should be enclosed in brackets) or Unix domain sockets. Here is an example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"127.0.0.1,[::1]\n"})}),"\n",(0,i.jsx)(s.p,{children:"by names:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"serv1.example.com,serv2.example.com\n"})}),"\n",(0,i.jsx)(s.p,{children:"If the ports you need to use are different from the default ones, you have the option to specify custom ports:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"serv1.example.com:8080,serv2.example.com\n"})}),"\n",(0,i.jsxs)(s.p,{children:["It is also possible to resolve both names and ports for some service using DNS ",(0,i.jsx)(s.strong,{children:"SRV"})," records. You can read more about this method in ",(0,i.jsx)(s.a,{href:"https://www.haproxy.com/blog/dns-service-discovery-haproxy#dns-srv-records",children:"this article"}),". To specify such an upstream you can set it's name to the following syntax:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"service=sentinel+redis-cluster.local\n"})}),"\n",(0,i.jsxs)(s.p,{children:["In this case, Rspamd will resolve SRV record in format ",(0,i.jsx)(s.code,{children:"_sentinel._tcp.redis-cluster.local"})," to get a list of names with the ports. A corresponding SRV record might look like this one:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"_sentinel._tcp.redis-cluster.local. TTL IN SRV 1 1 6300 sentinel1.redis-cluster.local.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["You can also specify Unix sockets by starting with either ",(0,i.jsx)(s.code,{children:"/"})," or ",(0,i.jsx)(s.code,{children:"."}),". However, please note that the priorities are not supported in this case:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"/tmp/rspamd.sock,fallback.example.com\n"})}),"\n",(0,i.jsx)(s.p,{children:"It is also possible to define priorities for the upstreams (their logic can vary depending on the rotation algorithm). However, if you choose to do so, you must also indicate a port number:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"127.0.0.1:53:10,8.8.8.8:53:1\n"})}),"\n",(0,i.jsx)(s.p,{children:"The upstreams line can be separated by commas or semicolons in any combination. Additionally, you can prepend a rotation algorithm to the upstreams line to override the default rotation method (specific for each upstream list definition):"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"master-slave:127.0.0.1:53:10,8.8.8.8:53:1\n"})}),"\n",(0,i.jsx)(s.p,{children:"There are several algorithms available in Rspamd so far:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"master-slave"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"round-robin"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"random"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"hash"})}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"master-slave-algorithm",children:"Master-slave algorithm"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"master-slave"})," algorithm always selects the upstream with the highest weight unless it is not alive. For example, the line ",(0,i.jsx)(s.code,{children:"master-slave:127.0.0.1:53:10,8.8.8.8:53:1"})," specifies that ",(0,i.jsx)(s.code,{children:"127.0.0.1"})," will always be used if possible, as it has a higher weight (10) compared to ",(0,i.jsx)(s.code,{children:"8.8.8.8"})," (weight 1). If ",(0,i.jsx)(s.code,{children:"127.0.0.1"})," becomes unavailable, Rspamd will use ",(0,i.jsx)(s.code,{children:"8.8.8.8"})," as the backup option."]}),"\n",(0,i.jsxs)(s.p,{children:["If you skip specifying priorities, the first element is treated as the master and the subsequent ones are used as slaves. For example, ",(0,i.jsx)(s.code,{children:"master-slave:127.0.0.1,8.8.8.8"})," is equivalent to the previous definition, with ",(0,i.jsx)(s.code,{children:"127.0.0.1"})," considered the master and ",(0,i.jsx)(s.code,{children:"8.8.8.8"})," as a slave."]}),"\n",(0,i.jsx)(s.h3,{id:"round-robin-algorithm",children:"Round-robin algorithm"}),"\n",(0,i.jsxs)(s.p,{children:["In the ",(0,i.jsx)(s.code,{children:"round-robin"})," algorithm, upstreams are initially selected based on their weights, but after selection, the weight of the chosen upstream is decreased by one. For example, ",(0,i.jsx)(s.code,{children:"round-robin:127.0.0.1:53:10,8.8.8.8:53:1"})," will select ",(0,i.jsx)(s.code,{children:"127.0.0.1"})," ten times and ",(0,i.jsx)(s.code,{children:"8.8.8.8"})," merely once. After all, upstreams are rotated through, Rspamd resets the current weights to their initial values. Therefore, this could be seen as a ",(0,i.jsx)(s.code,{children:"10:1"})," distribution for these two upstreams."]}),"\n",(0,i.jsx)(s.p,{children:"Upstreams that have errors pending will have their priorities penalized according to the number of errors pending, so Rspamd prefers to select upstreams with no errors whenever possible."}),"\n",(0,i.jsx)(s.h3,{id:"random-algorithm",children:"Random algorithm"}),"\n",(0,i.jsx)(s.p,{children:"Selects upstreams randomly ignoring priorities."}),"\n",(0,i.jsx)(s.h3,{id:"hash-algorithm",children:"Hash algorithm"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"hash"})," algorithm selects an upstream based on the hash value of the input key. Rspamd uses a ",(0,i.jsx)(s.a,{href:"https://arxiv.org/abs/1406.2294",children:"consistent hash algorithm"})," that allows data to be evenly distributed between shards based on some key value. This rotation method is available for specific upstreams, such as certain Redis upstreams. Otherwise, the ",(0,i.jsx)(s.code,{children:"round-robin"})," algorithm is used."]}),"\n",(0,i.jsx)(s.h2,{id:"upstreams-lifetime",children:"Upstreams lifetime"}),"\n",(0,i.jsxs)(s.p,{children:["Rspamd monitors each upstream for errors. If an error occurs, Rspamd places the upstream in monitoring mode during which it analyzes the error rate. The error rate is calculated as ",(0,i.jsx)(s.code,{children:"errors"})," / ",(0,i.jsx)(s.code,{children:"time elapsed since monitoring start"}),", usually set by options ",(0,i.jsx)(s.code,{children:"max_errors"})," and ",(0,i.jsx)(s.code,{children:"error_time"}),". If the error rate exceeds the desired limit (",(0,i.jsx)(s.code,{children:"max_errors"})," / ",(0,i.jsx)(s.code,{children:"error_time"}),"), Rspamd marks the upstream as inactive, unless no active upstreams are available. Any successful connection during the monitoring state returns the upstream to the active state."]}),"\n",(0,i.jsxs)(s.p,{children:["When an upstream reaches the error rate limit, Rspamd marks it as inactive and waits for a certain period of time, configured by the ",(0,i.jsx)(s.code,{children:"revive_time"})," option, before restoring the upstream to the active list. The entire process is illustrated in the following scheme:"]}),"\n",(0,i.jsx)(s.img,{className:"img-fluid",width:"75%",src:"/img/upstreams.png"}),"\n",(0,i.jsxs)(s.p,{children:["To tune these settings, please see the ",(0,i.jsx)(s.a,{href:"/configuration/options#upstreams-options",children:"Upstream options"})," documentation."]}),"\n",(0,i.jsx)(s.h2,{id:"name-resolution",children:"Name resolution"}),"\n",(0,i.jsxs)(s.p,{children:["Rspamd treats upstreams defined with their names differently. During the ",(0,i.jsx)(s.code,{children:"revive_time"}),", Rspamd attempts to re-resolve these names and inserts any new IP addresses into the upstream list. The minimum interval between resolve attempts is controlled by ",(0,i.jsx)(s.code,{children:"resolve_min_interval"}),", which is by default set to 1 minute. If a name has multiple addresses, Rspamd includes all of them. The addresses are then selected using round-robin rotation with error checking. Unlike upstream configurations, errors are persistent and not cleared after successful attempts. Therefore, Rspamd always selects an address with a lower error count. This approach is taken to disable an IPv6 address, for example, if IPv6 is improperly configured in the system."]}),"\n",(0,i.jsxs)(s.p,{children:["Starting from version 2.0, Rspamd also performs background resolution of all upstreams every ",(0,i.jsx)(s.code,{children:"lazy_resolve_time"})," + ",(0,i.jsx)(s.code,{children:"jitter(0.1 * lazy_resolve_time)"}),". By default, this value is set to 1 hour, but you can customize it in the configuration (options -> upstreams section). This allows Rspamd to update its knowledge of upstream IP addresses, ensuring efficient and reliable connections. SRV-based upstreams are resolved in two steps: one for SRV record resolution and one for target resolution."]})]})}function h(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);