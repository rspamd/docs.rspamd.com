"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[7108],{6358:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"modules/whitelist","title":"Whitelist module","description":"Whitelist module is intended to decrease or increase scores for some messages that are known to","source":"@site/docs/modules/whitelist.md","sourceDirName":"modules","slug":"/modules/whitelist","permalink":"/docs.rspamd.com/branches/master/ru/modules/whitelist","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/modules/whitelist.md","tags":[],"version":"current","frontMatter":{"title":"Whitelist module"},"sidebar":"docs","previous":{"title":"URL redirector module","permalink":"/docs.rspamd.com/branches/master/ru/modules/url_redirector"},"next":{"title":"Lua API documentation","permalink":"/docs.rspamd.com/branches/master/ru/lua/"}}');var t=s(4848),l=s(8453);const o={title:"Whitelist module"},r="Whitelist module",d={},a=[{value:"Whitelist setup",id:"whitelist-setup",level:2},{value:"Whitelist constraints",id:"whitelist-constraints",level:3},{value:"Whitelist rules modes",id:"whitelist-rules-modes",level:3},{value:"Whitelist values",id:"whitelist-values",level:3},{value:"Optional settings",id:"optional-settings",level:3},{value:"Note with regard to DKIM whitelist",id:"note-with-regard-to-dkim-whitelist",level:3},{value:"Configuration example",id:"configuration-example",level:2}];function c(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"whitelist-module",children:"Whitelist module"})}),"\n",(0,t.jsxs)(i.p,{children:["Whitelist module is intended to decrease or increase scores for some messages that are known to\nbe from the trusted sources ",(0,t.jsx)(i.strong,{children:"based on DKIM/SPF/DMARC policies"})," (for generic lists please use ",(0,t.jsx)(i.a,{href:"/modules/multimap",children:"multimap module"}),")."]}),"\n",(0,t.jsxs)(i.p,{children:["This module exists because the design flaws in the ",(0,t.jsx)(i.code,{children:"SMTP"})," protocol make it relatively simple to forge a sender. Consequently, rspamd endeavors to verify the sender's authenticity by considering the following supplementary policies:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"DKIM"}),": a message has a valid DKIM signature for this domain (similar to DMARC alignment but for DKIM only)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"SPF"}),": a message matches SPF record for the domain"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"DMARC"}),": a message satisfies domain's DMARC policy (implies ",(0,t.jsx)(i.em,{children:"aligned"})," SPF ",(0,t.jsx)(i.strong,{children:"or"})," DKIM according to the DMARC standard)"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"whitelist-setup",children:"Whitelist setup"}),"\n",(0,t.jsxs)(i.p,{children:["Configuring the Whitelist is a simple and straightforward process. Within the ",(0,t.jsx)(i.code,{children:"rules"})," section, you can define a collection of rules. Each rule ",(0,t.jsx)(i.strong,{children:"must"})," include the ",(0,t.jsx)(i.code,{children:"domains"})," attribute, which can be defined as either a string representing a map of domains or an array directly listing the domains."]}),"\n",(0,t.jsx)(i.h3,{id:"whitelist-constraints",children:"Whitelist constraints"}),"\n",(0,t.jsx)(i.p,{children:"The following constraints are allowed:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"valid_spf"}),": require a valid SPF policy"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"valid_dkim"}),": require DKIM validation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"valid_dmarc"}),": require a valid DMARC policy"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"whitelist-rules-modes",children:"Whitelist rules modes"}),"\n",(0,t.jsx)(i.p,{children:"Each whitelist rule can work in 3 modes:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"whitelist"})," (default): add symbol when a domain has been found and one of constraints defined is satisfied (e.g. ",(0,t.jsx)(i.code,{children:"valid_dmarc"}),")"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"blacklist"}),": add symbol when a domain has been found and one of constraints defined is ",(0,t.jsx)(i.em,{children:"NOT"})," satisfied (e.g. ",(0,t.jsx)(i.code,{children:"valid_dmarc"}),")"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"strict"}),": add symbol with negative (ham) score when a domain has been found and one of constraints defined is satisfied (e.g. ",(0,t.jsx)(i.code,{children:"valid_dmarc"}),") and add symbol with ",(0,t.jsx)(i.strong,{children:"POSITIVE"})," (spam) score when some of constraints defined has failed"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["If no constraints are defined, both the ",(0,t.jsx)(i.code,{children:"strict"})," and ",(0,t.jsx)(i.code,{children:"whitelist"})," rules will apply to all emails from the specified domains. For ",(0,t.jsx)(i.code,{children:"blacklist"})," rules, a positive score is typically assigned to the result."]}),"\n",(0,t.jsxs)(i.p,{children:["These options are combined using the ",(0,t.jsx)(i.code,{children:"AND"})," operator for ",(0,t.jsx)(i.code,{children:"whitelist"})," rules and the ",(0,t.jsx)(i.code,{children:"OR"})," operator for ",(0,t.jsx)(i.code,{children:"blacklist"})," and ",(0,t.jsx)(i.code,{children:"strict"})," rules. Therefore, if both ",(0,t.jsx)(i.code,{children:"valid_dkim = true"})," and ",(0,t.jsx)(i.code,{children:"valid_spf = true"})," are specified, both DKIM and SPF validation are required to whitelist domains from the list. Conversely, for blacklist and strict rules, any violation will result in a positive score symbol being assigned."]}),"\n",(0,t.jsx)(i.h3,{id:"whitelist-values",children:"Whitelist values"}),"\n",(0,t.jsxs)(i.p,{children:["In a map, each whitelist entry can have a value override, allowing you to modify the default rule policy and even adjust the score multiplier. This enables you to create a whitelist for DMARC while specifying certain entries to adhere to a ",(0,t.jsx)(i.code,{children:"strict"})," policy, which adds a spam symbol in the event of a DMARC policy failure. To achieve this, you can utilize the following values in your map:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"example.com # normal whitelist entry: whitelisting on hit, nothing on no hit\nbank.com both:1.0 # strict whitelist entry: spam symbol on policy failure and ham symbol on policy success\nfoo.com both:2.0 # same as previous but with 2.0 multiplier for score\nbar.com bl:1.0 # add spam symbol on failure but do not enable ham symbol on success\nbaz.com wl:2.0 # vice-versa - return to the normal behaviour but with 2.0 multiplier for policy success\n"})}),"\n",(0,t.jsxs)(i.p,{children:["You can also check maps shipped with Rspamd in the following repo: ",(0,t.jsx)(i.a,{href:"https://github.com/rspamd/maps/",children:"https://github.com/rspamd/maps/"}),"\nReasonable pull requests are very welcome."]}),"\n",(0,t.jsx)(i.h3,{id:"optional-settings",children:"Optional settings"}),"\n",(0,t.jsx)(i.p,{children:"You can also set the default metric settings using the ordinary attributes, such as:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"score"}),": default score"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"group"}),": default group (",(0,t.jsx)(i.code,{children:"whitelist"})," group is used if not specified explicitly)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"one_shot"}),": default one shot mode"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"description"}),": default description"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["In lists, you also have the option to include an optional ",(0,t.jsx)(i.code,{children:"multiplier"})," argument, which specifies an additional multiplier for the score assigned by this module. For instance, if you want to assign a score twice as large for ",(0,t.jsx)(i.code,{children:"github.com"}),", you can define it as follows:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:'["github.com", 2.0]\n'})}),"\n",(0,t.jsx)(i.p,{children:"or if using map:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"github.com 2.0\n"})}),"\n",(0,t.jsx)(i.h3,{id:"note-with-regard-to-dkim-whitelist",children:"Note with regard to DKIM whitelist"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"valid_dkim = true"})," check goes beyond verifying the triggering of just ",(0,t.jsx)(i.code,{children:"R_DKIM_ALLOW"}),". It also ensures that the DKIM domain being validated matches the domain in the FROM envelope. Therefore, if a message is sent by a sender with the domain ",(0,t.jsx)(i.code,{children:"x.com"})," but has been DKIM signed by ",(0,t.jsx)(i.code,{children:"mailchimp.app"}),", the ",(0,t.jsx)(i.code,{children:"valid_dkim"})," flag will not be set to true, and the whitelist rule will not be triggered"]}),"\n",(0,t.jsx)(i.h2,{id:"configuration-example",children:"Configuration example"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-hcl",children:'whitelist {\n    rules {\n        WHITELIST_SPF = {\n            valid_spf = true;\n            domains = [\n                "github.com",\n            ];\n            score = -1.0;\n        }\n\n        WHITELIST_DKIM = {\n            valid_dkim = true;\n            domains = [\n                "github.com",\n            ];\n            score = -2.0;\n        }\n\n        WHITELIST_SPF_DKIM = {\n            valid_spf = true;\n            valid_dkim = true;\n            domains = [\n                ["github.com", 2.0],\n            ];\n            score = -3.0;\n        }\n\n        STRICT_SPF_DKIM = {\n            valid_spf = true;\n            valid_dkim = true;\n            strict = true;\n            domains = [\n                ["paypal.com", 2.0],\n            ];\n            score = -3.0; # For strict rules negative score should be defined\n        }\n\n        BLACKLIST_DKIM = {\n            valid_spf = true;\n            valid_dkim = true;\n            blacklist = true;\n            domains = "/some/file/blacklist_dkim.map";\n            score = 3.0; # Note positive score here\n        }\n\n        WHITELIST_DMARC_DKIM = {\n            valid_dkim = true;\n            valid_dmarc = true;\n            domains = [\n                "github.com",\n            ];\n            score = -7.0;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(i.p,{children:"Rspamd also provides a collection of pre-defined whitelisted domains that can be beneficial for getting started."})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>o,x:()=>r});var n=s(6540);const t={},l=n.createContext(t);function o(e){const i=n.useContext(l);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),n.createElement(l.Provider,{value:i},e.children)}}}]);