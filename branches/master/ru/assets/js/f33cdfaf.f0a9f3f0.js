"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[543],{12579:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"developers/encryption","title":"HTTPCrypt Encryption Protocol","description":"Overview","source":"@site/docs/developers/encryption.md","sourceDirName":"developers","slug":"/developers/encryption","permalink":"/docs.rspamd.com/branches/master/ru/developers/encryption","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/developers/encryption.md","tags":[],"version":"current","frontMatter":{"title":"HTTPCrypt Encryption Protocol"},"sidebar":"docs","previous":{"title":"Rspamd protocol","permalink":"/docs.rspamd.com/branches/master/ru/developers/protocol"},"next":{"title":"Coroutines and async calls","permalink":"/docs.rspamd.com/branches/master/ru/developers/sync_async"}}');var i=r(74848),t=r(28453);const l={title:"HTTPCrypt Encryption Protocol"},c="HTTPCrypt Encryption Protocol",d={},a=[{value:"Overview",id:"overview",level:2},{value:"Cryptographic Primitives",id:"cryptographic-primitives",level:2},{value:"X25519 (Curve25519)",id:"x25519-curve25519",level:3},{value:"XChaCha20",id:"xchacha20",level:3},{value:"Poly1305",id:"poly1305",level:3},{value:"HChaCha20",id:"hchacha20",level:3},{value:"Blake2b",id:"blake2b",level:3},{value:"Key Generation and Management",id:"key-generation-and-management",level:2},{value:"Long-term Server Keys",id:"long-term-server-keys",level:3},{value:"Ephemeral Client Keys",id:"ephemeral-client-keys",level:3},{value:"Key Identification Header",id:"key-identification-header",level:3},{value:"Session Key Derivation (ECDH)",id:"session-key-derivation-ecdh",level:2},{value:"Step 1: Scalar Multiplication",id:"step-1-scalar-multiplication",level:3},{value:"Step 2: HChaCha20 Key Derivation",id:"step-2-hchacha20-key-derivation",level:3},{value:"Encryption Process",id:"encryption-process",level:2},{value:"Message Authentication Code (MAC) Key Derivation",id:"message-authentication-code-mac-key-derivation",level:3},{value:"Encryption Algorithm",id:"encryption-algorithm",level:3},{value:"Wire Format",id:"wire-format",level:3},{value:"Decryption Process",id:"decryption-process",level:2},{value:"HTTPCrypt Protocol Flow",id:"httpcrypt-protocol-flow",level:2},{value:"Client Request Encryption",id:"client-request-encryption",level:3},{value:"1. Prepare Inner Request",id:"1-prepare-inner-request",level:4},{value:"2. Generate Ephemeral Keypair",id:"2-generate-ephemeral-keypair",level:4},{value:"3. Perform ECDH",id:"3-perform-ecdh",level:4},{value:"4. Encrypt Inner Request",id:"4-encrypt-inner-request",level:4},{value:"5. Build Outer Request",id:"5-build-outer-request",level:4},{value:"Server Response Decryption",id:"server-response-decryption",level:3},{value:"1. Server Uses Same Shared Secret",id:"1-server-uses-same-shared-secret",level:4},{value:"2. Encrypt Response",id:"2-encrypt-response",level:4},{value:"3. Client Decrypts",id:"3-client-decrypts",level:4},{value:"Complete Example",id:"complete-example",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Strengths",id:"strengths",level:3},{value:"Limitations and Considerations",id:"limitations-and-considerations",level:3},{value:"Attack Resistance",id:"attack-resistance",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Key Encoding",id:"key-encoding",level:3},{value:"Memory Safety",id:"memory-safety",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Testing",id:"testing",level:3},{value:"Compatibility",id:"compatibility",level:3},{value:"Client Developer Guide",id:"client-developer-guide",level:2},{value:"Quick Start Checklist",id:"quick-start-checklist",level:3},{value:"Recommended Libraries by Language",id:"recommended-libraries-by-language",level:3},{value:"Step-by-Step Implementation",id:"step-by-step-implementation",level:3},{value:"Step 1: Parse Server&#39;s Public Key",id:"step-1-parse-servers-public-key",level:4},{value:"Step 2: Generate Key ID",id:"step-2-generate-key-id",level:4},{value:"Step 3: Generate Ephemeral Keypair",id:"step-3-generate-ephemeral-keypair",level:4},{value:"Step 4: Perform ECDH and Derive Shared Secret",id:"step-4-perform-ecdh-and-derive-shared-secret",level:4},{value:"Step 5: Build the Key Header",id:"step-5-build-the-key-header",level:4},{value:"Step 6: Encrypt the Request",id:"step-6-encrypt-the-request",level:4},{value:"Step 7: Send the Request",id:"step-7-send-the-request",level:4},{value:"Step 8: Decrypt the Response",id:"step-8-decrypt-the-response",level:4},{value:"Why You Should Use Official Implementations",id:"why-you-should-use-official-implementations",level:3},{value:"Verifying Your Implementation",id:"verifying-your-implementation",level:3},{value:"Reference Implementations",id:"reference-implementations",level:3},{value:"Testing Your Implementation",id:"testing-your-implementation",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:3},{value:"Code References",id:"code-references",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"httpcrypt-encryption-protocol",children:"HTTPCrypt Encryption Protocol"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Rspamd implements the HTTPCrypt protocol for encrypting client-server communications. HTTPCrypt is a lightweight encryption protocol that predates RFC 8439 but uses similar cryptographic primitives: X25519 for key exchange, XChaCha20 for encryption, and Poly1305 for authentication. However, it employs custom key derivation methods that differ from standard IETF approaches."}),"\n",(0,i.jsx)(n.p,{children:"The protocol provides:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authenticated encryption"})," using XChaCha20-Poly1305"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Forward secrecy"})," through ephemeral key exchange"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compact wire format"})," optimized for HTTP communication"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Strong security"})," based on modern elliptic curve cryptography"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"cryptographic-primitives",children:"Cryptographic Primitives"}),"\n",(0,i.jsx)(n.p,{children:"HTTPCrypt combines several well-established cryptographic algorithms:"}),"\n",(0,i.jsx)(n.h3,{id:"x25519-curve25519",children:"X25519 (Curve25519)"}),"\n",(0,i.jsx)(n.p,{children:"Used for Elliptic Curve Diffie-Hellman (ECDH) key exchange. X25519 provides:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"128-bit security level"}),"\n",(0,i.jsx)(n.li,{children:"Fast constant-time operations"}),"\n",(0,i.jsx)(n.li,{children:"Small key size (32 bytes)"}),"\n",(0,i.jsx)(n.li,{children:"Protection against side-channel attacks"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"xchacha20",children:"XChaCha20"}),"\n",(0,i.jsx)(n.p,{children:"A stream cipher variant of ChaCha20 with extended nonce size:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"24-byte (192-bit) nonces instead of ChaCha20's 12-byte nonces"}),"\n",(0,i.jsx)(n.li,{children:"256-bit keys"}),"\n",(0,i.jsx)(n.li,{children:"High performance on all platforms"}),"\n",(0,i.jsx)(n.li,{children:"No timing side channels"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"poly1305",children:"Poly1305"}),"\n",(0,i.jsx)(n.p,{children:"A cryptographic message authentication code (MAC):"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"128-bit security level"}),"\n",(0,i.jsx)(n.li,{children:"One-time MAC requiring unique key per message"}),"\n",(0,i.jsx)(n.li,{children:"Fast computation"}),"\n",(0,i.jsx)(n.li,{children:"Used in encrypt-then-MAC construction"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"hchacha20",children:"HChaCha20"}),"\n",(0,i.jsx)(n.p,{children:"A key derivation function based on ChaCha20:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Takes 32-byte key and 16-byte nonce"}),"\n",(0,i.jsx)(n.li,{children:"Produces 32-byte derived key"}),"\n",(0,i.jsx)(n.li,{children:"Used for XChaCha20 nonce extension and custom key derivation"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"blake2b",children:"Blake2b"}),"\n",(0,i.jsx)(n.p,{children:"A cryptographic hash function used for key identification:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Faster than SHA-2 and SHA-3"}),"\n",(0,i.jsx)(n.li,{children:"Provides 512-bit output (though only first 5 bytes used for key IDs)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-generation-and-management",children:"Key Generation and Management"}),"\n",(0,i.jsx)(n.h3,{id:"long-term-server-keys",children:"Long-term Server Keys"}),"\n",(0,i.jsx)(n.p,{children:"The server maintains a long-term key pair for identification and key exchange:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"rspamadm keypair\n"})}),"\n",(0,i.jsx)(n.p,{children:"This generates:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'keypair {\n    privkey = "e4gr3yuw4xiy6dikdpqus8cmxj8c6pqstt448ycwhewhhrtxdahy";\n    id = "gnyieumi6sp6d3yaq13q4u6xycmiqaw7iahsrz97acpposod1x8zogynnishtgxr47o815dgsz9t69d66jcm1drjei4a5d";\n    pubkey = "fg8uwtce9sta43sdwzddb11iez5thcskiufj4ug8esyfniqq5iiy";\n    type = "kex";\n    algorithm = "curve25519";\n    encoding = "base32";\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Components:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"privkey"}),": Server's private key (32 bytes, zbase32-encoded)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"pubkey"}),": Server's public key (32 bytes, zbase32-encoded)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"id"}),": Full key identifier derived from the public key"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"algorithm"}),": Always ",(0,i.jsx)(n.code,{children:"curve25519"})," for HTTPCrypt"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"encoding"}),": Always ",(0,i.jsx)(n.code,{children:"base32"})," in the config file, but the actual encoding is ",(0,i.jsx)(n.strong,{children:"zbase32"})," (alphabet: ",(0,i.jsx)(n.code,{children:"ybndrfg8ejkmcpqxot1uwisza345h769"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"ephemeral-client-keys",children:"Ephemeral Client Keys"}),"\n",(0,i.jsx)(n.p,{children:"For each encrypted request, the client generates a fresh ephemeral keypair:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let local_sk = SecretKey::generate(&mut OsRng);\nlet local_pk = local_sk.public_key();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This provides ",(0,i.jsx)(n.strong,{children:"forward secrecy"}),": even if the server's long-term key is compromised, past communications remain secure because ephemeral keys are discarded immediately after use."]}),"\n",(0,i.jsx)(n.h3,{id:"key-identification-header",children:"Key Identification Header"}),"\n",(0,i.jsxs)(n.p,{children:["The client sends a ",(0,i.jsx)(n.code,{children:"Key"})," header to identify which server public key was used and provide the client's ephemeral public key:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Key: <short_key_id>=<client_ephemeral_pubkey>\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"short_key_id"}),": First 5 bytes of Blake2b hash of server's public key, zbase32-encoded"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"client_ephemeral_pubkey"}),": Client's ephemeral public key, zbase32-encoded"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Key: kbr3m=k4nz984k36xmcynm1hr9kdbn6jhcxf4ggbrb1quay7f88rpm9kay\n"})}),"\n",(0,i.jsx)(n.p,{children:"The short key ID allows the server to quickly identify which of its keys should be used when it has multiple keys configured."}),"\n",(0,i.jsx)(n.h2,{id:"session-key-derivation-ecdh",children:"Session Key Derivation (ECDH)"}),"\n",(0,i.jsx)(n.p,{children:"HTTPCrypt uses a custom ECDH key derivation that differs from standard X25519 usage:"}),"\n",(0,i.jsx)(n.h3,{id:"step-1-scalar-multiplication",children:"Step 1: Scalar Multiplication"}),"\n",(0,i.jsx)(n.p,{children:"Standard X25519 scalar multiplication is performed between the client's ephemeral private key and the server's public key:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Clamp the private key according to X25519 spec\nlet e = Scalar::from_bytes_mod_order(clamp_integer(local_sk.to_bytes()));\nlet p = MontgomeryPoint(remote_pk);\nlet shared_point = e * p;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Clamping:"}),' The private key is "clamped" before use:']}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Clear bits 0, 1, 2 of the first byte (sets lowest 3 bits to 0)"}),"\n",(0,i.jsx)(n.li,{children:"Clear bit 7 of the last byte (clears top bit)"}),"\n",(0,i.jsx)(n.li,{children:"Set bit 6 of the last byte (sets second-highest bit)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This ensures the scalar is in the correct range for X25519 and avoids small subgroup attacks."}),"\n",(0,i.jsx)(n.h3,{id:"step-2-hchacha20-key-derivation",children:"Step 2: HChaCha20 Key Derivation"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"This is where HTTPCrypt diverges from standard practice."})}),"\n",(0,i.jsx)(n.p,{children:"Standard X25519 usage (RFC 7748) would use the shared point directly or hash it with additional context. HTTPCrypt instead applies HChaCha20 with a zero nonce:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"fn rspamd_x25519_ecdh(point: MontgomeryPoint) -> RspamdNM {\n    let n0 = [0u8; 16];  // Zero nonce\n    hchacha::<U10>(&point.to_bytes().into(), &n0)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"HChaCha20 Operation:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Initialize ChaCha20 state with:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'Constants: "expand 32-byte k" (ChaCha20 constants)'}),"\n",(0,i.jsx)(n.li,{children:"Key: The 32-byte shared point from X25519"}),"\n",(0,i.jsx)(n.li,{children:"Nonce: 16 zero bytes"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Execute 20 rounds of ChaCha20 permutation (10 double-rounds)"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Output: Concatenate state words [0..3] and [12..15] (first 128 bits + last 128 bits)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This produces a 32-byte ",(0,i.jsx)(n.strong,{children:"shared secret"})," (called ",(0,i.jsx)(n.code,{children:"nm"}),' in the code, standing for "NaCl-style shared secret").']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Security Note:"})," While non-standard, this approach is cryptographically sound. HChaCha20 acts as a key derivation function, providing additional mixing and ensuring the derived key is uniformly distributed."]}),"\n",(0,i.jsx)(n.h2,{id:"encryption-process",children:"Encryption Process"}),"\n",(0,i.jsx)(n.h3,{id:"message-authentication-code-mac-key-derivation",children:"Message Authentication Code (MAC) Key Derivation"}),"\n",(0,i.jsx)(n.p,{children:"Before encrypting, a one-time Poly1305 MAC key must be derived. HTTPCrypt uses a custom method:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn new(key: RspamdNM, nonce: chacha20::XNonce) -> Self {\n    let mut chacha = XChaCha20::new_from_slices(key.as_slice(), nonce.as_slice()).unwrap();\n    let mut mac_key: GenericArray<u8, U64> = GenericArray::default(); // 64 zero bytes\n    chacha.apply_keystream(mac_key.as_mut());\n    let poly = Poly1305::new_from_slice(mac_key.split_at(32).0).unwrap();\n    // chacha context remains positioned for encryption\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Process:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Initialize XChaCha20 with:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Shared secret (32 bytes) as key"}),"\n",(0,i.jsx)(n.li,{children:"Random nonce (24 bytes)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Generate 64 zero bytes"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Encrypt these zero bytes with XChaCha20, producing keystream bytes"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Take first 32 bytes as the Poly1305 MAC key"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Important:"})," The XChaCha20 cipher context is now positioned at byte offset 64"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This approach is similar to the original ChaCha20-Poly1305 construction but uses 64 bytes instead of the RFC's 32 bytes for key material derivation."}),"\n",(0,i.jsx)(n.h3,{id:"encryption-algorithm",children:"Encryption Algorithm"}),"\n",(0,i.jsx)(n.p,{children:"With the MAC key derived and cipher positioned, encryption proceeds:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn encrypt_in_place(mut self, data: &mut [u8]) -> Tag {\n    // Encrypt\n    self.enc_ctx.apply_keystream(data);\n    // Authenticate (encrypt-then-MAC)\n    self.mac_ctx.compute_unpadded(data)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Process:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Encrypt the plaintext"})," using XChaCha20 (which is already positioned at offset 64)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compute MAC"})," over the ciphertext using Poly1305"]}),"\n",(0,i.jsx)(n.li,{children:"Return the 16-byte authentication tag"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This is an ",(0,i.jsx)(n.strong,{children:"encrypt-then-MAC"})," construction, which is the secure approach (as opposed to MAC-then-encrypt or encrypt-and-MAC)."]}),"\n",(0,i.jsx)(n.h3,{id:"wire-format",children:"Wire Format"}),"\n",(0,i.jsx)(n.p,{children:"The encrypted message format is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"+----------------------+\n| Nonce (24 bytes)    |\n+----------------------+\n| Tag (16 bytes)      |\n+----------------------+\n| Ciphertext (N bytes)|\n+----------------------+\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Field Details:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Nonce (24 bytes)"}),": Random nonce generated for this message, sent in plaintext"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tag (16 bytes)"}),": Poly1305 authentication tag over the ciphertext"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ciphertext (N bytes)"}),": XChaCha20-encrypted payload"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Total overhead: 40 bytes per message."}),"\n",(0,i.jsx)(n.h2,{id:"decryption-process",children:"Decryption Process"}),"\n",(0,i.jsx)(n.p,{children:"Decryption reverses the encryption process with authentication verification:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'pub fn decrypt_in_place(&mut self, data: &mut [u8], tag: &Tag) -> Result<usize, RspamdError> {\n    // Verify MAC first\n    let computed = self.mac_ctx.clone().compute_unpadded(data);\n    if computed != *tag {\n        return Err(RspamdError::EncryptionError("Authentication failed".to_string()));\n    }\n    // Decrypt only if authentication succeeds\n    self.enc_ctx.apply_keystream(&mut data[..]);\n    Ok(computed.len())\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Process:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Parse the message:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Extract 24-byte nonce"}),"\n",(0,i.jsx)(n.li,{children:"Extract 16-byte tag"}),"\n",(0,i.jsx)(n.li,{children:"Remaining bytes are ciphertext"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Derive shared secret using same ECDH process"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Initialize XChaCha20 with shared secret and nonce"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Derive MAC key (64 zero bytes through cipher)"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Verify authentication tag:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Compute Poly1305 MAC over ciphertext"}),"\n",(0,i.jsx)(n.li,{children:"Compare with received tag using constant-time comparison"}),"\n",(0,i.jsxs)(n.li,{children:["If mismatch, ",(0,i.jsx)(n.strong,{children:"fail immediately"})," and return error"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Decrypt ciphertext"})," (only if authentication succeeds):"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Re-initialize cipher (or use positioned context)"}),"\n",(0,i.jsx)(n.li,{children:"Apply XChaCha20 keystream to ciphertext"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Security:"})," Authentication is verified ",(0,i.jsx)(n.strong,{children:"before"})," decryption to prevent oracle attacks and ensure ciphertext integrity."]}),"\n",(0,i.jsx)(n.h2,{id:"httpcrypt-protocol-flow",children:"HTTPCrypt Protocol Flow"}),"\n",(0,i.jsx)(n.h3,{id:"client-request-encryption",children:"Client Request Encryption"}),"\n",(0,i.jsx)(n.p,{children:"When a client sends an encrypted request:"}),"\n",(0,i.jsx)(n.h4,{id:"1-prepare-inner-request",children:"1. Prepare Inner Request"}),"\n",(0,i.jsx)(n.p,{children:"Build a complete HTTP request as plaintext:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"POST /checkv2 HTTP/1.1\nFrom: user@example.com\nIP: 192.0.2.1\nContent-Length: 1234\n\n<message body>\n"})}),"\n",(0,i.jsx)(n.p,{children:"This inner request contains all the actual headers and body."}),"\n",(0,i.jsx)(n.h4,{id:"2-generate-ephemeral-keypair",children:"2. Generate Ephemeral Keypair"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let local_sk = SecretKey::generate(&mut OsRng);\nlet local_pk = local_sk.public_key();\n"})}),"\n",(0,i.jsx)(n.h4,{id:"3-perform-ecdh",children:"3. Perform ECDH"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let ec_point = rspamd_x25519_scalarmult(server_public_key, &local_sk)?;\nlet shared_secret = rspamd_x25519_ecdh(ec_point);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"4-encrypt-inner-request",children:"4. Encrypt Inner Request"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let nonce = ChaChaBox::generate_nonce(&mut OsRng);\nlet cbox = RspamdSecretbox::new(shared_secret, nonce);\nlet tag = cbox.encrypt_in_place(&mut ciphertext);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"5-build-outer-request",children:"5. Build Outer Request"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:"POST /checkv2 HTTP/1.1\nContent-Length: <encrypted_length>\nKey: kbr3m=k4nz984k36xmcynm1hr9kdbn6jhcxf4ggbrb1quay7f88rpm9kay\n\n<nonce (24 bytes)><tag (16 bytes)><ciphertext>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Key"})," header contains:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Short ID of server's public key (5 bytes, zbase32)"}),"\n",(0,i.jsx)(n.li,{children:"Client's ephemeral public key (32 bytes, zbase32)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"server-response-decryption",children:"Server Response Decryption"}),"\n",(0,i.jsx)(n.p,{children:"The server can also encrypt responses using the same shared secret:"}),"\n",(0,i.jsx)(n.h4,{id:"1-server-uses-same-shared-secret",children:"1. Server Uses Same Shared Secret"}),"\n",(0,i.jsx)(n.p,{children:"The server computes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let ec_point = rspamd_x25519_scalarmult(client_ephemeral_pk, &server_sk)?;\nlet shared_secret = rspamd_x25519_ecdh(ec_point);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This produces the ",(0,i.jsx)(n.strong,{children:"same shared secret"})," due to ECDH properties:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Client: ",(0,i.jsx)(n.code,{children:"ECDH(client_ephemeral_sk, server_pk) = shared_secret"})]}),"\n",(0,i.jsxs)(n.li,{children:["Server: ",(0,i.jsx)(n.code,{children:"ECDH(server_sk, client_ephemeral_pk) = shared_secret"})]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"2-encrypt-response",children:"2. Encrypt Response"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:"HTTP/1.1 200 OK\nContent-Length: <encrypted_length>\n\n<nonce (24 bytes)><tag (16 bytes)><encrypted JSON response>\n"})}),"\n",(0,i.jsx)(n.h4,{id:"3-client-decrypts",children:"3. Client Decrypts"}),"\n",(0,i.jsx)(n.p,{children:"The client uses the stored shared secret (from step 3 of request encryption) to decrypt the response."}),"\n",(0,i.jsx)(n.h3,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Client sends:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:"POST /checkv2 HTTP/1.1\nHost: rspamd.example.com\nContent-Type: application/octet-stream\nContent-Length: 1540\nKey: kbr3m=k4nz984k36xmcynm1hr9kdbn6jhcxf4ggbrb1quay7f88rpm9kay\n\n<24-byte nonce><16-byte tag><1500 bytes encrypted inner request>\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Server responds:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:"HTTP/1.1 200 OK\nContent-Type: application/octet-stream\nContent-Length: 556\n\n<24-byte nonce><16-byte tag><500 bytes encrypted JSON response>\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"strengths",children:"Strengths"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Forward Secrecy"}),": Ephemeral key exchange ensures past messages cannot be decrypted even if server's long-term key is compromised."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Authenticated Encryption"}),": Poly1305 MAC provides strong authentication, preventing tampering and detecting corruption."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Modern Cryptography"}),": Based on well-analyzed primitives (Curve25519, ChaCha20, Poly1305)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Constant-Time Operations"}),": Implementations use constant-time comparison for MACs and constant-time X25519."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Nonce Collision Resistance"}),": 24-byte nonces (XChaCha20) provide enormous keyspace (2^192), making collisions virtually impossible with random generation."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"limitations-and-considerations",children:"Limitations and Considerations"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Non-Standard Key Derivation"}),": The use of HChaCha20 with zero nonce for ECDH key derivation is non-standard. While not insecure, it differs from RFC 7748 recommendations."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"No Replay Protection"}),": HTTPCrypt itself doesn't provide replay protection. Applications should implement this at a higher layer if needed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"No Key Confirmation"}),": The protocol doesn't include explicit key confirmation. Authentication failures are detected during MAC verification."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"MAC Key Derivation"}),": Uses 64 zero bytes through cipher instead of RFC 8439's 32 bytes. This is a design choice from the pre-RFC era but remains secure."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Single-Use Ephemeral Keys"}),": Each request requires a new ephemeral keypair generation, which adds computational cost but ensures forward secrecy."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"No Explicit Version Negotiation"}),": The protocol has no version field. Any changes would require out-of-band negotiation."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"attack-resistance",children:"Attack Resistance"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Chosen Ciphertext Attacks (CCA):"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Protected by encrypt-then-MAC construction"}),"\n",(0,i.jsx)(n.li,{children:"MAC verification before decryption prevents oracle attacks"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Compromise:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Forward secrecy limits damage from server key compromise"}),"\n",(0,i.jsx)(n.li,{children:"Past communications remain secure"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Timing Attacks:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Constant-time operations in X25519 and MAC verification"}),"\n",(0,i.jsx)(n.li,{children:"Constant-time comparison prevents timing leaks"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Small Subgroup Attacks:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prevented by X25519 key clamping"}),"\n",(0,i.jsx)(n.li,{children:"Curve25519 is designed to resist these attacks"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,i.jsx)(n.h3,{id:"key-encoding",children:"Key Encoding"}),"\n",(0,i.jsxs)(n.p,{children:["All keys use a ",(0,i.jsx)(n.strong,{children:"modified zbase32"})," encoding with non-standard bit ordering:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Alphabet: ",(0,i.jsx)(n.code,{children:"ybndrfg8ejkmcpqxot1uwisza345h769"})]}),"\n",(0,i.jsx)(n.li,{children:"Designed to be human-friendly (avoids visually similar characters like 0/O, 1/l)"}),"\n",(0,i.jsx)(n.li,{children:"Case insensitive for decoding"}),"\n",(0,i.jsx)(n.li,{children:"No padding characters"}),"\n",(0,i.jsx)(n.li,{children:"Compact representation (32 bytes \u2192 52 characters)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"IMPORTANT - Non-standard bit ordering:"})," Rspamd's zbase32 implementation uses ",(0,i.jsx)(n.strong,{children:"inverted bit order"})," compared to standard base32 implementations. This is a historical artifact from when the implementation was created before any RFCs or test vectors existed. Standard zbase32 libraries will ",(0,i.jsx)(n.strong,{children:"NOT"})," produce correct results!"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Test vectors for verification:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Input"}),(0,i.jsx)(n.th,{children:"Rspamd zbase32 output"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"hello"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"em3ags7p"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"test123"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"wm3g84fg13cy"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"a"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bd"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"aaaaa"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bmansofc"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Compare with RFC 4648 base32 (different!):"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Input"}),(0,i.jsx)(n.th,{children:"RFC 4648 output"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"hello"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"NBSWY3DP"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"a"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ME"})})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Strongly recommended:"})," Use the official implementations from ",(0,i.jsx)(n.a,{href:"https://github.com/vstakhov/rust-base32",children:"rspamd_base32"})," (Rust) or the Go equivalent in rspamdclient-go rather than implementing your own."]}),"\n",(0,i.jsx)(n.h3,{id:"memory-safety",children:"Memory Safety"}),"\n",(0,i.jsx)(n.p,{children:"Implementations should:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero sensitive data"}),": Clear private keys, shared secrets, and MAC keys after use"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use secure allocators"}),": Consider using locked memory for key material"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Avoid copying keys"}),": Use move semantics or references when possible"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Rust example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use crypto_box::cipher::zeroize::Zeroizing;\ntype RspamdNM = Zeroizing<GenericArray<u8, U32>>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Zeroizing"})," wrapper ensures the memory is zeroed when dropped."]}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.p,{children:"Critical errors that must be handled:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authentication Failure"}),": Never proceed with decryption if MAC verification fails"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Invalid Key Length"}),": Reject keys that aren't exactly 32 bytes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Malformed Messages"}),": Check minimum message length (24 + 16 bytes) before parsing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"zbase32 Decode Errors"}),": Handle invalid zbase32 encoding gracefully (invalid characters, wrong length)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Fast operations:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"X25519 scalar multiplication: ~50-100 microseconds on modern CPUs"}),"\n",(0,i.jsx)(n.li,{children:"XChaCha20 encryption: ~1-2 GB/s throughput"}),"\n",(0,i.jsx)(n.li,{children:"Poly1305 MAC: ~1-2 GB/s throughput"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Slow operations:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ephemeral keypair generation: Requires random number generation"}),"\n",(0,i.jsx)(n.li,{children:"Key encoding/decoding: Base32 conversion adds overhead"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Optimization tips:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reuse server keypair (don't regenerate for each request)"}),"\n",(0,i.jsx)(n.li,{children:"Consider connection pooling to amortize key exchange costs"}),"\n",(0,i.jsx)(n.li,{children:"Use vectorized implementations of ChaCha20 when available"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"testing",children:"Testing"}),"\n",(0,i.jsx)(n.p,{children:"Implementations should verify:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Known Answer Tests (KAT)"}),": Test against known test vectors"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Round-trip"}),": Encrypt and decrypt should return original plaintext"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authentication"}),": Modified ciphertext should fail MAC verification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Interoperability"}),": Test against reference implementations (Rust/Go clients, Rspamd server)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"compatibility",children:"Compatibility"}),"\n",(0,i.jsx)(n.p,{children:"HTTPCrypt is implemented in:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rspamd server"})," (C): Built-in support in all workers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"rspamc client"})," (C): Command-line client"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rspamd proxy"}),": Can act as encryption bridge"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"rspamdclient-rs"})," (Rust): Full client library"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"rspamdclient-go"})," (Go): Full client library"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"All implementations use the same wire format and are fully interoperable."}),"\n",(0,i.jsx)(n.h2,{id:"client-developer-guide",children:"Client Developer Guide"}),"\n",(0,i.jsx)(n.p,{children:"This section provides practical guidance for developers implementing HTTPCrypt clients in various programming languages."}),"\n",(0,i.jsx)(n.h3,{id:"quick-start-checklist",children:"Quick Start Checklist"}),"\n",(0,i.jsx)(n.p,{children:"To implement an HTTPCrypt client, you need:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"X25519 library"})," for elliptic curve Diffie-Hellman key exchange"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"XChaCha20 implementation"})," for encryption/decryption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Poly1305 implementation"})," for message authentication"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"HChaCha20 function"})," for key derivation (often included in XChaCha20 libraries)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rspamd's modified zbase32"})," - uses inverted bit order; standard zbase32 libraries won't work!"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Warning:"})," Due to the non-standard zbase32 encoding and custom HChaCha20 key derivation, we ",(0,i.jsx)(n.strong,{children:"strongly recommend"})," using or porting the official client implementations rather than building from scratch:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rust"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-rs",children:"rspamdclient-rs"})," with ",(0,i.jsx)(n.a,{href:"https://github.com/vstakhov/rust-base32",children:"rspamd_base32"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Go"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-go",children:"rspamdclient-go"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"recommended-libraries-by-language",children:"Recommended Libraries by Language"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Language"}),(0,i.jsx)(n.th,{children:"Recommended Libraries"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Rust"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"crypto_box"}),", ",(0,i.jsx)(n.code,{children:"chacha20poly1305"}),", ",(0,i.jsx)(n.code,{children:"x25519-dalek"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Go"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"golang.org/x/crypto/chacha20poly1305"}),", ",(0,i.jsx)(n.code,{children:"golang.org/x/crypto/curve25519"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Python"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"pynacl"}),", ",(0,i.jsx)(n.code,{children:"cryptography"})," (requires custom HChaCha20 wrapper)"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"JavaScript/Node.js"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"tweetnacl"}),", ",(0,i.jsx)(n.code,{children:"@stablelib/xchacha20poly1305"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"C/C++"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"libsodium"}),", ",(0,i.jsx)(n.code,{children:"monocypher"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Java"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Tink"}),", ",(0,i.jsx)(n.code,{children:"BouncyCastle"})," (requires custom implementation)"]})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"step-by-step-implementation",children:"Step-by-Step Implementation"}),"\n",(0,i.jsx)(n.h4,{id:"step-1-parse-servers-public-key",children:"Step 1: Parse Server's Public Key"}),"\n",(0,i.jsx)(n.p,{children:"The server's public key is provided in Rspamd's modified zbase32 format."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Important:"})," Rspamd uses a non-standard zbase32 with inverted bit ordering. Standard zbase32 implementations will produce incorrect results. You must use:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.a,{href:"https://github.com/vstakhov/rust-base32",children:"rspamd_base32"})," Rust crate"]}),"\n",(0,i.jsxs)(n.li,{children:["The Go implementation from ",(0,i.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-go",children:"rspamdclient-go"})]}),"\n",(0,i.jsx)(n.li,{children:"Or port the bit-inverted algorithm from these implementations"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Using rspamd_base32 crate (Rust)\nuse rspamd_base32::decode;\n\nlet server_pubkey = decode("fg8uwtce9sta43sdwzddb11iez5thcskiufj4ug8esyfniqq5iiy")\n    .expect("Invalid zbase32");\n'})}),"\n",(0,i.jsx)(n.p,{children:"Test your implementation against these vectors:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"hello"'})," \u2192 ",(0,i.jsx)(n.code,{children:'"em3ags7p"'})," (encoding)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"em3ags7p"'})," \u2192 ",(0,i.jsx)(n.code,{children:'"hello"'})," (decoding)"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"step-2-generate-key-id",children:"Step 2: Generate Key ID"}),"\n",(0,i.jsx)(n.p,{children:"Calculate the short key ID from the server's public key using Blake2b hash and zbase32 encoding:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Using rspamd_base32 crate (Rust)\nuse blake2::{Blake2b, Digest};\nuse rspamd_base32::encode;\n\nfn calculate_key_id(pubkey: &[u8]) -> String {\n    let mut hasher = Blake2b::new();\n    hasher.update(pubkey);\n    let hash = hasher.finalize();\n    // Take first 5 bytes and encode with Rspamd\'s zbase32\n    encode(&hash[..5])\n}\n\nlet key_id = calculate_key_id(&server_pubkey);  // e.g., "kbr3m"\n'})}),"\n",(0,i.jsx)(n.h4,{id:"step-3-generate-ephemeral-keypair",children:"Step 3: Generate Ephemeral Keypair"}),"\n",(0,i.jsx)(n.p,{children:"For each request, generate a new ephemeral keypair:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey\n\nephemeral_private = X25519PrivateKey.generate()\nephemeral_public = ephemeral_private.public_key()\n"})}),"\n",(0,i.jsx)(n.h4,{id:"step-4-perform-ecdh-and-derive-shared-secret",children:"Step 4: Perform ECDH and Derive Shared Secret"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from cryptography.hazmat.primitives import serialization\n\n# Standard X25519 ECDH\nshared_point = ephemeral_private.exchange(server_pubkey_obj)\n\n# HTTPCrypt-specific: Apply HChaCha20 with zero nonce\n# This step differs from standard X25519 usage!\ndef hchacha20(key: bytes, nonce: bytes) -> bytes:\n    """HChaCha20 key derivation - custom implementation needed"""\n    # See implementation details in the main documentation\n    pass\n\nzero_nonce = bytes(16)\nshared_secret = hchacha20(shared_point, zero_nonce)\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Important:"})," The HChaCha20 step is non-standard. Most X25519 libraries don't include this. You may need to:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use a library that exposes HChaCha20 (like libsodium's ",(0,i.jsx)(n.code,{children:"crypto_core_hchacha20"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Implement HChaCha20 yourself (it's the ChaCha20 quarter-round applied 20 times)"}),"\n",(0,i.jsx)(n.li,{children:"Use a reference implementation from rspamdclient-rs or rspamdclient-go"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"step-5-build-the-key-header",children:"Step 5: Build the Key Header"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use rspamd_base32::encode;\n\nlet ephemeral_pub_bytes = ephemeral_public.as_bytes();\nlet key_header = format!("{}={}", key_id, encode(ephemeral_pub_bytes));\n'})}),"\n",(0,i.jsx)(n.h4,{id:"step-6-encrypt-the-request",children:"Step 6: Encrypt the Request"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import os\n\ndef encrypt_request(shared_secret: bytes, plaintext: bytes) -> bytes:\n    # Generate random 24-byte nonce\n    nonce = os.urandom(24)\n    \n    # Initialize XChaCha20 with shared_secret and nonce\n    # Derive MAC key: encrypt 64 zero bytes, take first 32 as Poly1305 key\n    # Encrypt plaintext (cipher is now at offset 64)\n    # Compute Poly1305 tag over ciphertext\n    \n    # Return: nonce (24) + tag (16) + ciphertext\n    return nonce + tag + ciphertext\n"})}),"\n",(0,i.jsx)(n.h4,{id:"step-7-send-the-request",children:"Step 7: Send the Request"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import requests\n\ninner_request = b\"POST /checkv2 HTTP/1.1\\r\\nContent-Length: 100\\r\\n\\r\\n<message>\"\nencrypted_body = encrypt_request(shared_secret, inner_request)\n\nresponse = requests.post(\n    'http://rspamd-server:11333/checkv2',\n    headers={\n        'Key': key_header,\n        'Content-Type': 'application/octet-stream',\n    },\n    data=encrypted_body\n)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"step-8-decrypt-the-response",children:"Step 8: Decrypt the Response"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def decrypt_response(shared_secret: bytes, encrypted: bytes) -> bytes:\n    nonce = encrypted[:24]\n    tag = encrypted[24:40]\n    ciphertext = encrypted[40:]\n    \n    # Re-derive MAC key with same nonce\n    # Verify Poly1305 tag - FAIL if mismatch!\n    # Decrypt ciphertext\n    \n    return plaintext\n"})}),"\n",(0,i.jsx)(n.h3,{id:"why-you-should-use-official-implementations",children:"Why You Should Use Official Implementations"}),"\n",(0,i.jsx)(n.p,{children:"Due to HTTPCrypt's non-standard components, implementing a client from scratch is error-prone:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Modified zbase32"}),": Rspamd uses inverted bit ordering that differs from any standard zbase32 implementation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Custom HChaCha20 key derivation"}),": The ECDH shared secret is processed through HChaCha20 with a zero nonce"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Non-standard MAC key derivation"}),": Uses 64 zero bytes instead of RFC's 32 bytes"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For production use, we strongly recommend:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rust"}),": Use ",(0,i.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-rs",children:"rspamdclient-rs"})," directly, or port its encryption module"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Go"}),": Use ",(0,i.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-go",children:"rspamdclient-go"})," directly, or port its encryption module"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Other languages"}),": Port the Rust or Go implementation, using the test vectors to verify correctness"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"verifying-your-implementation",children:"Verifying Your Implementation"}),"\n",(0,i.jsx)(n.p,{children:"Use these test vectors to verify your zbase32 and encryption implementations:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"zbase32 encoding (with Rspamd's inverted bit order):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Input: "hello"     -> Output: "em3ags7p"\nInput: "test123"   -> Output: "wm3g84fg13cy"  \nInput: "a"         -> Output: "bd"\nInput: "aaaaa"     -> Output: "bmansofc"\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Full encryption test:"}),"\nThe best way to verify your implementation is to:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Run ",(0,i.jsx)(n.code,{children:"rspamc --key=<server_pubkey> message.eml"})," and capture the wire format"]}),"\n",(0,i.jsx)(n.li,{children:"Compare your implementation's output byte-by-byte"}),"\n",(0,i.jsx)(n.li,{children:"Verify the server can decrypt your encrypted requests"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"reference-implementations",children:"Reference Implementations"}),"\n",(0,i.jsx)(n.p,{children:"For production use, we recommend using or adapting these official client implementations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rust"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-rs",children:"rspamdclient-rs"})," - Full-featured client with complete HTTPCrypt support"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Go"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-go",children:"rspamdclient-go"})," - Idiomatic Go client with encryption support"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Both implementations handle all the edge cases and provide well-tested, production-ready code."}),"\n",(0,i.jsx)(n.h3,{id:"testing-your-implementation",children:"Testing Your Implementation"}),"\n",(0,i.jsx)(n.p,{children:"To verify your HTTPCrypt implementation:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test against rspamd server"})," with encryption enabled"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compare with rspamc output"}),": Use ",(0,i.jsx)(n.code,{children:"rspamc --key=<pubkey>"})," and compare wire format"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use test vectors"}),": Generate known test cases with reference implementations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Verify interoperability"}),": Ensure your client can decrypt responses from rspamd"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Forgetting HChaCha20 step"}),": Standard X25519 + XChaCha20-Poly1305 won't work without the custom key derivation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Using any standard base32/zbase32 library"}),": Rspamd uses a ",(0,i.jsx)(n.strong,{children:"modified zbase32 with inverted bit ordering"}),". Even libraries that use the correct alphabet (",(0,i.jsx)(n.code,{children:"ybndrfg8ejkmcpqxot1uwisza345h769"}),") will fail because they process bits in the wrong order. You ",(0,i.jsx)(n.strong,{children:"must"})," use ",(0,i.jsx)(n.a,{href:"https://github.com/vstakhov/rust-base32",children:"rspamd_base32"})," or port its algorithm."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Incorrect MAC key derivation"}),": Must use 64 zero bytes through cipher, not 32"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Not using constant-time comparison"}),": MAC verification must use constant-time comparison"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reusing nonces"}),": Each encryption must use a fresh random nonce"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test your zbase32 implementation:"})," If encoding ",(0,i.jsx)(n.code,{children:'"hello"'})," doesn't produce ",(0,i.jsx)(n.code,{children:'"em3ags7p"'}),", your implementation is wrong."]}),"\n",(0,i.jsx)(n.h2,{id:"code-references",children:"Code References"}),"\n",(0,i.jsx)(n.p,{children:"For implementation details, see:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rust client"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-rs/blob/master/src/protocol/encryption.rs",children:"rspamdclient-rs/src/protocol/encryption.rs"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Go client"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-go/blob/master/protocol/encryption.go",children:"rspamdclient-go/protocol/encryption.go"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Original Paper"}),": ",(0,i.jsx)(n.a,{href:"https://highsecure.ru/httpcrypt.pdf",children:"HTTPCrypt Protocol Specification"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc7748",children:"RFC 7748"})," - Elliptic Curves for Security (X25519)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc8439",children:"RFC 8439"})," - ChaCha20 and Poly1305 for IETF Protocols"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc7539",children:"ChaCha20-Poly1305 AEAD"})," - Original ChaCha20-Poly1305 specification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha",children:"XChaCha20-Poly1305"})," - Extended nonce variant"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"HTTPCrypt provides lightweight, secure encryption for Rspamd client-server communications. Its design prioritizes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simplicity"}),": Minimal protocol overhead and complexity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Fast symmetric encryption with reasonable key exchange costs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security"}),": Modern cryptographic primitives with forward secrecy"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compatibility"}),": Base32 encoding and HTTP-friendly design"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"While it uses non-standard key derivation methods, the protocol is cryptographically sound and has been in production use for years. The main trade-off is non-standardization in exchange for a simpler, more compact protocol designed specifically for HTTPCrypt's use case."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>c});var s=r(96540);const i={},t=s.createContext(i);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);