"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[1142],{347:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"tutorials/fuzzy_storage","title":"Usage of fuzzy hashes","description":"Russian version","source":"@site/docs/tutorials/fuzzy_storage.md","sourceDirName":"tutorials","slug":"/tutorials/fuzzy_storage","permalink":"/docs.rspamd.com/branches/master/ru/tutorials/fuzzy_storage","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/tutorials/fuzzy_storage.md","tags":[],"version":"current","frontMatter":{"title":"Usage of fuzzy hashes"},"sidebar":"docs","previous":{"title":"Scanning outbound mail","permalink":"/docs.rspamd.com/branches/master/ru/tutorials/scanning_outbound"},"next":{"title":"Multi-instance Redis replication","permalink":"/docs.rspamd.com/branches/master/ru/tutorials/redis_replication"}}');var i=n(4848),r=n(8453);const a={title:"Usage of fuzzy hashes"},o="Usage of fuzzy hashes",l={},h=[{value:"Introduction",id:"introduction",level:2},{value:"Step 1: Hash sources selection",id:"step-1-hash-sources-selection",level:2},{value:"Working with user complaints",id:"working-with-user-complaints",level:3},{value:"Hash weight",id:"hash-weight",level:4},{value:"Learning filters",id:"learning-filters",level:4},{value:"Configuring spam traps",id:"configuring-spam-traps",level:3},{value:"Step 2: Configuring storage",id:"step-2-configuring-storage",level:2},{value:"Sample configuration",id:"sample-configuration",level:3},{value:"Data storage",id:"data-storage",level:3},{value:"Hash expiration",id:"hash-expiration",level:3},{value:"Access control",id:"access-control",level:3},{value:"Transport protocol encryption",id:"transport-protocol-encryption",level:3},{value:"Hashes replication",id:"hashes-replication",level:3},{value:"Step 3: Configuring <code>fuzzy_check</code> plugin",id:"step-3-configuring-fuzzy_check-plugin",level:2},{value:"Condition scripts for the learning",id:"condition-scripts-for-the-learning",level:3},{value:"Hashes replication",id:"hashes-replication-1",level:2},{value:"The &quot;cold&quot; synchronization",id:"the-cold-synchronization",level:3},{value:"Replication setup",id:"replication-setup",level:3},{value:"Storage testing",id:"storage-testing",level:2}];function c(e){const s={a:"a",br:"br",center:"center",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"usage-of-fuzzy-hashes",children:"Usage of fuzzy hashes"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"/tutorials/fuzzy_storage.ru/",children:"Russian version"})}),"\n",(0,i.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(s.p,{children:"Fuzzy hashing can be used to search for similar messages, allowing us to identify messages with the same or slightly modified text. This technique is particularly useful for blocking spam that is sent to many users simultaneously."}),"\n",(0,i.jsx)(s.p,{children:"The purpose of this page is to explain how to use fuzzy hashes, not to provide extensive details or a thorough understanding of how they work within Rspamd. However, the following summary should provide a basic understanding of the content covered on this page."}),"\n",(0,i.jsx)(s.p,{children:"Textual content is divided into tokens, also known as chunks or shingles, each of which represents a window of text with a certain number of characters. These tokens are then hashed individually and stored. When new email arrives, it is also tokenized and the hashes of these tokens are compared to the stored corpus of data. Calculations based on the position and number of matches are performed to determine if the current email is similar to or identical to previously encountered emails."}),"\n",(0,i.jsx)(s.p,{children:"For images and other attachments, a single hash is calculated and used to check for an exact match in storage."}),"\n",(0,i.jsx)(s.p,{children:"Since the hash function is unidirectional, it is not possible to restore the original text using the hashed data. This allows us to send requests to third-party hash storages without the risk of disclosure and to benefit from a larger corpus of data aggregated from various unrelated sources."}),"\n",(0,i.jsx)(s.p,{children:"The source data for fuzzy hash storage includes both spam and legitimate (non-spam) emails. Fuzzy hashes are used to match emails, not to classify them as spam or non-spam. First, we determine if an email is similar to other emails, and then we evaluate the significance of this similarity separately. The weight assigned to fuzzy hash matches (that is, the measure of how closely the current email matches or does not match content in the pool of many other emails) is just one factor among many in the determination of whether an email is spam or non-spam."}),"\n",(0,i.jsx)(s.p,{children:"This page is intended for mail system administrators who want to create and maintain their own hash storage and for those who want to understand how rspamd.com serves as a third-party resource. More details can be found in other pages here, including:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"/modules/fuzzy_check",children:"Fuzzy Check module"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"/workers/fuzzy_storage",children:"Fuzzy Storage Workers"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"/other/usage_policy",children:"Rspamd.com infrastructure policies"})}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"There are three high-level steps toward using fuzzy hashes"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Step 1: Hash sources selection"}),"\n",(0,i.jsx)(s.li,{children:"Step 2: Configuring storage"}),"\n",(0,i.jsx)(s.li,{children:"Step 3: Configuring fuzzy_check plugin"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Optional:"})," Hashes replication",(0,i.jsx)(s.br,{}),"\n",(0,i.jsx)(s.strong,{children:"Suggested:"})," Storage testing"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"step-1-hash-sources-selection",children:"Step 1: Hash sources selection"}),"\n",(0,i.jsx)(s.p,{children:"It is important to carefully select the sources of spam samples for training. The general principle is to use spam messages that are received by a large number of users. There are two main approaches to this task:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"working with users complaints"}),"\n",(0,i.jsx)(s.li,{children:"creating spam traps (honeypot)"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"working-with-user-complaints",children:"Working with user complaints"}),"\n",(0,i.jsx)(s.p,{children:'User complaints can be a useful source for improving the quality of the hash storage, but it is important to be aware that users may sometimes complain about legitimate emails that they have subscribed to themselves, such as store newsletters, ticket booking notifications, and even personal emails that they do not like for some reason. Many users do not differentiate between the "Delete" and "Mark as Spam" buttons.'}),"\n",(0,i.jsx)(s.p,{children:"One solution to this issue is to prompt the user for additional information about the complaint, such as why they believe the email is spam. This may draw the user's attention to the fact that they can unsubscribe from receiving unwanted emails rather than marking them as spam. Another approach is manual processing of user spam complaints."}),"\n",(0,i.jsx)(s.p,{children:"A combination of these methods may also be effective: assign greater weight to the emails that have been manually processed and a smaller weight to all other complaints."}),"\n",(0,i.jsx)(s.p,{children:'There are two features in Rspamd that can help filter out false positives (emails that are mistakenly marked as spam). (Note: In this documentation, FP stands for "False Positive" and FN stands for "False Negative".)'}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Hash weight"}),"\n",(0,i.jsx)(s.li,{children:"Learning filters"}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"hash-weight",children:"Hash weight"}),"\n",(0,i.jsx)(s.p,{children:"One method to filter out false positives is to assign a weight to each complaint and add this weight to the stored hash value during each subsequent learning step."}),"\n",(0,i.jsxs)(s.p,{children:["When querying the storage, we will ignore hashes with weights that are less than a defined threshold. For example, if the weight of a complaint is ",(0,i.jsx)(s.code,{children:"w=1"})," and the threshold is ",(0,i.jsx)(s.code,{children:"t=20"}),", then we will ignore this hash unless we receive at least 20 user complaints."]}),"\n",(0,i.jsx)(s.p,{children:"Furthermore, Rspamd does not assign the maximum score immediately upon reaching the threshold value. Instead, the score gradually increases from zero to a maximum (up to the metric value) as the weight of the hash increases from the threshold value to twice the threshold value (t .. 2 * t)."}),"\n",(0,i.jsx)(s.center,{children:(0,i.jsx)(s.img,{className:"img-fluid",src:"/img/rspamd-fuzzy-1.png",width:"50%"})}),"\n",(0,i.jsx)(s.h4,{id:"learning-filters",children:"Learning filters"}),"\n",(0,i.jsx)(s.p,{children:"The second method for filtering out false positives based on user complaints involves writing conditions in the Lua language that can skip the learning process or modify the value of a hash for emails from specific domains, for example. These filters offer a wide range of possibilities, but they require manual writing and configuration."}),"\n",(0,i.jsx)(s.h3,{id:"configuring-spam-traps",children:"Configuring spam traps"}),"\n",(0,i.jsx)(s.p,{children:'The "honeypot" method of improving the value of the hash storage involves using a mailbox that only receives spam emails and does not receive legitimate emails. The idea is that a large volume of fresh, guaranteed spam (possibly 100%) will be continually received, following current patterns, providing a vast corpus of fuzzy hash data for comparison with email received by live mailboxes. As mentioned earlier, user interpretation of spam can be somewhat error-prone. A corpus of user-reported spam is not as reliable as a spam trap, where matches are very likely to indicate that a new incoming email is also spam.'}),"\n",(0,i.jsxs)(s.p,{children:["One way to set up a spam trap is to expose addresses to spammer databases, but not to legitimate users. This can be done by placing email addresses in a hidden ",(0,i.jsx)(s.em,{children:"iframe"})," element on a popular website, for example. The element is not visible to users due to the ",(0,i.jsx)(s.em,{children:"hidden"})," property or zero size, but it is visible to spam bots. This method is not as effective as it used to be, as spammers have learned how to avoid such traps."]}),"\n",(0,i.jsx)(s.p,{children:"Another way to create a trap is to find domains that were popular in the past but are no longer functional. These domain names can be found in many spam databases. Purchase these domains and allow all incoming mail to go to a catch-all address, where it is processed for fuzzy hashing and then discarded. In general, setting up your own traps like this is only practical for large mail systems, as it can be costly in terms of maintenance and direct expenses such as domain purchases."}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"step-2-configuring-storage",children:"Step 2: Configuring storage"}),"\n",(0,i.jsxs)(s.p,{children:["The Rspamd process that is responsible for fuzzy hash storage is called the ",(0,i.jsx)(s.a,{href:"/workers/fuzzy_storage",children:(0,i.jsx)(s.code,{children:"fuzzy_storage"})})," worker. The information here should be useful whether you are using local or remote storage."]}),"\n",(0,i.jsx)(s.p,{children:"This process performs the following functions which will be detailed below."}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Data storage"}),"\n",(0,i.jsx)(s.li,{children:"Hash expiration"}),"\n",(0,i.jsx)(s.li,{children:"Access control (read and write)"}),"\n",(0,i.jsx)(s.li,{children:"Transport protocol encryption"}),"\n",(0,i.jsx)(s.li,{children:"Replication"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The configuration for the ",(0,i.jsx)(s.code,{children:'worker "fuzzy"'})," section begins in ",(0,i.jsx)(s.code,{children:"/etc/rspamd/rspamd.conf"}),".",(0,i.jsx)(s.br,{}),"\nAn ",(0,i.jsx)(s.code,{children:".include"})," directive there links to ",(0,i.jsx)(s.code,{children:"/etc/rspamd/local.d/worker-fuzzy.inc"}),", which is where local settings activate and configure this process. (Earlier documentation referred to ",(0,i.jsx)(s.code,{children:"/etc/rspamd/rspamd.conf.local"}),".)"]}),"\n",(0,i.jsx)(s.h3,{id:"sample-configuration",children:"Sample configuration"}),"\n",(0,i.jsxs)(s.p,{children:["The following is a sample configuration for this fuzzy storage worker process, which will be explained and referred to below. Please refer to ",(0,i.jsx)(s.a,{href:"/workers/fuzzy_storage#configuration",children:"this page"})," for any settings not profiled here."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'worker "fuzzy" {\n  # Socket to listen on (UDP and TCP from rspamd 1.3)\n  bind_socket = "*:11335";\n\n  # Number of processes to serve this storage (useful for read scaling)\n  count = 4;\n\n  # Backend ("sqlite" or "redis" - default "sqlite")\n  backend = "sqlite";\n\n  # sqlite: Where data file is stored (must be owned by rspamd user)\n  database = "${DBDIR}/fuzzy.db";\n\n  # Hashes storage time (3 months)\n  expire = 90d;\n\n  # Synchronize updates to the storage each minute\n  sync = 1min;\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["This sample shows an entire section, not as you will see it in the file, but as it looks to the controller when the setting details are collected from all files (with the ",(0,i.jsx)(s.code,{children:".include"})," directive) : Be sure to put changes in the .inc file, without the ",(0,i.jsx)(s.code,{children:"worker"})," wrapper."]}),"\n",(0,i.jsxs)(s.p,{children:["By default, the fuzzy_storage process is not active, with the ",(0,i.jsx)(s.code,{children:"count=-1"})," directive found in the core file. To activate fuzzy storage, the local .inc file gets the ",(0,i.jsx)(s.code,{children:"count=4"})," directive as seen above."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"expire"})," and ",(0,i.jsx)(s.code,{children:"sync"})," values are related to database cleanup and performance, as described below."]}),"\n",(0,i.jsxs)(s.p,{children:["Fuzzy storage works with hashes and not with email messages. A ",(0,i.jsx)(s.a,{href:"/workers/normal",children:"worker/scanner process"})," or a ",(0,i.jsx)(s.a,{href:"/workers/controller",children:"controller process"})," convert emails to hashes before connecting to this process for fuzzy processing. In this sample, we see the fuzzy storage process that operates on the sqlite database is listening on socket 11335 for UDP requests from the other processes to query or update the storage."]}),"\n",(0,i.jsx)(s.center,{children:(0,i.jsx)(s.img,{className:"img-fluid",src:"/img/rspamd-fuzzy-2.png",width:"75%"})}),"\n",(0,i.jsx)(s.h3,{id:"data-storage",children:"Data storage"}),"\n",(0,i.jsx)(s.p,{children:"The database engine, sqlite3, has some restrictions on the storage architecture that can impact performance. Specifically, sqlite cannot handle concurrent write requests well, which can lead to significant degradation in database performance."}),"\n",(0,i.jsx)(s.p,{children:"To address this issue, Rspamd hash storage always writes to the database from a single process, the fuzzy storage worker. This process maintains an updates queue, while all other processes simply forward write requests from clients to this process. By default, the updates queue is written to disk once per minute, but this can be configured using the sync setting in the sample configuration."}),"\n",(0,i.jsx)(s.p,{children:"This architecture is optimized for read requests and prioritizes them."}),"\n",(0,i.jsx)(s.h3,{id:"hash-expiration",children:"Hash expiration"}),"\n",(0,i.jsxs)(s.p,{children:["Another important function of the fuzzy storage worker is to remove obsolete hashes using the ",(0,i.jsx)(s.code,{children:"expire"})," setting."]}),"\n",(0,i.jsx)(s.p,{children:'Spam patterns change as certain tactics become more or less effective. Spammers send out blasts of spam and, after a period of time ranging from days to months, they change the patterns because they know systems like this are analyzing their data. Since the "effective lifetime" of spam emails is always limited, there is no reason to store all hashes permanently. Based on experience, it is recommended to store hashes for no longer than about three months.'}),"\n",(0,i.jsx)(s.p,{children:"It is a good idea to compare the volume of hashes learned over a certain period with the available RAM. For example, 400,000 hashes may occupy about 100 MB, and 1.5 million hashes may occupy 500 MB. To avoid a significant performance degradation, it is not recommended to increase the storage size beyond the available RAM size. That is, do not rely on swap space or allocate too many resources to other processes. If you have a small volume of hashes suitable for learning, start with an expiration time of 90 days. If the volume of data over that time period results in an unacceptable amount of available RAM, such as peak-time available RAM going down to 20%, you may want to reduce the expiration time to 70 days and see if expiring data from storage releases a more acceptable amount of RAM."}),"\n",(0,i.jsx)(s.h3,{id:"access-control",children:"Access control"}),"\n",(0,i.jsx)(s.p,{children:"By default, Rspamd does not allow changes to the fuzzy storage. Any system that connects to the fuzzy_storage process via UDP must be authorized, and a list of trusted IP addresses and/or networks must be provided to enable learning. In practice, it is better to write from the local address only (127.0.0.1) because fuzzy storage uses UDP, which is not protected from source IP forgery."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'worker "fuzzy" {\n  # Same options as before ...\n  allow_update = ["127.0.0.1"];\n\n  # or 10.0.0.0/8, for internal network\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"allow_update"})," setting is a comma-delimited array of strings, or a ",(0,i.jsx)(s.a,{href:"/modules/multimap",children:"map"})," of IP addresses, that are allowed to perform changes to fuzzy storage - You should also set ",(0,i.jsx)(s.code,{children:"read_only"})," = no in your fuzzy_check plugin, see step 3 below."]}),"\n",(0,i.jsx)(s.h3,{id:"transport-protocol-encryption",children:"Transport protocol encryption"}),"\n",(0,i.jsx)(s.p,{children:"The fuzzy hashes protocol allows optional (opportunistic) or mandatory encryption based on public-key cryptography. This feature is useful for creating restricted storages where access is allowed exclusively to customers or other business partners who have a generated public key."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"How this works:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The configuration is modified in ",(0,i.jsx)(s.code,{children:"/etc/rspamd/local.d/worker-fuzzy.inc"})," of the local system running the fuzzy_storage worker. One public/private keypair is set for each remote UDP client that will connect on port 11335."]}),"\n",(0,i.jsxs)(s.li,{children:["One unique ",(0,i.jsx)(s.strong,{children:"public"})," key is given to each unique client system, so that only that one system can use that one key."]}),"\n"]}),"\n",(0,i.jsx)(s.center,{children:(0,i.jsx)(s.img,{className:"img-fluid",src:"/img/rspamd-fuzzy-3.png",width:"75%"})}),"\n",(0,i.jsxs)(s.p,{children:["The encryption architecture uses cryptobox construction: ",(0,i.jsx)(s.a,{href:"https://nacl.cr.yp.to/box.html",children:"https://nacl.cr.yp.to/box.html"})," and it is similar to the algorithm for end-to-end encryption used in the DNSCurve protocol: ",(0,i.jsx)(s.a,{href:"https://dnscurve.org/",children:"https://dnscurve.org/"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["To configure transport encryption, create a keypair for the storage server, using the command ",(0,i.jsx)(s.code,{children:"rspamadm keypair -u"}),". Each time this command is run, unique output is returned, as shown in this example (the order of the name=value pairs may change each time this is run) :"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'keypair {\n    pubkey = "og3snn8s37znxz53mr5yyyzktt3d5uczxecsp3kkrs495p4iaxzy";\n    privkey = "o6wnij9r4wegqjnd46dyifwgf5gwuqguqxzntseectroq7b3gwty";\n    id = "f5yior1ag3csbzjiuuynff9tczknoj9s9b454kuonqknthrdbwbqj63h3g9dht97fhp4a5jgof1eiifshcsnnrbj73ak8hkq6sbrhed";\n    encoding = "base32";\n    algorithm = "curve25519";\n    type = "kex";\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The  ",(0,i.jsx)(s.strong,{children:"public"})," ",(0,i.jsx)(s.code,{children:"pubkey"})," should be copied manually to the remote host, or published in any way that guarantees the reliability (e.g. certified digital signature or HTTPS-site hosting). As always the ",(0,i.jsx)(s.strong,{children:"private"})," ",(0,i.jsx)(s.code,{children:"privkey"})," should never be published or shared."]}),"\n",(0,i.jsx)(s.p,{children:"Each storage can use any number of keys simultaneously, one for each remote client (or a group of clients):"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'worker "fuzzy" {\n  # Same options as before ...\n  keypair = [\n  {\n    pubkey = ...\n    privkey = ...\n  },\n  {\n    pubkey = ...\n    privkey = ...\n  },\n  {\n    pubkey = ...\n    privkey = ...\n  }\n]\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["This mechanism is optional, but it can be made mandatory by adding the ",(0,i.jsx)(s.code,{children:"encrypted_only"})," option. In this mode, client systems that do not have a valid public key will be unable to access the storage."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'worker "fuzzy" {\n  # Same options as before ...\n  encrypted_only = true;\n\n  keypair = [ {\n    ...\n  } ]\n  ...\n}\n'})}),"\n",(0,i.jsx)(s.h3,{id:"hashes-replication",children:"Hashes replication"}),"\n",(0,i.jsx)(s.p,{children:"Having a local copy of remote fuzzy storage can be useful in many situations. To facilitate this, Rspamd provides support for hash replication, which is handled by the fuzzy storage worker. Instructions for setting up replication can be found in Step 4 below."}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.h2,{id:"step-3-configuring-fuzzy_check-plugin",children:["Step 3: Configuring ",(0,i.jsx)(s.code,{children:"fuzzy_check"})," plugin"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"fuzzy_check"})," plugin is used by scanner processes for querying a storage, and by controller processes for learning fuzzy hashes."]}),"\n",(0,i.jsx)(s.p,{children:"Plugin functions:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Email processing and hash creation from email parts and attachments"}),"\n",(0,i.jsx)(s.li,{children:"Querying from and learning to storage"}),"\n",(0,i.jsx)(s.li,{children:"Transport Encryption"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Learning is performing by ",(0,i.jsx)(s.code,{children:"rspamc fuzzy_add"})," command:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"$ rspamc -f 1 -w 10 fuzzy_add <message|directory|stdin>\n"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"-w"})," parameter is used to set the hash weight, as mentioned earlier, while the ",(0,i.jsx)(s.code,{children:"-f"})," parameter specifies the flag number."]}),"\n",(0,i.jsx)(s.p,{children:"Flags enable the storage of hashes from different sources. For example, a hash may originate from a spam trap, another hash may be the result of user complaints, and a third hash may come from emails on a whitelist. Each flag can be associated with its own symbol and have a weight when checking emails:"}),"\n",(0,i.jsx)(s.center,{children:(0,i.jsx)(s.img,{className:"img-fluid",src:"/img/rspamd-fuzzy-4.png",width:"75%"})}),"\n",(0,i.jsx)(s.p,{children:"A symbol name can be used instead of a numeric flag during learning, for example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"$ rspamc -S FUZZY_DENIED -w 10 fuzzy_add <message|directory|stdin>\n"})}),"\n",(0,i.jsxs)(s.p,{children:["The FUZZY_DENIED symbol is equivalent to flag=1, as defined in modules.d/fuzzy_check.conf. To match symbols with the corresponding flags you can use the ",(0,i.jsx)(s.code,{children:"rule"})," section."]}),"\n",(0,i.jsx)(s.p,{children:"local.d/fuzzy_check.conf example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'rule "local" {\n    # Fuzzy storage server list\n    servers = "localhost:11335";\n    # Default symbol for unknown flags\n    symbol = "LOCAL_FUZZY_UNKNOWN";\n    # Additional mime types to store/check\n    mime_types = ["*"];\n    # Hash weight threshold for all maps\n    max_score = 20.0;\n    # Whether we can learn this storage\n    read_only = no;\n    # Ignore unknown flags\n    skip_unknown = yes;\n    # Hash generation algorithm\n    algorithm = "mumhash";\n    # Use direct hash for short texts\n    short_text_direct_hash = true;\n\n    # Map flags to symbols\n    fuzzy_map = {\n        LOCAL_FUZZY_DENIED {\n            # Local threshold\n            max_score = 20.0;\n            # Flag to match\n            flag = 11;\n        }\n        LOCAL_FUZZY_PROB {\n            max_score = 10.0;\n            flag = 12;\n        }\n        LOCAL_FUZZY_WHITE {\n            max_score = 2.0;\n            flag = 13;\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"local.d/fuzzy_group.conf example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'max_score = 12.0;\nsymbols = {\n    "LOCAL_FUZZY_UNKNOWN" {\n        weight = 5.0;\n        description = "Generic fuzzy hash match";\n    }\n    "LOCAL_FUZZY_DENIED" {\n        weight = 12.0;\n        description = "Denied fuzzy hash";\n    }\n    "LOCAL_FUZZY_PROB" {\n        weight = 5.0;\n        description = "Probable fuzzy hash";\n    }\n    "LOCAL_FUZZY_WHITE" {\n        weight = -2.1;\n        description = "Whitelisted fuzzy hash";\n    }\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"Here are some useful options that can be set in the module:"}),"\n",(0,i.jsxs)(s.p,{children:["One option is ",(0,i.jsx)(s.code,{children:"max_score"}),", which specifies the threshold for a hash weight:"]}),"\n",(0,i.jsx)(s.center,{children:(0,i.jsx)(s.img,{className:"img-fluid",src:"/img/rspamd-fuzzy-1.png",width:"50%"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"mime_types"})," option specifies which attachment types are checked (or learned) using this fuzzy rule. This option takes a list of valid types in the following format: ",(0,i.jsx)(s.code,{children:'["type/subtype", "*/subtype", "type/*", "*"]'}),", where ",(0,i.jsx)(s.code,{children:"*"})," represents any valid type. In practice, it can be useful to save the hashes for all ",(0,i.jsx)(s.code,{children:"application/*"})," attachments. Texts and embedded images are implicitly checked by ",(0,i.jsx)(s.code,{children:"fuzzy_check"})," plugin, so there is no need to add ",(0,i.jsx)(s.code,{children:"image/*"})," in the list of scanned attachments. Note that attachments and images are searched for an exact match, while texts are matched using the approximate algorithm (shingles)."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"read_only"})," is quite an important option required for storage learning. It is set to ",(0,i.jsx)(s.code,{children:"read_only=true"})," by default, restricting thus a storage's learning:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:"read_only = true; # disallow learning\nread_only = false; # allow learning\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"Encryption_key"})," parameter specifies the ",(0,i.jsx)(s.strong,{children:"public"})," key of a storage and enables encryption for all requests."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"Algorithm"})," parameter specifies the algorithm for generating hashes from text parts of emails (for attachments and images ",(0,i.jsx)(s.a,{href:"https://blake2.net/",children:"blake2b"})," is always used)."]}),"\n",(0,i.jsxs)(s.p,{children:["Initially, rspamd only supported the ",(0,i.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/SipHash",children:"siphash"})," algorithm. However, this algorithm had some performance issues, particularly on older hardware (CPU models up to Intel Haswell). Subsequently, support was added for the following algorithms:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"mumhash"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"xxhash"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"fasthash"})}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["For the vast majority of configurations we recommend ",(0,i.jsx)(s.code,{children:"mumhash"})," or ",(0,i.jsx)(s.code,{children:"fasthash"})," (also called ",(0,i.jsx)(s.code,{children:"fast"}),"). These algorithms perform well on a wide range of platforms, and ",(0,i.jsx)(s.code,{children:"mumhash"})," is currently the default for all new storage. ",(0,i.jsx)(s.code,{children:"siphash"})," (also called ",(0,i.jsx)(s.code,{children:"old"}),") is only supported for legacy purposes."]}),"\n",(0,i.jsxs)(s.p,{children:["You can evaluate the performance of different algorithms yourself by ",(0,i.jsx)(s.a,{href:"/developers/writing_tests",children:"compiling the tests set"})," from rspamd sources:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"$ make rspamd-test\n"})}),"\n",(0,i.jsx)(s.p,{children:"Run the test suite of different variants of hash algorithms on a specific platform:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"test/rspamd-test -p /rspamd/shingles\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Important note:"})," Changing this parameter ",(0,i.jsx)(s.strong,{children:"will result in losing all data in the fuzzy hash storage"}),", since only one algorithm can be used for each storage at a time. It is not possible to convert one type of hash to another, as hash functions are designed to be irreversible."]}),"\n",(0,i.jsx)(s.h3,{id:"condition-scripts-for-the-learning",children:"Condition scripts for the learning"}),"\n",(0,i.jsxs)(s.p,{children:["As the ",(0,i.jsx)(s.code,{children:"fuzzy_check"})," plugin is responsible for learning, we create the script within its configuration. This script determines whether an email is suitable for learning. The script should return a Lua function with a single argument of type ",(0,i.jsx)(s.a,{href:"/lua/rspamd_task",children:(0,i.jsx)(s.code,{children:"rspamd_task"})})," type. The function should return a boolean value (",(0,i.jsx)(s.code,{children:"true"})," to learn, ",(0,i.jsx)(s.code,{children:"false"})," to skip learning), or a pair consisting of a boolean value and a numeric value (to modify the hash flag value, if necessary). Parameter ",(0,i.jsx)(s.code,{children:"learn_condition"})," is used to setup learn script. The most convenient way to set the script is to write it as a multiline string supported by ",(0,i.jsx)(s.code,{children:"UCL"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:"# Fuzzy check plugin configuration snippet\nlearn_condition = <<EOD\nreturn function(task)\n  return true -- Always learn\nend\nEOD;\n"})}),"\n",(0,i.jsx)(s.p,{children:"Here are some practical examples of useful scripts. For instance, if we want to restrict learning for messages that come from certain domains:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lua",children:"return function(task)\n  local skip_domains = {\n    'example.com',\n    'google.com',\n  }\n\n  local from = task:get_from()\n\n  if from and from[1] and from[1]['addr'] then\n    for i,d in ipairs(skip_domains) do\n      if string.find(from[1]['addr'], d) then\n        return false\n      end\n    end\n  end\n\n\nend\n"})}),"\n",(0,i.jsxs)(s.p,{children:["It can also be useful to split hashes into different flags based on their source. For example, such sources may be encoded in the ",(0,i.jsx)(s.code,{children:"X-Source"})," title. For instance, we have the following match between flags and sources:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"honeypot"}),' - "black" list: 1']}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"users_unfiltered"}),' - "gray" list: 2']}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"users_filtered"}),' - "black" list: 1']}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"FP"}),' - "white" list: 3']}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Then the script that provides this logic may be as following:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lua",children:"return function(task)\n  local skip_headers = {\n    ['X-Source'] = function(hdr)\n      local sources = {\n        honeypot = 1,\n        users_unfiltered = 2,\n        users_filtered = 1,\n        FP = 3\n      }\n      local fl = sources[hdr]\n\n      if fl then return true,fl end -- Return true + new flag\n      return false\n    end\n  }\n\n  for h,f in pairs(skip_headers) do\n    local hdr = task:get_header(h) -- Check for interesting header\n    if h then\n      return f(hdr) -- Call its handler and return result\n    end\n  end\n\n  return false -- Do not learn if specified header is missing\nend\n"})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"hashes-replication-1",children:"Hashes replication"}),"\n",(0,i.jsx)(s.p,{children:"It is often desired to have a local copy of the remote storage. Rspamd supports replication for this purposes that is implemented in the hashes storage since version 1.3:"}),"\n",(0,i.jsx)(s.center,{children:(0,i.jsx)(s.img,{className:"img-fluid",src:"/img/rspamd-fuzzy-5.png",width:"75%"})}),"\n",(0,i.jsxs)(s.p,{children:["The hashes transfer is initiated by the replication ",(0,i.jsx)(s.strong,{children:"master"}),". It sends hash update commands, such as adding, modifying or deleting, to all specified slaves. Therefore, the slaves must be able to accept connections from the master. This should be taken into account when configuring the firewall."]}),"\n",(0,i.jsx)(s.p,{children:"By default, a slave listens on port 11335 over TCP to accept connections. Synchronization between the master and the slave is performed via the HTTP protocol with HTTPCrypt transport encryption. To prevent repeated or invalid updates, the slave checks the update version. If the master's version is less than or equal to the local version, the update is rejected. If the master is ahead of the slave by more than one version, the following message will appear in the slave's log file:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"rspamd_fuzzy_mirror_process_update: remote revision: XX is newer more than 1 revision than ours: YY, cold sync is recommended\n"})}),"\n",(0,i.jsx)(s.p,{children:'In this case we recommend to re-create the database through a "cold" synchronization.'}),"\n",(0,i.jsx)(s.h3,{id:"the-cold-synchronization",children:'The "cold" synchronization'}),"\n",(0,i.jsx)(s.p,{children:"This procedure is used to initialize a new slave or to recover a slave after the communications with the master is interrupted."}),"\n",(0,i.jsx)(s.p,{children:"To synchronize the master host you need to stop rspamd service and create a dump of hash database. In theory, you can skip this step, however, if a version of the master increases by more than one while database cloning, it will be required to repeat the procedure:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'sqlite3 /var/lib/rspamd/fuzzy.db ".backup fuzzy.sql"\n'})}),"\n",(0,i.jsxs)(s.p,{children:["Afterwards, copy the output file ",(0,i.jsx)(s.code,{children:"fuzzy.sql"})," to all the slaves (it can be done without stopping rspamd service on the slaves):"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'sqlite3 /var/lib/rspamd/fuzzy.db ".restore fuzzy.sql"\n'})}),"\n",(0,i.jsx)(s.p,{children:"After all, you can run rspamd on the slaves and then switch on the master."}),"\n",(0,i.jsx)(s.h3,{id:"replication-setup",children:"Replication setup"}),"\n",(0,i.jsxs)(s.p,{children:["You can set the replication in the hashes storage configuration file, namely ",(0,i.jsx)(s.code,{children:"worker-fuzzy.inc"}),". Master replication is configured as follows:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'# Fuzzy storage worker configuration snippet\n# Local keypair (rspamadm keypair -u)\nsync_keypair {\n    pubkey = "xxx";\n    privkey = "ppp";\n    encoding = "base32";\n    algorithm = "curve25519";\n    type = "kex";\n}\n# Remote slave\nslave {\n        name = "slave1";\n        hosts = "slave1.example.com";\n        key = "yyy";\n}\nslave {\n        name = "slave2";\n        hosts = "slave2.example.com";\n        key = "zzz";\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"Let\u2019s focus on configuring the encryption keys. Typically, rspamd automatically generates a keypair for clients and does not require any dedicated setup. However, in replication case, the master acts as the client, so you can set a specific (public) key on the slaves for better access control. The slaves will allow updates merely for hosts that are using this key. It is also possible to set allowed IP-addresses of the master, but public key based protection seems to be more reliable. Alternatively, you can combine these methods."}),"\n",(0,i.jsx)(s.p,{children:"The slave setup looks similar:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'# Fuzzy storage worker configuration snippet\n# We assume it is slave1 with pubkey \'yyy\'\nsync_keypair {\n    pubkey = "yyy";\n    privkey = "PPP";\n    encoding = "base32";\n    algorithm = "curve25519";\n    type = "kex";\n}\n\n# Allow update from these hosts only\nmasters = "master.example.com";\n# Also limit updates to this specific public key\nmaster_key = "xxx";\n'})}),"\n",(0,i.jsxs)(s.p,{children:["To avoid conflicts with local hashes, you can set a flag translation from the master to the slave. For example, the following configuration can be used to translate the flags ",(0,i.jsx)(s.code,{children:"1"}),", ",(0,i.jsx)(s.code,{children:"2"}),", and ",(0,i.jsx)(s.code,{children:"3"})," to ",(0,i.jsx)(s.code,{children:"10"}),", ",(0,i.jsx)(s.code,{children:"20"}),", and ",(0,i.jsx)(s.code,{children:"30"}),", respectively:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'# Fuzzy storage worker configuration snippet\nmaster_flags {\n  "1" = 10;\n  "2" = 20;\n  "3" = 30;\n};\n'})}),"\n",(0,i.jsx)(s.h2,{id:"storage-testing",children:"Storage testing"}),"\n",(0,i.jsxs)(s.p,{children:["To test the storage you can use ",(0,i.jsx)(s.code,{children:"rspamadm control fuzzystat"})," command:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"Statistics for storage 73ee122ac2cfe0c4f12\ninvalid_requests: 6.69M\nfuzzy_expired: 35.57k\nfuzzy_found: (v0.6: 0), (v0.8: 0), (v0.9: 0), (v1.0+: 20.10M)\nfuzzy_stored: 425.46k\nfuzzy_shingles: (v0.6: 0), (v0.8: 41.78k), (v0.9: 23.60M), (v1.0+: 380.87M)\nfuzzy_checked: (v0.6: 0), (v0.8: 95.29k), (v0.9: 55.47M), (v1.0+: 1.01G)\n\nKeys statistics:\nKey id: icy63itbhhni8\n        Checked: 1.00G\n        Matched: 18.29M\n        Errors: 0\n        Added: 1.81M\n        Deleted: 0\n\n        IPs stat:\n        x.x.x.x\n                Checked: 131.23M\n                Matched: 1.85M\n                Errors: 0\n                Added: 0\n                Deleted: 0\n\n        x.x.x.x\n                Checked: 119.86M\n                ...\n"})}),"\n",(0,i.jsx)(s.p,{children:"Primarily, a general storage statistics is shown, such as the number of stored and obsolete hashes, and the distribution of requests for client Protocol versions:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"v0.6"})," - requests from rspamd 0.6 - 0.8 (older versions, compatibility is limited)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"v0.8"})," - requests from rspamd 0.8 - 0.9 (partially compatible)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"v0.9"})," - unencrypted requests from rspamd 0.9+ (fully compatible)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"v1.1"})," - encrypted requests from rspamd 1.1+ (fully compatible)"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"And then detailed statistics is displayed for each of the keys configured in the storage and for the latest requested client IP-addresses. In conclusion, we see the overall statistics on IP-addresses."}),"\n",(0,i.jsx)(s.p,{children:"To change the output from this command, you can use the following options:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"-n"}),": display raw numbers without reduction"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"--short"}),": do not display detailed statistics on the keys and IP-addresses"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"--no-keys"}),": do not show statistics on keys"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"--no-ips"}),": do not show statistics on IP-addresses"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"--sort"}),": sort:\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"checked"}),": by the number of trusted hashes (default)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"matched"}),": by the number of found hashes"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"errors"}),": by the number of failed requests"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"ip"}),": by IP-address lexicographically"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"e.g."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"rspamadm control fuzzystat -n\n"})})]})}function d(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>o});var t=n(6540);const i={},r=t.createContext(i);function a(e){const s=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);