"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[543],{12579:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"developers/encryption","title":"HTTPCrypt Encryption Protocol","description":"Overview","source":"@site/docs/developers/encryption.md","sourceDirName":"developers","slug":"/developers/encryption","permalink":"/docs.rspamd.com/branches/master/ru/developers/encryption","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/developers/encryption.md","tags":[],"version":"current","frontMatter":{"title":"HTTPCrypt Encryption Protocol"},"sidebar":"docs","previous":{"title":"Rspamd protocol","permalink":"/docs.rspamd.com/branches/master/ru/developers/protocol"},"next":{"title":"Coroutines and async calls","permalink":"/docs.rspamd.com/branches/master/ru/developers/sync_async"}}');var s=r(74848),t=r(28453);const l={title:"HTTPCrypt Encryption Protocol"},c="HTTPCrypt Encryption Protocol",a={},o=[{value:"Overview",id:"overview",level:2},{value:"Cryptographic Primitives",id:"cryptographic-primitives",level:2},{value:"X25519 (Curve25519)",id:"x25519-curve25519",level:3},{value:"XChaCha20",id:"xchacha20",level:3},{value:"Poly1305",id:"poly1305",level:3},{value:"HChaCha20",id:"hchacha20",level:3},{value:"Blake2b",id:"blake2b",level:3},{value:"Key Generation and Management",id:"key-generation-and-management",level:2},{value:"Long-term Server Keys",id:"long-term-server-keys",level:3},{value:"Ephemeral Client Keys",id:"ephemeral-client-keys",level:3},{value:"Key Identification Header",id:"key-identification-header",level:3},{value:"Session Key Derivation (ECDH)",id:"session-key-derivation-ecdh",level:2},{value:"Step 1: Scalar Multiplication",id:"step-1-scalar-multiplication",level:3},{value:"Step 2: HChaCha20 Key Derivation",id:"step-2-hchacha20-key-derivation",level:3},{value:"Encryption Process",id:"encryption-process",level:2},{value:"Message Authentication Code (MAC) Key Derivation",id:"message-authentication-code-mac-key-derivation",level:3},{value:"Encryption Algorithm",id:"encryption-algorithm",level:3},{value:"Wire Format",id:"wire-format",level:3},{value:"Decryption Process",id:"decryption-process",level:2},{value:"HTTPCrypt Protocol Flow",id:"httpcrypt-protocol-flow",level:2},{value:"Client Request Encryption",id:"client-request-encryption",level:3},{value:"1. Prepare Inner Request",id:"1-prepare-inner-request",level:4},{value:"2. Generate Ephemeral Keypair",id:"2-generate-ephemeral-keypair",level:4},{value:"3. Perform ECDH",id:"3-perform-ecdh",level:4},{value:"4. Encrypt Inner Request",id:"4-encrypt-inner-request",level:4},{value:"5. Build Outer Request",id:"5-build-outer-request",level:4},{value:"Server Response Decryption",id:"server-response-decryption",level:3},{value:"1. Server Uses Same Shared Secret",id:"1-server-uses-same-shared-secret",level:4},{value:"2. Encrypt Response",id:"2-encrypt-response",level:4},{value:"3. Client Decrypts",id:"3-client-decrypts",level:4},{value:"Complete Example",id:"complete-example",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Strengths",id:"strengths",level:3},{value:"Limitations and Considerations",id:"limitations-and-considerations",level:3},{value:"Attack Resistance",id:"attack-resistance",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Key Encoding",id:"key-encoding",level:3},{value:"Memory Safety",id:"memory-safety",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Testing",id:"testing",level:3},{value:"Compatibility",id:"compatibility",level:3},{value:"Code References",id:"code-references",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"httpcrypt-encryption-protocol",children:"HTTPCrypt Encryption Protocol"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Rspamd implements the HTTPCrypt protocol for encrypting client-server communications. HTTPCrypt is a lightweight encryption protocol that predates RFC 8439 but uses similar cryptographic primitives: X25519 for key exchange, XChaCha20 for encryption, and Poly1305 for authentication. However, it employs custom key derivation methods that differ from standard IETF approaches."}),"\n",(0,s.jsx)(n.p,{children:"The protocol provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authenticated encryption"})," using XChaCha20-Poly1305"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Forward secrecy"})," through ephemeral key exchange"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compact wire format"})," optimized for HTTP communication"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strong security"})," based on modern elliptic curve cryptography"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"cryptographic-primitives",children:"Cryptographic Primitives"}),"\n",(0,s.jsx)(n.p,{children:"HTTPCrypt combines several well-established cryptographic algorithms:"}),"\n",(0,s.jsx)(n.h3,{id:"x25519-curve25519",children:"X25519 (Curve25519)"}),"\n",(0,s.jsx)(n.p,{children:"Used for Elliptic Curve Diffie-Hellman (ECDH) key exchange. X25519 provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"128-bit security level"}),"\n",(0,s.jsx)(n.li,{children:"Fast constant-time operations"}),"\n",(0,s.jsx)(n.li,{children:"Small key size (32 bytes)"}),"\n",(0,s.jsx)(n.li,{children:"Protection against side-channel attacks"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"xchacha20",children:"XChaCha20"}),"\n",(0,s.jsx)(n.p,{children:"A stream cipher variant of ChaCha20 with extended nonce size:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"24-byte (192-bit) nonces instead of ChaCha20's 12-byte nonces"}),"\n",(0,s.jsx)(n.li,{children:"256-bit keys"}),"\n",(0,s.jsx)(n.li,{children:"High performance on all platforms"}),"\n",(0,s.jsx)(n.li,{children:"No timing side channels"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"poly1305",children:"Poly1305"}),"\n",(0,s.jsx)(n.p,{children:"A cryptographic message authentication code (MAC):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"128-bit security level"}),"\n",(0,s.jsx)(n.li,{children:"One-time MAC requiring unique key per message"}),"\n",(0,s.jsx)(n.li,{children:"Fast computation"}),"\n",(0,s.jsx)(n.li,{children:"Used in encrypt-then-MAC construction"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"hchacha20",children:"HChaCha20"}),"\n",(0,s.jsx)(n.p,{children:"A key derivation function based on ChaCha20:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Takes 32-byte key and 16-byte nonce"}),"\n",(0,s.jsx)(n.li,{children:"Produces 32-byte derived key"}),"\n",(0,s.jsx)(n.li,{children:"Used for XChaCha20 nonce extension and custom key derivation"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"blake2b",children:"Blake2b"}),"\n",(0,s.jsx)(n.p,{children:"A cryptographic hash function used for key identification:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Faster than SHA-2 and SHA-3"}),"\n",(0,s.jsx)(n.li,{children:"Provides 512-bit output (though only first 5 bytes used for key IDs)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-generation-and-management",children:"Key Generation and Management"}),"\n",(0,s.jsx)(n.h3,{id:"long-term-server-keys",children:"Long-term Server Keys"}),"\n",(0,s.jsx)(n.p,{children:"The server maintains a long-term key pair for identification and key exchange:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"rspamadm keypair\n"})}),"\n",(0,s.jsx)(n.p,{children:"This generates:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'keypair {\n    privkey = "e4gr3yuw4xiy6dikdpqus8cmxj8c6pqstt448ycwhewhhrtxdahy";\n    id = "gnyieumi6sp6d3yaq13q4u6xycmiqaw7iahsrz97acpposod1x8zogynnishtgxr47o815dgsz9t69d66jcm1drjei4a5d";\n    pubkey = "fg8uwtce9sta43sdwzddb11iez5thcskiufj4ug8esyfniqq5iiy";\n    type = "kex";\n    algorithm = "curve25519";\n    encoding = "base32";\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Components:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"privkey"}),": Server's private key (32 bytes, base32-encoded)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"pubkey"}),": Server's public key (32 bytes, base32-encoded)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"id"}),": Full key identifier derived from the public key"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"algorithm"}),": Always ",(0,s.jsx)(n.code,{children:"curve25519"})," for HTTPCrypt"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"encoding"}),": Always ",(0,s.jsx)(n.code,{children:"base32"})," (RFC 4648 base32 without padding)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"ephemeral-client-keys",children:"Ephemeral Client Keys"}),"\n",(0,s.jsx)(n.p,{children:"For each encrypted request, the client generates a fresh ephemeral keypair:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let local_sk = SecretKey::generate(&mut OsRng);\nlet local_pk = local_sk.public_key();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This provides ",(0,s.jsx)(n.strong,{children:"forward secrecy"}),": even if the server's long-term key is compromised, past communications remain secure because ephemeral keys are discarded immediately after use."]}),"\n",(0,s.jsx)(n.h3,{id:"key-identification-header",children:"Key Identification Header"}),"\n",(0,s.jsxs)(n.p,{children:["The client sends a ",(0,s.jsx)(n.code,{children:"Key"})," header to identify which server public key was used and provide the client's ephemeral public key:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Key: <short_key_id>=<client_ephemeral_pubkey>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"short_key_id"}),": First 5 bytes of Blake2b hash of server's public key, base32-encoded"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"client_ephemeral_pubkey"}),": Client's ephemeral public key, base32-encoded"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Key: kbr3m=k4nz984k36xmcynm1hr9kdbn6jhcxf4ggbrb1quay7f88rpm9kay\n"})}),"\n",(0,s.jsx)(n.p,{children:"The short key ID allows the server to quickly identify which of its keys should be used when it has multiple keys configured."}),"\n",(0,s.jsx)(n.h2,{id:"session-key-derivation-ecdh",children:"Session Key Derivation (ECDH)"}),"\n",(0,s.jsx)(n.p,{children:"HTTPCrypt uses a custom ECDH key derivation that differs from standard X25519 usage:"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-scalar-multiplication",children:"Step 1: Scalar Multiplication"}),"\n",(0,s.jsx)(n.p,{children:"Standard X25519 scalar multiplication is performed between the client's ephemeral private key and the server's public key:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Clamp the private key according to X25519 spec\nlet e = Scalar::from_bytes_mod_order(clamp_integer(local_sk.to_bytes()));\nlet p = MontgomeryPoint(remote_pk);\nlet shared_point = e * p;\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Clamping:"}),' The private key is "clamped" before use:']}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Clear bits 0, 1, 2 of the first byte (sets lowest 3 bits to 0)"}),"\n",(0,s.jsx)(n.li,{children:"Clear bit 7 of the last byte (clears top bit)"}),"\n",(0,s.jsx)(n.li,{children:"Set bit 6 of the last byte (sets second-highest bit)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This ensures the scalar is in the correct range for X25519 and avoids small subgroup attacks."}),"\n",(0,s.jsx)(n.h3,{id:"step-2-hchacha20-key-derivation",children:"Step 2: HChaCha20 Key Derivation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"This is where HTTPCrypt diverges from standard practice."})}),"\n",(0,s.jsx)(n.p,{children:"Standard X25519 usage (RFC 7748) would use the shared point directly or hash it with additional context. HTTPCrypt instead applies HChaCha20 with a zero nonce:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn rspamd_x25519_ecdh(point: MontgomeryPoint) -> RspamdNM {\n    let n0 = [0u8; 16];  // Zero nonce\n    hchacha::<U10>(&point.to_bytes().into(), &n0)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"HChaCha20 Operation:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Initialize ChaCha20 state with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Constants: "expand 32-byte k" (ChaCha20 constants)'}),"\n",(0,s.jsx)(n.li,{children:"Key: The 32-byte shared point from X25519"}),"\n",(0,s.jsx)(n.li,{children:"Nonce: 16 zero bytes"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Execute 20 rounds of ChaCha20 permutation (10 double-rounds)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Output: Concatenate state words [0..3] and [12..15] (first 128 bits + last 128 bits)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This produces a 32-byte ",(0,s.jsx)(n.strong,{children:"shared secret"})," (called ",(0,s.jsx)(n.code,{children:"nm"}),' in the code, standing for "NaCl-style shared secret").']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Security Note:"})," While non-standard, this approach is cryptographically sound. HChaCha20 acts as a key derivation function, providing additional mixing and ensuring the derived key is uniformly distributed."]}),"\n",(0,s.jsx)(n.h2,{id:"encryption-process",children:"Encryption Process"}),"\n",(0,s.jsx)(n.h3,{id:"message-authentication-code-mac-key-derivation",children:"Message Authentication Code (MAC) Key Derivation"}),"\n",(0,s.jsx)(n.p,{children:"Before encrypting, a one-time Poly1305 MAC key must be derived. HTTPCrypt uses a custom method:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub fn new(key: RspamdNM, nonce: chacha20::XNonce) -> Self {\n    let mut chacha = XChaCha20::new_from_slices(key.as_slice(), nonce.as_slice()).unwrap();\n    let mut mac_key: GenericArray<u8, U64> = GenericArray::default(); // 64 zero bytes\n    chacha.apply_keystream(mac_key.as_mut());\n    let poly = Poly1305::new_from_slice(mac_key.split_at(32).0).unwrap();\n    // chacha context remains positioned for encryption\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Process:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Initialize XChaCha20 with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Shared secret (32 bytes) as key"}),"\n",(0,s.jsx)(n.li,{children:"Random nonce (24 bytes)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Generate 64 zero bytes"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Encrypt these zero bytes with XChaCha20, producing keystream bytes"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Take first 32 bytes as the Poly1305 MAC key"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important:"})," The XChaCha20 cipher context is now positioned at byte offset 64"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This approach is similar to the original ChaCha20-Poly1305 construction but uses 64 bytes instead of the RFC's 32 bytes for key material derivation."}),"\n",(0,s.jsx)(n.h3,{id:"encryption-algorithm",children:"Encryption Algorithm"}),"\n",(0,s.jsx)(n.p,{children:"With the MAC key derived and cipher positioned, encryption proceeds:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub fn encrypt_in_place(mut self, data: &mut [u8]) -> Tag {\n    // Encrypt\n    self.enc_ctx.apply_keystream(data);\n    // Authenticate (encrypt-then-MAC)\n    self.mac_ctx.compute_unpadded(data)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Process:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encrypt the plaintext"})," using XChaCha20 (which is already positioned at offset 64)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compute MAC"})," over the ciphertext using Poly1305"]}),"\n",(0,s.jsx)(n.li,{children:"Return the 16-byte authentication tag"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This is an ",(0,s.jsx)(n.strong,{children:"encrypt-then-MAC"})," construction, which is the secure approach (as opposed to MAC-then-encrypt or encrypt-and-MAC)."]}),"\n",(0,s.jsx)(n.h3,{id:"wire-format",children:"Wire Format"}),"\n",(0,s.jsx)(n.p,{children:"The encrypted message format is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"+----------------------+\n| Nonce (24 bytes)    |\n+----------------------+\n| Tag (16 bytes)      |\n+----------------------+\n| Ciphertext (N bytes)|\n+----------------------+\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Field Details:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Nonce (24 bytes)"}),": Random nonce generated for this message, sent in plaintext"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tag (16 bytes)"}),": Poly1305 authentication tag over the ciphertext"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ciphertext (N bytes)"}),": XChaCha20-encrypted payload"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Total overhead: 40 bytes per message."}),"\n",(0,s.jsx)(n.h2,{id:"decryption-process",children:"Decryption Process"}),"\n",(0,s.jsx)(n.p,{children:"Decryption reverses the encryption process with authentication verification:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'pub fn decrypt_in_place(&mut self, data: &mut [u8], tag: &Tag) -> Result<usize, RspamdError> {\n    // Verify MAC first\n    let computed = self.mac_ctx.clone().compute_unpadded(data);\n    if computed != *tag {\n        return Err(RspamdError::EncryptionError("Authentication failed".to_string()));\n    }\n    // Decrypt only if authentication succeeds\n    self.enc_ctx.apply_keystream(&mut data[..]);\n    Ok(computed.len())\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Process:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Parse the message:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Extract 24-byte nonce"}),"\n",(0,s.jsx)(n.li,{children:"Extract 16-byte tag"}),"\n",(0,s.jsx)(n.li,{children:"Remaining bytes are ciphertext"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Derive shared secret using same ECDH process"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Initialize XChaCha20 with shared secret and nonce"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Derive MAC key (64 zero bytes through cipher)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Verify authentication tag:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Compute Poly1305 MAC over ciphertext"}),"\n",(0,s.jsx)(n.li,{children:"Compare with received tag using constant-time comparison"}),"\n",(0,s.jsxs)(n.li,{children:["If mismatch, ",(0,s.jsx)(n.strong,{children:"fail immediately"})," and return error"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Decrypt ciphertext"})," (only if authentication succeeds):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Re-initialize cipher (or use positioned context)"}),"\n",(0,s.jsx)(n.li,{children:"Apply XChaCha20 keystream to ciphertext"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Security:"})," Authentication is verified ",(0,s.jsx)(n.strong,{children:"before"})," decryption to prevent oracle attacks and ensure ciphertext integrity."]}),"\n",(0,s.jsx)(n.h2,{id:"httpcrypt-protocol-flow",children:"HTTPCrypt Protocol Flow"}),"\n",(0,s.jsx)(n.h3,{id:"client-request-encryption",children:"Client Request Encryption"}),"\n",(0,s.jsx)(n.p,{children:"When a client sends an encrypted request:"}),"\n",(0,s.jsx)(n.h4,{id:"1-prepare-inner-request",children:"1. Prepare Inner Request"}),"\n",(0,s.jsx)(n.p,{children:"Build a complete HTTP request as plaintext:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"POST /checkv2 HTTP/1.1\nFrom: user@example.com\nIP: 192.0.2.1\nContent-Length: 1234\n\n<message body>\n"})}),"\n",(0,s.jsx)(n.p,{children:"This inner request contains all the actual headers and body."}),"\n",(0,s.jsx)(n.h4,{id:"2-generate-ephemeral-keypair",children:"2. Generate Ephemeral Keypair"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let local_sk = SecretKey::generate(&mut OsRng);\nlet local_pk = local_sk.public_key();\n"})}),"\n",(0,s.jsx)(n.h4,{id:"3-perform-ecdh",children:"3. Perform ECDH"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let ec_point = rspamd_x25519_scalarmult(server_public_key, &local_sk)?;\nlet shared_secret = rspamd_x25519_ecdh(ec_point);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"4-encrypt-inner-request",children:"4. Encrypt Inner Request"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let nonce = ChaChaBox::generate_nonce(&mut OsRng);\nlet cbox = RspamdSecretbox::new(shared_secret, nonce);\nlet tag = cbox.encrypt_in_place(&mut ciphertext);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"5-build-outer-request",children:"5. Build Outer Request"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:"POST /checkv2 HTTP/1.1\nContent-Length: <encrypted_length>\nKey: kbr3m=k4nz984k36xmcynm1hr9kdbn6jhcxf4ggbrb1quay7f88rpm9kay\n\n<nonce (24 bytes)><tag (16 bytes)><ciphertext>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Key"})," header contains:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Short ID of server's public key (5 bytes, base32)"}),"\n",(0,s.jsx)(n.li,{children:"Client's ephemeral public key (32 bytes, base32)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"server-response-decryption",children:"Server Response Decryption"}),"\n",(0,s.jsx)(n.p,{children:"The server can also encrypt responses using the same shared secret:"}),"\n",(0,s.jsx)(n.h4,{id:"1-server-uses-same-shared-secret",children:"1. Server Uses Same Shared Secret"}),"\n",(0,s.jsx)(n.p,{children:"The server computes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let ec_point = rspamd_x25519_scalarmult(client_ephemeral_pk, &server_sk)?;\nlet shared_secret = rspamd_x25519_ecdh(ec_point);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This produces the ",(0,s.jsx)(n.strong,{children:"same shared secret"})," due to ECDH properties:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Client: ",(0,s.jsx)(n.code,{children:"ECDH(client_ephemeral_sk, server_pk) = shared_secret"})]}),"\n",(0,s.jsxs)(n.li,{children:["Server: ",(0,s.jsx)(n.code,{children:"ECDH(server_sk, client_ephemeral_pk) = shared_secret"})]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"2-encrypt-response",children:"2. Encrypt Response"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:"HTTP/1.1 200 OK\nContent-Length: <encrypted_length>\n\n<nonce (24 bytes)><tag (16 bytes)><encrypted JSON response>\n"})}),"\n",(0,s.jsx)(n.h4,{id:"3-client-decrypts",children:"3. Client Decrypts"}),"\n",(0,s.jsx)(n.p,{children:"The client uses the stored shared secret (from step 3 of request encryption) to decrypt the response."}),"\n",(0,s.jsx)(n.h3,{id:"complete-example",children:"Complete Example"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Client sends:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:"POST /checkv2 HTTP/1.1\nHost: rspamd.example.com\nContent-Type: application/octet-stream\nContent-Length: 1540\nKey: kbr3m=k4nz984k36xmcynm1hr9kdbn6jhcxf4ggbrb1quay7f88rpm9kay\n\n<24-byte nonce><16-byte tag><1500 bytes encrypted inner request>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Server responds:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:"HTTP/1.1 200 OK\nContent-Type: application/octet-stream\nContent-Length: 556\n\n<24-byte nonce><16-byte tag><500 bytes encrypted JSON response>\n"})}),"\n",(0,s.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"strengths",children:"Strengths"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Forward Secrecy"}),": Ephemeral key exchange ensures past messages cannot be decrypted even if server's long-term key is compromised."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Authenticated Encryption"}),": Poly1305 MAC provides strong authentication, preventing tampering and detecting corruption."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Modern Cryptography"}),": Based on well-analyzed primitives (Curve25519, ChaCha20, Poly1305)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Constant-Time Operations"}),": Implementations use constant-time comparison for MACs and constant-time X25519."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Nonce Collision Resistance"}),": 24-byte nonces (XChaCha20) provide enormous keyspace (2^192), making collisions virtually impossible with random generation."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"limitations-and-considerations",children:"Limitations and Considerations"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Non-Standard Key Derivation"}),": The use of HChaCha20 with zero nonce for ECDH key derivation is non-standard. While not insecure, it differs from RFC 7748 recommendations."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"No Replay Protection"}),": HTTPCrypt itself doesn't provide replay protection. Applications should implement this at a higher layer if needed."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"No Key Confirmation"}),": The protocol doesn't include explicit key confirmation. Authentication failures are detected during MAC verification."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"MAC Key Derivation"}),": Uses 64 zero bytes through cipher instead of RFC 8439's 32 bytes. This is a design choice from the pre-RFC era but remains secure."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Single-Use Ephemeral Keys"}),": Each request requires a new ephemeral keypair generation, which adds computational cost but ensures forward secrecy."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"No Explicit Version Negotiation"}),": The protocol has no version field. Any changes would require out-of-band negotiation."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"attack-resistance",children:"Attack Resistance"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Chosen Ciphertext Attacks (CCA):"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Protected by encrypt-then-MAC construction"}),"\n",(0,s.jsx)(n.li,{children:"MAC verification before decryption prevents oracle attacks"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Compromise:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Forward secrecy limits damage from server key compromise"}),"\n",(0,s.jsx)(n.li,{children:"Past communications remain secure"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Timing Attacks:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Constant-time operations in X25519 and MAC verification"}),"\n",(0,s.jsx)(n.li,{children:"Constant-time comparison prevents timing leaks"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Small Subgroup Attacks:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Prevented by X25519 key clamping"}),"\n",(0,s.jsx)(n.li,{children:"Curve25519 is designed to resist these attacks"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,s.jsx)(n.h3,{id:"key-encoding",children:"Key Encoding"}),"\n",(0,s.jsx)(n.p,{children:"All keys use RFC 4648 base32 encoding without padding:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Alphabet: ",(0,s.jsx)(n.code,{children:"abcdefghijklmnopqrstuvwxyz234567"})]}),"\n",(0,s.jsx)(n.li,{children:"Case insensitive for decoding"}),"\n",(0,s.jsx)(n.li,{children:"No padding characters (=)"}),"\n",(0,s.jsx)(n.li,{children:"Compact representation (32 bytes \u2192 52 characters)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"memory-safety",children:"Memory Safety"}),"\n",(0,s.jsx)(n.p,{children:"Implementations should:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zero sensitive data"}),": Clear private keys, shared secrets, and MAC keys after use"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use secure allocators"}),": Consider using locked memory for key material"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Avoid copying keys"}),": Use move semantics or references when possible"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Rust example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use crypto_box::cipher::zeroize::Zeroizing;\ntype RspamdNM = Zeroizing<GenericArray<u8, U32>>;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Zeroizing"})," wrapper ensures the memory is zeroed when dropped."]}),"\n",(0,s.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"Critical errors that must be handled:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authentication Failure"}),": Never proceed with decryption if MAC verification fails"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Invalid Key Length"}),": Reject keys that aren't exactly 32 bytes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Malformed Messages"}),": Check minimum message length (24 + 16 bytes) before parsing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Base32 Decode Errors"}),": Handle invalid base32 encoding gracefully"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fast operations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"X25519 scalar multiplication: ~50-100 microseconds on modern CPUs"}),"\n",(0,s.jsx)(n.li,{children:"XChaCha20 encryption: ~1-2 GB/s throughput"}),"\n",(0,s.jsx)(n.li,{children:"Poly1305 MAC: ~1-2 GB/s throughput"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Slow operations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ephemeral keypair generation: Requires random number generation"}),"\n",(0,s.jsx)(n.li,{children:"Key encoding/decoding: Base32 conversion adds overhead"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimization tips:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reuse server keypair (don't regenerate for each request)"}),"\n",(0,s.jsx)(n.li,{children:"Consider connection pooling to amortize key exchange costs"}),"\n",(0,s.jsx)(n.li,{children:"Use vectorized implementations of ChaCha20 when available"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"testing",children:"Testing"}),"\n",(0,s.jsx)(n.p,{children:"Implementations should verify:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Known Answer Tests (KAT)"}),": Test against known test vectors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Round-trip"}),": Encrypt and decrypt should return original plaintext"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authentication"}),": Modified ciphertext should fail MAC verification"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interoperability"}),": Test against reference implementations (Rust/Go clients, Rspamd server)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"compatibility",children:"Compatibility"}),"\n",(0,s.jsx)(n.p,{children:"HTTPCrypt is implemented in:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rspamd server"})," (C): Built-in support in all workers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"rspamc client"})," (C): Command-line client"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rspamd proxy"}),": Can act as encryption bridge"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"rspamdclient-rs"})," (Rust): Full client library"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"rspamdclient-go"})," (Go): Full client library"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"All implementations use the same wire format and are fully interoperable."}),"\n",(0,s.jsx)(n.h2,{id:"code-references",children:"Code References"}),"\n",(0,s.jsx)(n.p,{children:"For implementation details, see:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rust client"}),": ",(0,s.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-rs/blob/master/src/protocol/encryption.rs",children:"rspamdclient-rs/src/protocol/encryption.rs"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Go client"}),": ",(0,s.jsx)(n.a,{href:"https://github.com/rspamd/rspamdclient-go/blob/master/protocol/encryption.go",children:"rspamdclient-go/protocol/encryption.go"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Original Paper"}),": ",(0,s.jsx)(n.a,{href:"https://highsecure.ru/httpcrypt.pdf",children:"HTTPCrypt Protocol Specification"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc7748",children:"RFC 7748"})," - Elliptic Curves for Security (X25519)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc8439",children:"RFC 8439"})," - ChaCha20 and Poly1305 for IETF Protocols"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc7539",children:"ChaCha20-Poly1305 AEAD"})," - Original ChaCha20-Poly1305 specification"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha",children:"XChaCha20-Poly1305"})," - Extended nonce variant"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"HTTPCrypt provides lightweight, secure encryption for Rspamd client-server communications. Its design prioritizes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simplicity"}),": Minimal protocol overhead and complexity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Fast symmetric encryption with reasonable key exchange costs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Security"}),": Modern cryptographic primitives with forward secrecy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compatibility"}),": Base32 encoding and HTTP-friendly design"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"While it uses non-standard key derivation methods, the protocol is cryptographically sound and has been in production use for years. The main trade-off is non-standardization in exchange for a simpler, more compact protocol designed specifically for HTTPCrypt's use case."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>c});var i=r(96540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);