"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[8218],{5541(e,s,n){n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"workers/index","title":"Workers documentation","description":"Rspamd defines several types of worker processes, each designed for specific purposes.","source":"@site/docs/workers/index.md","sourceDirName":"workers","slug":"/workers/","permalink":"/docs.rspamd.com/branches/master/ru/workers/","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/workers/index.md","tags":[],"version":"current","frontMatter":{"title":"Workers documentation"},"sidebar":"docs","previous":{"title":"Universal configuration language (UCL)","permalink":"/docs.rspamd.com/branches/master/ru/configuration/ucl"},"next":{"title":"Normal worker (scanner)","permalink":"/docs.rspamd.com/branches/master/ru/workers/normal"}}');var o=n(4848),t=n(8453);const i={title:"Workers documentation"},c="Rspamd workers",l={},d=[{value:"Worker types",id:"worker-types",level:2},{value:"Workers connections",id:"workers-connections",level:2},{value:"Common worker options",id:"common-worker-options",level:2},{value:"HTTPS support",id:"https-support",level:2},{value:"Overview",id:"overview",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Setup guide",id:"setup-guide",level:3},{value:"Proxy mirror SSL and keepalive",id:"proxy-mirror-ssl-and-keepalive",level:3}];function a(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"rspamd-workers",children:"Rspamd workers"})}),"\n",(0,o.jsx)(s.p,{children:"Rspamd defines several types of worker processes, each designed for specific purposes.\nFor instance, some are meant for scanning mail messages, while others handle control actions\nlike learning or statistic grabbing. Additionally, there's a versatile worker type\ncalled the 'lua' worker, which permits the execution of any Lua script as an Rspamd worker.\nThis worker type acts as a proxy for Rspamd's Lua API."}),"\n",(0,o.jsx)(s.h2,{id:"worker-types",children:"Worker types"}),"\n",(0,o.jsx)(s.p,{children:"Currently Rspamd defines the following worker types:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/workers/normal",children:"normal"}),": this worker is designed to scan mail messages"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/workers/controller",children:"controller"}),": this worker performs configuration actions, such as\nlearning, adding fuzzy hashes and serving web interface requests"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/workers/fuzzy_storage",children:"fuzzy_storage"}),": stores fuzzy hashes"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/workers/rspamd_proxy",children:"rspamd_proxy"}),": handles requests forwarding and milter protocol"]}),"\n"]}),"\n",(0,o.jsx)(s.h2,{id:"workers-connections",children:"Workers connections"}),"\n",(0,o.jsxs)(s.p,{children:["All client applications should interact with two main workers: ",(0,o.jsx)(s.code,{children:"normal"})," and ",(0,o.jsx)(s.code,{children:"controller"}),".\nBoth of these workers utilize the ",(0,o.jsx)(s.code,{children:"HTTP"})," protocol for all operations and depend on HTTP headers\nto retrieve additional information from a client. Starting from Rspamd 3.15, workers can also serve HTTPS directly (see ",(0,o.jsx)(s.a,{href:"#https-support",children:"HTTPS support"})," below). Depending on your network configuration, it might be\nbeneficial to bind all workers to the loopback interface to prevent any external interactions.\nIt's important to note that Rspamd workers are ",(0,o.jsx)(s.strong,{children:"not"})," meant to operate in an unprotected environment, such as\nthe Internet without proper TLS encryption. When using plain HTTP, sensitive information might potentially be leaked."]}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.a,{href:"/workers/fuzzy_storage",children:"Fuzzy worker"})," is different: it is intended to serve external requests, however, it\nlistens on an UDP port and does not save any state information."]}),"\n",(0,o.jsx)(s.h2,{id:"common-worker-options",children:"Common worker options"}),"\n",(0,o.jsx)(s.p,{children:"All workers share a set of common options. Here's a typical example of a normal worker configuration that utilizes only the common worker options:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-hcl",children:'worker "normal" {\n    bind_socket = "*:11333";\n}\n'})}),"\n",(0,o.jsx)(s.p,{children:"Here are options available to all workers:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"bind_socket"})," - a string that defines the bind address of a worker. If the port number is omitted, port 11333 is assumed."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"count"})," - the number of worker instances to run (some workers ignore this option, e.g., ",(0,o.jsx)(s.code,{children:"hs_helper"}),")"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"enabled"})," (1.6.2+) - a Boolean (",(0,o.jsx)(s.code,{children:"true"})," or ",(0,o.jsx)(s.code,{children:"false"}),"), enabling or disabling a worker (",(0,o.jsx)(s.code,{children:"true"})," by default)"]}),"\n"]}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"bind_socket"})," is the most commonly used option. It defines the address where the worker should accept\nconnections. Rspamd allows both names and IP addresses for this option:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-hcl",children:'bind_socket = "localhost:11333";\nbind_socket = "127.0.0.1:11333";\nbind_socket = "[::1]:11333"; # note that you need to enclose ipv6 in \'[]\'\n'})}),"\n",(0,o.jsx)(s.p,{children:"Also universal listening addresses are defined:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-hcl",children:'bind_socket = "*:11333"; # any ipv4 and ipv6 address\nbind_socket = "*v4:11333"; # any ipv4 address\nbind_socket = "*v6:11333"; # any ipv6 address\n'})}),"\n",(0,o.jsxs)(s.p,{children:["It is possible to use systemd sockets as configured via a ",(0,o.jsx)(s.a,{href:"https://www.freedesktop.org/software/systemd/man/systemd.socket.html",children:"socket unit file"}),".\nHowever, this is not recommended, especially if one is using official packages or requires the use of multiple sockets:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-hcl",children:'# Use the first socket passed through a systemd .socket file.\nbind_socket = "systemd:0";\n# Starting with Rspamd 2.4, one can use named socket files too. If the systemd\n# FileDescriptorName= option is not specified, the socket unit name can be used.\nbind_socket = "systemd:rspamd.socket";\n'})}),"\n",(0,o.jsx)(s.p,{children:"For UNIX sockets, it is also possible to specify owner and mode using this syntax:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-hcl",children:'bind_socket = "/tmp/rspamd.sock mode=0666 owner=user";\n'})}),"\n",(0,o.jsxs)(s.p,{children:["Without specifying an owner and mode, Rspamd uses the active user as the owner\n(for instance, if started by root, then ",(0,o.jsx)(s.code,{children:"root"})," is used) and ",(0,o.jsx)(s.code,{children:"0644"})," as the access mask.\nPlease note that you need to specify the ",(0,o.jsx)(s.strong,{children:"octal"})," number for the mode, specifically prefixed by a zero.\nOtherwise, modes like ",(0,o.jsx)(s.code,{children:"666"})," will produce unexpected results."]}),"\n",(0,o.jsxs)(s.p,{children:["You can specify multiple ",(0,o.jsx)(s.code,{children:"bind_socket"})," options to listen on as many addresses as you want."]}),"\n",(0,o.jsx)(s.h2,{id:"https-support",children:"HTTPS support"}),"\n",(0,o.jsx)(s.p,{children:"Starting from version 3.15, Rspamd workers can serve HTTPS natively without requiring a TLS-terminating reverse proxy (e.g. nginx) in front. This simplifies deployments where Rspamd's HTTP API or web UI must be exposed over an encrypted connection."}),"\n",(0,o.jsx)(s.admonition,{type:"note",children:(0,o.jsx)(s.p,{children:"A reverse proxy may still be preferred for advanced TLS features such as client certificate authentication, OCSP stapling, or centralised certificate management."})}),"\n",(0,o.jsx)(s.h3,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(s.p,{children:["HTTPS is enabled by appending the ",(0,o.jsx)(s.code,{children:"ssl"})," suffix to a ",(0,o.jsx)(s.code,{children:"bind_socket"})," line. There is no separate ",(0,o.jsx)(s.code,{children:"ssl = true"})," option -- the suffix on the bind line is the only mechanism. A single worker can listen on both plain HTTP and HTTPS ports simultaneously by specifying multiple ",(0,o.jsx)(s.code,{children:"bind_socket"})," lines, some with the ",(0,o.jsx)(s.code,{children:"ssl"})," suffix and some without."]}),"\n",(0,o.jsxs)(s.p,{children:["When any ",(0,o.jsx)(s.code,{children:"bind_socket"})," uses the ",(0,o.jsx)(s.code,{children:"ssl"})," suffix, the worker requires two additional options:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(s.table,{children:[(0,o.jsx)(s.thead,{children:(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.th,{children:"Option"}),(0,o.jsx)(s.th,{children:"Description"})]})}),(0,o.jsxs)(s.tbody,{children:[(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:(0,o.jsx)(s.code,{children:"ssl_cert"})}),(0,o.jsx)(s.td,{children:"Path to the PEM-encoded certificate (or certificate chain) file"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:(0,o.jsx)(s.code,{children:"ssl_key"})}),(0,o.jsx)(s.td,{children:"Path to the PEM-encoded private key file"})]})]})]}),"\n",(0,o.jsx)(s.p,{children:"Both options are configured at the worker level and apply to all SSL-enabled sockets of that worker."}),"\n",(0,o.jsx)(s.h3,{id:"configuration",children:"Configuration"}),"\n",(0,o.jsx)(s.p,{children:"Here is an example that adds HTTPS to the controller worker while keeping the plain HTTP listener intact:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-hcl",children:'# local.d/worker-controller.inc\nbind_socket = "127.0.0.1:11334";         # plain HTTP (loopback only)\nbind_socket = "*:11335 ssl";              # HTTPS (all interfaces)\nssl_cert = "/etc/rspamd/ssl/cert.pem";\nssl_key = "/etc/rspamd/ssl/key.pem";\n'})}),"\n",(0,o.jsx)(s.p,{children:"The same approach works for the normal worker and proxy worker:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-hcl",children:'# local.d/worker-normal.inc\nbind_socket = "127.0.0.1:11333";         # plain HTTP\nbind_socket = "*:11336 ssl";              # HTTPS\nssl_cert = "/etc/rspamd/ssl/cert.pem";\nssl_key = "/etc/rspamd/ssl/key.pem";\n'})}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-hcl",children:'# local.d/worker-proxy.inc\nbind_socket = "127.0.0.1:11332";         # plain milter/HTTP\nbind_socket = "*:11339 ssl";              # HTTPS\nssl_cert = "/etc/rspamd/ssl/cert.pem";\nssl_key = "/etc/rspamd/ssl/key.pem";\n'})}),"\n",(0,o.jsx)(s.h3,{id:"setup-guide",children:"Setup guide"}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Obtain a certificate and key."})," Use your existing PKI, ACME/Let's Encrypt, or generate a self-signed certificate for testing:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{children:'openssl req -x509 -newkey rsa:2048 -nodes \\\n  -keyout /etc/rspamd/ssl/key.pem \\\n  -out /etc/rspamd/ssl/cert.pem \\\n  -days 365 -subj "/CN=rspamd.example.com"\n'})}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Set file permissions."})," Ensure the Rspamd user can read both files, and that the private key is not world-readable:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{children:"chown _rspamd:_rspamd /etc/rspamd/ssl/key.pem /etc/rspamd/ssl/cert.pem\nchmod 600 /etc/rspamd/ssl/key.pem\nchmod 644 /etc/rspamd/ssl/cert.pem\n"})}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Add SSL bind sockets."})," Edit the appropriate ",(0,o.jsx)(s.code,{children:"local.d/worker-*.inc"})," file and add a ",(0,o.jsx)(s.code,{children:"bind_socket"})," line with the ",(0,o.jsx)(s.code,{children:"ssl"})," suffix, along with ",(0,o.jsx)(s.code,{children:"ssl_cert"})," and ",(0,o.jsx)(s.code,{children:"ssl_key"})," paths (see examples above)."]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.strong,{children:"Restart Rspamd:"})}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{children:"systemctl restart rspamd\n"})}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.strong,{children:"Verify the connection:"})}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{children:"curl -k https://rspamd.example.com:11335/stat\n"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(s.h3,{id:"proxy-mirror-ssl-and-keepalive",children:"Proxy mirror SSL and keepalive"}),"\n",(0,o.jsxs)(s.p,{children:["The proxy worker's ",(0,o.jsx)(s.code,{children:"mirror"})," and ",(0,o.jsx)(s.code,{children:"upstream"})," blocks also support ",(0,o.jsx)(s.code,{children:"ssl"})," and ",(0,o.jsx)(s.code,{children:"keepalive"})," (or ",(0,o.jsx)(s.code,{children:"keep_alive"}),") options for connections to upstream/mirror servers:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-hcl",children:'# local.d/worker-proxy.inc\nupstream "scan" {\n  default = yes;\n  hosts = "scanner.example.com:11336";\n  ssl = true;         # connect to upstream over TLS\n  keepalive = true;   # use persistent connections\n}\n\nmirror "test" {\n  hosts = "test.example.com:11336";\n  probability = 0.1;\n  ssl = true;\n  keepalive = true;\n}\n'})}),"\n",(0,o.jsxs)(s.p,{children:["This is separate from the worker-level ",(0,o.jsx)(s.code,{children:"ssl_cert"}),"/",(0,o.jsx)(s.code,{children:"ssl_key"})," options: the worker-level settings control the ",(0,o.jsx)(s.em,{children:"listener"})," side (serving HTTPS to clients), while ",(0,o.jsx)(s.code,{children:"ssl"})," in upstream/mirror blocks controls the ",(0,o.jsx)(s.em,{children:"client"})," side (connecting to backend servers over TLS)."]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},8453(e,s,n){n.d(s,{R:()=>i,x:()=>c});var r=n(6540);const o={},t=r.createContext(o);function i(e){const s=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);