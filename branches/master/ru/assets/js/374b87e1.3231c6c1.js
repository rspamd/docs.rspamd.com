"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[938],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>t});var s=i(96540);const r={},l=s.createContext(r);function o(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(l.Provider,{value:n},e.children)}},43610:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/rspamd-diagram-ad69b8ff3b4c936757436f9d452670b7.png"},51233:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"guides/configuration/tool-selection","title":"Tool Selection Guide","description":"This guide helps you choose the right Rspamd tools and approaches for your specific situation. Rather than overwhelming you with options, we\'ll guide you through a simple decision process.","source":"@site/docs/guides/configuration/tool-selection.md","sourceDirName":"guides/configuration","slug":"/guides/configuration/tool-selection","permalink":"/docs.rspamd.com/branches/master/ru/guides/configuration/tool-selection","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/guides/configuration/tool-selection.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Tool Selection Guide","sidebar_position":2},"sidebar":"docs","previous":{"title":"Configuration Fundamentals","permalink":"/docs.rspamd.com/branches/master/ru/guides/configuration/fundamentals"},"next":{"title":"Upgrading","permalink":"/docs.rspamd.com/branches/master/ru/tutorials/migration"}}');var r=i(74848),l=i(28453);const o={title:"Tool Selection Guide",sidebar_position:2},t="Tool Selection Guide",c={},a=[{value:"Rule Selection Priority",id:"rule-selection-priority",level:2},{value:"1) Prefer regexp rules (with conditions)",id:"1-prefer-regexp-rules-with-conditions",level:2},{value:"2) If multiple matches are required, prefer multimaps",id:"2-if-multiple-matches-are-required-prefer-multimaps",level:2},{value:"3) If you need async calls \u2014 create custom Lua rules",id:"3-if-you-need-async-calls--create-custom-lua-rules",level:2},{value:"4) If you need configuration and multi-symbol logic \u2014 write a plugin",id:"4-if-you-need-configuration-and-multi-symbol-logic--write-a-plugin",level:2},{value:"5) Combine different symbols using composites",id:"5-combine-different-symbols-using-composites",level:2},{value:"Quick Reference",id:"quick-reference",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"tool-selection-guide",children:"Tool Selection Guide"})}),"\n",(0,r.jsx)(n.p,{children:"This guide helps you choose the right Rspamd tools and approaches for your specific situation. Rather than overwhelming you with options, we'll guide you through a simple decision process."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Rspamd Tool Selection Diagram",src:i(43610).A+"",width:"2568",height:"1218"})}),"\n",(0,r.jsx)(n.h2,{id:"rule-selection-priority",children:"Rule Selection Priority"}),"\n",(0,r.jsx)(n.p,{children:"Use the simplest tool that solves the problem. Prefer this order:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Prefer regexp rules (with conditions)"}),"\n",(0,r.jsx)(n.li,{children:"If multiple independent matches are required, prefer multimaps"}),"\n",(0,r.jsx)(n.li,{children:"If you need asynchronous calls, create custom Lua rules"}),"\n",(0,r.jsx)(n.li,{children:"If you need configuration and multi-symbol logic, write a plugin"}),"\n",(0,r.jsx)(n.li,{children:"Combine different symbols using composites"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"1-prefer-regexp-rules-with-conditions",children:"1) Prefer regexp rules (with conditions)"}),"\n",(0,r.jsx)(n.p,{children:"Best starting point for: single-pattern detections, cheap text checks, header/body conditions."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fast and efficient"}),"\n",(0,r.jsxs)(n.li,{children:["Can be gated with ",(0,r.jsx)(n.code,{children:"re_conditions"})," to validate matches precisely"]}),"\n",(0,r.jsx)(n.li,{children:"Keep logic minimal; offload heavy checks to later stages"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Example with conditions (inspired by ",(0,r.jsx)(n.code,{children:"rules/bitcoin.lua"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"config.regexp['BITCOIN_ADDR'] = {\n  re = string.format('(%s) + (%s) > 0', normal_wallet_re, btc_bleach_re),\n  expression_flags = { 'noopt' },\n  re_conditions = {\n    [normal_wallet_re] = function(task, txt, s, e)\n      local word = lua_util.str_trim(txt:sub(s + 1, e))\n      local valid = is_traditional_btc_address(word)\n      if valid then\n        task:insert_result('BITCOIN_ADDR', 1.0, word)\n        return true\n      end\n      return false\n    end,\n    [btc_bleach_re] = function(task, txt, s, e)\n      local word = tostring(lua_util.str_trim(txt:sub(s + 1, e)))\n      local valid = is_segwit_bech32_address(task, word)\n      if valid then\n        task:insert_result('BITCOIN_ADDR', 1.0, word)\n        return true\n      end\n      return false\n    end,\n  },\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Tips:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keep regexps strict and bounded to avoid overmatching"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"re_conditions"})," to confirm complex formats (checksums, structure)"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-if-multiple-matches-are-required-prefer-multimaps",children:"2) If multiple matches are required, prefer multimaps"}),"\n",(0,r.jsx)(n.p,{children:"Use when you need many independent lookups: domains, IPs, keywords, MIME types, URLs, etc."}),"\n",(0,r.jsx)(n.p,{children:"Benefits:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Clean separation of data (maps) and logic"}),"\n",(0,r.jsx)(n.li,{children:"Efficient, built-in caching, easy to maintain lists"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# /etc/rspamd/local.d/multimap.conf\n\n# Block specific senders/domains\nBLOCKED_SENDERS {\n  type = "from";\n  map = "/etc/rspamd/maps/blocked_domains.list";\n  score = 8.0;\n}\n\n# Flag messages containing risky keywords\nRISKY_KEYWORDS {\n  type = "content";\n  map = "/etc/rspamd/maps/risky_keywords.list";\n  score = 3.0;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"When to choose: many patterns, externalized and frequently updated."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-if-you-need-async-calls--create-custom-lua-rules",children:"3) If you need async calls \u2014 create custom Lua rules"}),"\n",(0,r.jsx)(n.p,{children:"Use when you must perform asynchronous checks: HTTP queries, DNS, Redis/ClickHouse, external services."}),"\n",(0,r.jsx)(n.p,{children:"Example skeleton:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local rspamd_http = require \"rspamd_http\"\n\nrspamd_config:register_symbol({\n  name = 'MY_ASYNC_CHECK',\n  callback = function(task)\n    local url = 'https://example.com/check?id=' .. task:get_message_id()\n    rspamd_http.request({\n      url = url,\n      task = task,\n      timeout = 1.5,\n      callback = function(err, code, body)\n        if not err and code == 200 and body == 'bad' then\n          task:insert_result('MY_ASYNC_CHECK', 1.0)\n        end\n      end,\n    })\n    return false\n  end,\n  flags = 'empty',\n})\n"})}),"\n",(0,r.jsx)(n.p,{children:"Notes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Return quickly; set results in the async callback"}),"\n",(0,r.jsx)(n.li,{children:"Respect timeouts; avoid blocking work"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-if-you-need-configuration-and-multi-symbol-logic--write-a-plugin",children:"4) If you need configuration and multi-symbol logic \u2014 write a plugin"}),"\n",(0,r.jsx)(n.p,{children:"Use a plugin when you need:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Multiple symbols working together"}),"\n",(0,r.jsxs)(n.li,{children:["Structured configuration under ",(0,r.jsx)(n.code,{children:"local.d/<plugin>.conf"})]}),"\n",(0,r.jsx)(n.li,{children:"Reuse across deployments"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Minimal plugin shape:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local lua_util = require \"lua_util\"\n\nlocal M = 'my_plugin'\n\nlocal function check_one(task)\n  -- lightweight logic here\n  if task:get_header('X-Flag') == 'on' then\n    task:insert_result('MY_PLUGIN_SYMBOL', 1.0)\n  end\nend\n\nrspamd_config:register_symbol({\n  name = 'MY_PLUGIN_SYMBOL',\n  callback = check_one,\n  score = 0.0,\n  group = 'policies',\n})\n\nreturn {\n  name = M,\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Configuration example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:"# /etc/rspamd/local.d/my_plugin.conf\nenabled = true;\nthreshold = 5;\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-combine-different-symbols-using-composites",children:"5) Combine different symbols using composites"}),"\n",(0,r.jsx)(n.p,{children:"Use composites to express higher-level logic without duplicating work."}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# /etc/rspamd/local.d/composites.conf\n\nSUSPICIOUS_OUTBOUND {\n  expression = "(MY_ASYNC_CHECK & RISKY_KEYWORDS) | (BLOCKED_SENDERS & /DMARC_.*//)";\n  score = 6.0;\n  policy = "leave"; # keep original symbols as well\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Guidelines:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Compose existing symbols first; avoid re-implementing logic"}),"\n",(0,r.jsx)(n.li,{children:"Use composites to define actions/policies at a higher level"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"quick-reference",children:"Quick Reference"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Prefer ",(0,r.jsx)(n.strong,{children:"regexp rules"})," with ",(0,r.jsx)(n.code,{children:"re_conditions"})," for single-pattern checks"]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.strong,{children:"multimaps"})," for many independent lookups"]}),"\n",(0,r.jsxs)(n.li,{children:["Write ",(0,r.jsx)(n.strong,{children:"Lua rules"})," for async operations"]}),"\n",(0,r.jsxs)(n.li,{children:["Create a ",(0,r.jsx)(n.strong,{children:"plugin"})," for configurable, multi-symbol logic"]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.strong,{children:"composites"})," to combine symbols into richer signals"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);