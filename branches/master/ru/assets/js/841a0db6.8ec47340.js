"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[3385],{28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(96540);const r={},d=t.createContext(r);function i(e){const n=t.useContext(d);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(d.Provider,{value:n},e.children)}},29439:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"workers/fuzzy_storage","title":"Fuzzy storage worker","description":"Fuzzy storage worker is intended to store fuzzy hashes of messages.","source":"@site/docs/workers/fuzzy_storage.md","sourceDirName":"workers","slug":"/workers/fuzzy_storage","permalink":"/docs.rspamd.com/branches/master/ru/workers/fuzzy_storage","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/workers/fuzzy_storage.md","tags":[],"version":"current","frontMatter":{"title":"Fuzzy storage worker"},"sidebar":"docs","previous":{"title":"Proxy worker","permalink":"/docs.rspamd.com/branches/master/ru/workers/rspamd_proxy"},"next":{"title":"Modules documentation","permalink":"/docs.rspamd.com/branches/master/ru/modules/"}}');var r=s(74848),d=s(28453);const i={title:"Fuzzy storage worker"},o="Fuzzy storage worker",l={},c=[{value:"Protocol format",id:"protocol-format",level:2},{value:"Storage format",id:"storage-format",level:2},{value:"Operation notes",id:"operation-notes",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Storage options",id:"storage-options",level:3},{value:"Security options",id:"security-options",level:3},{value:"Replication options",id:"replication-options",level:3},{value:"Advanced options",id:"advanced-options",level:3},{value:"Compatibility notes",id:"compatibility-notes",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"fuzzy-storage-worker",children:"Fuzzy storage worker"})}),"\n",(0,r.jsx)(n.p,{children:"Fuzzy storage worker is intended to store fuzzy hashes of messages."}),"\n",(0,r.jsx)(n.h2,{id:"protocol-format",children:"Protocol format"}),"\n",(0,r.jsxs)(n.p,{children:["Fuzzy storage accepts requests using ",(0,r.jsx)(n.code,{children:"UDP"})," protocol with the following structure:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-C",children:"struct fuzzy_cmd  { /* attribute(packed) */\n\tunit8_t version;        /* command version, must be 0x2 */\n\tunit8_t cmd;            /* numeric command */\n\tunit8_t shingles_count; /* number of shingles */\n\tunit8_t flag;           /* flag number */\n\tint32_t value;          /* value to store */\n\tuint32_t tag;           /* random tag */\n\tchar digest[64];        /* blake2b digest */\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"All numbers are in host byte order, so if you want to check fuzzy hashes from a\nhost with a different byte order, you need some additional conversions (not currently\nsupported by Rspamd). In the future, Rspamd might use little-endian byte order for all\noperations."}),"\n",(0,r.jsx)(n.p,{children:"Fuzzy storage accepts the following commands:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"FUZZY_CHECK"})," - check for a fuzzy hash"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"FUZZY_ADD"})," - add a new hash"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"FUZZY_DEL"})," - remove a hash"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"flag"})," field is used to store different hashes in a single storage. For example,\nit allows storing blacklists and whitelists in the same fuzzy storage worker.\nA client should set the ",(0,r.jsx)(n.code,{children:"flag"})," field when adding or deleting hashes and check it\nwhen querying for a hash."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"value"})," is added to the currently stored value of a hash if that hash has been found.\nThis field can handle negative numbers as well."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"tag"})," is used to distinguish requests by a client. Fuzzy storage just sets this\nfield in the reply equal to the value in the request."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"digest"})," field contains the content of the hash. Currently, Rspamd uses the ",(0,r.jsx)(n.code,{children:"blake2b"})," hash\nin its binary form, providing ",(0,r.jsx)(n.code,{children:"2^512"})," possible hashes with negligible collision\nprobability. At the same time, Rspamd saves the legacy format of fuzzy hashes by\nmeans of this field. Old Rspamd can work with legacy hashes only."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"shingles_count"})," defines how many ",(0,r.jsx)(n.code,{children:"shingles"})," are attached to this command.\nCurrently, Rspamd uses 32 shingles, so this value should be set to 32 for commands\nwith shingles. Shingles should be included in the same packet and follow the command as\nan array of int64_t values. Please note that Rspamd rejects commands that have the wrong\nshingle count or if their size is not equal to the desired one:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"sizeof(fuzzy_cmd) + shingles_count * sizeof(int64_t)\n"})}),"\n",(0,r.jsx)(n.p,{children:"The reply format of fuzzy storage is also presented as a structure:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-C",children:"struct fuzzy_cmd  { /* attribute(packed) */\n\tint32_t value;\n\tuint32_t flag;\n\tuint32_t tag;\n\tfloat prob;\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"prob"})," field is used to store the probability of match. This value is changed from\n",(0,r.jsx)(n.code,{children:"0.0"})," (no match) to ",(0,r.jsx)(n.code,{children:"1.0"})," (full match)."]}),"\n",(0,r.jsx)(n.h2,{id:"storage-format",children:"Storage format"}),"\n",(0,r.jsxs)(n.p,{children:["Rspamd's fuzzy storage uses ",(0,r.jsx)(n.code,{children:"sqlite3"})," for storing hashes. All update operations are\nperformed in a transaction, which is committed to the main database approximately once\nper minute. The ",(0,r.jsx)(n.code,{children:"VACUUM"})," command is executed on startup, and hash expiration is performed\nwhen the Rspamd fuzzy storage worker terminates."]}),"\n",(0,r.jsx)(n.p,{children:"Here is the internal database structure:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"CREATE TABLE digests(id INTEGER PRIMARY KEY,\n\tflag INTEGER NOT NULL,\n\tdigest TEXT NOT NULL,\n\tvalue INTEGER,\n\ttime INTEGER);\n\nCREATE TABLE shingles(value INTEGER NOT NULL,\n\tnumber INTEGER NOT NULL,\n\tdigest_id INTEGER REFERENCES digests(id) ON DELETE CASCADE ON UPDATE CASCADE);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Since Rspamd uses normal sqlite3 you can use all tools for working with the hashes\ndatabase to perform, for example backup or analysis."}),"\n",(0,r.jsx)(n.h2,{id:"operation-notes",children:"Operation notes"}),"\n",(0,r.jsxs)(n.p,{children:["To check a hash, Rspamd fuzzy storage initially queries for a direct match using\nthe ",(0,r.jsx)(n.code,{children:"digest"})," field as a key. If that match succeeds, the value is returned immediately.\nOtherwise, if a command contains shingles, then Rspamd checks for a fuzzy match by attempting\nto find the value for each shingle. If more than 50% of the shingles match the same digest,\nRspamd returns that digest's value along with the probability of the match, which generally\nequals ",(0,r.jsx)(n.code,{children:"match_count / shingles_count"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Fuzzy storage accepts the following configuration options:"}),"\n",(0,r.jsx)(n.h3,{id:"storage-options",children:"Storage options"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Option"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"hashfile"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsxs)(n.td,{children:["Path to the sqlite storage (aliases: ",(0,r.jsx)(n.code,{children:"hash_file"}),", ",(0,r.jsx)(n.code,{children:"file"}),", ",(0,r.jsx)(n.code,{children:"database"}),")"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"backend"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sqlite"})}),(0,r.jsxs)(n.td,{children:["Storage backend: ",(0,r.jsx)(n.code,{children:"sqlite"})," or ",(0,r.jsx)(n.code,{children:"redis"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sync"})}),(0,r.jsx)(n.td,{children:"60s"}),(0,r.jsx)(n.td,{children:"Time interval to perform database sync"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"expire"})}),(0,r.jsx)(n.td,{children:"2d"}),(0,r.jsx)(n.td,{children:"Default expire time for hashes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"delay"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"Default delay time for hashes (not enabled by default)"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"security-options",children:"Security options"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Option"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"keypair"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsxs)(n.td,{children:["Encryption keypair (can be repeated for different keys), generate via ",(0,r.jsx)(n.code,{children:"rspamadm keypair -u"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"keypair_cache_size"})}),(0,r.jsx)(n.td,{children:"512"}),(0,r.jsx)(n.td,{children:"Size of keypairs cache"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"encrypted_only"})}),(0,r.jsx)(n.td,{children:"false"}),(0,r.jsx)(n.td,{children:"Allow only encrypted requests (forbid unknown keys or plaintext)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"allow_update"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"IP addresses/map allowed to perform modifications"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"allow_update_keys"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"Public keys allowed to perform modifications"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"blocked"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"Block requests from specific networks"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"read_only"})}),(0,r.jsx)(n.td,{children:"false"}),(0,r.jsx)(n.td,{children:"Work in read-only mode"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"replication-options",children:"Replication options"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Option"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"master_timeout"})}),(0,r.jsx)(n.td,{children:"10s"}),(0,r.jsx)(n.td,{children:"Master protocol I/O timeout"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sync_keypair"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"Encryption key for master/slave updates"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"masters"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"IP addresses allowed for master/slave updates"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"master_key"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"Key allowed for master/slave updates"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"slave"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"List of slave hosts"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"mirror"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsxs)(n.td,{children:["Alias for ",(0,r.jsx)(n.code,{children:"slave"})]})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"advanced-options",children:"Advanced options"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Option"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"tcp_timeout"})}),(0,r.jsx)(n.td,{children:"5s"}),(0,r.jsx)(n.td,{children:"TCP connection timeout"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"updates_maxfail"})}),(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"Maximum update failures before discarding"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"dedicated_update_worker"})}),(0,r.jsx)(n.td,{children:"false"}),(0,r.jsx)(n.td,{children:"Use worker 0 for updates only"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"delay_whitelist"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"Disable delay check for specific IP addresses"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"forbidden_ids"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"Deny specific flags by default"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"weak_ids"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"Flags treated as weak (don't overwrite strong flags)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"dynamic_keys_map"})}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:"Map for dynamic encryption keypairs"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Here is an example configuration of fuzzy storage:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'worker "fuzzy" {\n   bind_socket = "*:11335";\n   hashfile = "${DBDIR}/fuzzy.db"\n   expire = 90d;\n   allow_update = ["127.0.0.1", "::1"];\n   keypair = [\n   {\n     pubkey = ...\n     privkey = ...\n   },\n   {\n     pubkey = ...\n     privkey = ...\n   },\n   {\n     pubkey = ...\n     privkey = ...\n   }\n   ]\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"compatibility-notes",children:"Compatibility notes"}),"\n",(0,r.jsxs)(n.p,{children:["Rspamd fuzzy storage version ",(0,r.jsx)(n.code,{children:"0.8"})," is compatible with Rspamd clients of all versions.\nHowever, all updates from legacy versions (less than ",(0,r.jsx)(n.code,{children:"0.8"}),") won't update the fuzzy shingles\ndatabase. The Rspamd ",(0,r.jsx)(n.a,{href:"/modules/fuzzy_check",children:"fuzzy check module"})," can work ",(0,r.jsx)(n.strong,{children:"only"}),"\nwith the recent Rspamd fuzzy storage and won't retrieve anything from the legacy storages."]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);