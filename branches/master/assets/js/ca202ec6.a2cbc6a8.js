"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[7613],{4487:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"modules/neural","title":"Neural network module","description":"Neural network module is an experimental module that allows to perform post-classification of messages based on their current symbols and some training corpus obtained from the previous learns.","source":"@site/docs/modules/neural.md","sourceDirName":"modules","slug":"/modules/neural","permalink":"/docs.rspamd.com/branches/master/modules/neural","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/modules/neural.md","tags":[],"version":"current","frontMatter":{"title":"Neural network module"},"sidebar":"docs","previous":{"title":"MX Check module","permalink":"/docs.rspamd.com/branches/master/modules/mx_check"},"next":{"title":"Once received module","permalink":"/docs.rspamd.com/branches/master/modules/once_received"}}');var r=s(4848),a=s(8453);const i={title:"Neural network module"},o="Neural network module",l={},d=[{value:"Configuration",id:"configuration",level:2},{value:"Configuration options",id:"configuration-options",level:3},{value:"Settings usage",id:"settings-usage",level:3},{value:"Multiple networks",id:"multiple-networks",level:3},{value:"Manual learning",id:"manual-learning",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"neural-network-module",children:"Neural network module"})}),"\n",(0,r.jsx)(n.p,{children:"Neural network module is an experimental module that allows to perform post-classification of messages based on their current symbols and some training corpus obtained from the previous learns."}),"\n",(0,r.jsxs)(n.p,{children:["To use this module in versions prior to Rspamd 2.0, ranging from Rspamd 1.7 up to version 2.0, you must build Rspamd with ",(0,r.jsx)(n.code,{children:"libfann"})," support. Although it is typically enabled when using pre-built packages, you may specify it using ",(0,r.jsx)(n.code,{children:"-DENABLE_FANN=ON"})," with the ",(0,r.jsx)(n.code,{children:"cmake"})," command during the building process."]}),"\n",(0,r.jsxs)(n.p,{children:["Since Rspamd 2.0, the ",(0,r.jsx)(n.code,{children:"libfann"})," module has been replaced with ",(0,r.jsx)(n.a,{href:"https://github.com/attractivechaos/kann",children:"kann"})," to provide more powerful neural network processing, making it the preferred option for all new installations."]}),"\n",(0,r.jsx)(n.p,{children:"The Neural Network learns by classifying messages as spam or ham, and adjusting its parameters accordingly. Several heuristics are employed to achieve this, so it is not solely based on a plain score. You can also use your own criteria for learning."}),"\n",(0,r.jsx)(n.p,{children:"The training occurs in the background, and once a certain amount of training is complete, the Neural Network is updated and stored in a Redis server. This allows scanners to load and update their own data."}),"\n",(0,r.jsxs)(n.p,{children:["After a set number of training iterations (by default, ",(0,r.jsx)(n.code,{children:"10"}),"), the training process removes the old Neural Network and begins training a new one. This ensures that old data does not influence the current processing. Once the Neural Network is trained, its data is saved into Redis, where all Rspamd scanners share their learning data. Additionally, intermediate training vectors are stored in Redis. The ANN and training data are compressed using the ",(0,r.jsx)(n.code,{children:"zstd"})," compressor before being saved in Redis."]}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["By default, this module is explicitly ",(0,r.jsx)(n.strong,{children:"disabled"}),", so you will need to enable it either in the local or override configuration."]}),"\n",(0,r.jsxs)(n.p,{children:["Ensure that at least one Redis server is ",(0,r.jsx)(n.a,{href:"/configuration/redis",children:"specified"})," in the common ",(0,r.jsx)(n.code,{children:"redis"})," section. Alternatively, you can define the Redis server in the module configuration:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# local.d/neural.conf\nservers = "localhost";\nenabled = true; # Important after 1.7\n'})}),"\n",(0,r.jsxs)(n.p,{children:["It is also necessary to ",(0,r.jsx)(n.strong,{children:"define the scores"})," for symbols added by this module, as they are set to zero by default. To accomplish this, you must edit the ",(0,r.jsx)(n.code,{children:"local.d/neural_group.conf"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# local.d/neural_group.conf\n\nsymbols = {\n  "NEURAL_SPAM" {\n    weight = 3.0; # sample weight\n    description = "Neural network spam";\n  }\n  "NEURAL_HAM" {\n    weight = -3.0; # sample weight\n    description = "Neural network ham";\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"configuration-options",children:"Configuration options"}),"\n",(0,r.jsx)(n.p,{children:"The neural networks module supports various configuration options for setting up different neural networks. Starting from version 1.7, it supports multiple rules with both automatic and non-automatic neural networks. However, this configuration is usually too advanced for general usage."}),"\n",(0,r.jsx)(n.p,{children:"By default, you can use the old configuration style, such as:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# local.d/neural.conf\n\nservers = "127.0.0.1:6379";\n\ntrain {\n  max_trains = 1k; # Number ham/spam samples needed to start train\n  max_usages = 20; # Number of learn iterations while ANN data is valid\n  learning_rate = 0.01; # Rate of learning\n  max_iterations = 25; # Maximum iterations of learning (better preciseness but also lower speed of learning)\n}\n\nann_expire = 2d; # For how long ANN should be preserved in Redis\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In this code snippet, we define a simple network that automatically learns ham and spam on messages with corresponding actions. Upon creation, it is allowed to undergo additional training for up to 20 more times. Rspamd trains a neural network when ",(0,r.jsx)(n.code,{children:"(ham_samples + spam_samples) >= max_trains"}),". It also automatically maintains equal proportions of spam and ham samples to provide fair training. If you are running a small email system, then you can increase ",(0,r.jsx)(n.code,{children:"max_usages"})," to preserve trained networks for a longer time (you may also adjust ",(0,r.jsx)(n.code,{children:"ann_expire"})," accordingly)."]}),"\n",(0,r.jsx)(n.p,{children:"Rspamd can use the same neural network from multiple processes running on multiple hosts across the network. It is guaranteed that processes with different configuration symbols enabled will use different neural networks (each network has a hash of all symbols defined as a suffix for Redis keys). Furthermore, there is a guarantee that all learning will be done in a single process that atomically updates neural network data after learning."}),"\n",(0,r.jsx)(n.h3,{id:"settings-usage",children:"Settings usage"}),"\n",(0,r.jsxs)(n.p,{children:["Rspamd automatically selects different networks for different sets of ",(0,r.jsx)(n.a,{href:"/configuration/settings",children:"user settings"})," based on their settings ID. The settings ID is appended to the neural network name to identify which network to use. This feature can be useful for splitting neural networks for inbound and outbound users identified by settings."]}),"\n",(0,r.jsxs)(n.p,{children:["To set which rules in ",(0,r.jsx)(n.code,{children:"neural.conf"})," apply to different settings IDs, you can either set ",(0,r.jsx)(n.code,{children:'allowed_settings = "all";'})," in the rules section to allow messages with all possible settings IDs to train the rule, or ",(0,r.jsx)(n.code,{children:'allowed_settings = [ "settings-id1", "settings-id2" ];'})," to allow only messages with specific settings IDs to do so."]}),"\n",(0,r.jsx)(n.h3,{id:"multiple-networks",children:"Multiple networks"}),"\n",(0,r.jsxs)(n.p,{children:["Starting from version 1.7, Rspamd offers support for multiple neural networks that can be defined in the configuration. This feature can be useful when setting up long or short neural networks, where one network has a high ",(0,r.jsx)(n.code,{children:"max_usages"})," and a large ",(0,r.jsx)(n.code,{children:"max_trains"}),", while the other reacts quickly to newly detected patterns. However, in practice, this setup is not usually more effective, so it is recommended to use a single network instead."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# local.d/neural.conf\nrules {\n  "LONG" {\n    train {\n      max_trains = 5000;\n      max_usages = 200;\n      max_iterations = 25;\n      learning_rate = 0.01,\n    }\n    symbol_spam = "NEURAL_SPAM_LONG";\n    symbol_ham = "NEURAL_HAM_LONG";\n    ann_expire = 100d;\n  }\n  "SHORT" {\n    train {\n      max_trains = 100;\n      max_usages = 2;\n      max_iterations = 25;\n      learning_rate = 0.01,\n    }\n    symbol_spam = "NEURAL_SPAM_SHORT";\n    symbol_ham = "NEURAL_HAM_SHORT";\n    ann_expire = 1d;\n  }\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# local.d/neural_group.conf\n\nsymbols = {\n  "NEURAL_SPAM_LONG" {\n    weight = 3.0; # sample weight\n    description = "Neural network spam (long)";\n  }\n  "NEURAL_HAM_LONG" {\n    weight = -3.0; # sample weight\n    description = "Neural network ham (long)";\n  }\n  "NEURAL_SPAM_SHORT" {\n    weight = 2.0; # sample weight\n    description = "Neural network spam (short)";\n  }\n  "NEURAL_HAM_SHORT" {\n    weight = -1.0; # sample weight\n    description = "Neural network ham (short)";\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"manual-learning",children:"Manual learning"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"This is a work-in-progress"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If you set ",(0,r.jsx)(n.code,{children:"store_pool_only = true"})," in the ",(0,r.jsx)(n.code,{children:"train"})," options, the neural module will store training vectors in MessagePack format and a profile digest in the task cache instead of performing online learning. These can then be saved to, for example, ClickHouse and used at a later time."]}),"\n",(0,r.jsx)(n.p,{children:"The configuration snippet below shows how to save these to ClickHouse:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'# local.d/clickhouse.conf\nextra_columns = {\n\tNeural_Vec = {\n\t\tselector = "task_cache(\'neural_vec_mpack\')";\n\t\ttype = "String";\n\t\tcomment = "Training vector for neural";\n        }\n\tNeural_Digest = {\n\t\tselector = "task_cache(\'neural_profile_digest\')";\n\t\ttype = "String";\n\t\tcomment = "Digest of neural profile";\n        }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The controller endpoint ",(0,r.jsx)(n.code,{children:"/plugins/neural/learn"})," facilitates manual training of neural networks & accepts a JSON POST with the following keys:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"spam_vec"})," and ",(0,r.jsx)(n.code,{children:"ham_vec"}),": are lists of lists of numbers containing training information"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rule"})," is an optional name of the rule to perform training for"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(6540);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);