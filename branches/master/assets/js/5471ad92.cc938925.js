"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[6598],{882:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"configuration/maps","title":"Rspamd maps","description":"Maps are one of the most important and flexible features in Rspamd, allowing for dynamic configuration of various elements without requiring service restarts. This article provides a comprehensive overview of Rspamd maps, their types, configuration options, and best practices.","source":"@site/docs/configuration/maps.md","sourceDirName":"configuration","slug":"/configuration/maps","permalink":"/docs.rspamd.com/branches/master/configuration/maps","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/configuration/maps.md","tags":[],"version":"current","frontMatter":{"title":"Rspamd maps"},"sidebar":"docs","previous":{"title":"Composite symbols","permalink":"/docs.rspamd.com/branches/master/configuration/composites"},"next":{"title":"Selectors","permalink":"/docs.rspamd.com/branches/master/configuration/selectors"}}');var a=s(4848),r=s(8453);const l={title:"Rspamd maps"},t="Rspamd Maps: A Comprehensive Guide",o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"What Are Maps?",id:"what-are-maps",level:2},{value:"Map Types",id:"map-types",level:2},{value:"Map Configuration Formats",id:"map-configuration-formats",level:2},{value:"1. Simple String URL",id:"1-simple-string-url",level:3},{value:"2. Composite Path Array",id:"2-composite-path-array",level:3},{value:"3. Embedded Data",id:"3-embedded-data",level:3},{value:"4. Detailed Configuration Object",id:"4-detailed-configuration-object",level:3},{value:"Map Content Format",id:"map-content-format",level:2},{value:"Basic Formats",id:"basic-formats",level:3},{value:"Regular Expression Maps",id:"regular-expression-maps",level:3},{value:"IP Maps",id:"ip-maps",level:3},{value:"HTTP Maps and Caching",id:"http-maps-and-caching",level:2},{value:"Map Loading Lifecycle",id:"map-loading-lifecycle",level:2},{value:"How to sign maps",id:"how-to-sign-maps",level:2},{value:"External Maps",id:"external-maps",level:2},{value:"Authentication for HTTP Maps",id:"authentication-for-http-maps",level:2},{value:"1. Basic Auth in URL",id:"1-basic-auth-in-url",level:3},{value:"2. Configuration-based Authentication",id:"2-configuration-based-authentication",level:3},{value:"Compression Support",id:"compression-support",level:2},{value:"Fallback Options",id:"fallback-options",level:2},{value:"CDB Maps",id:"cdb-maps",level:2},{value:"Configuring CDB Maps",id:"configuring-cdb-maps",level:3},{value:"Creating CDB Files",id:"creating-cdb-files",level:3},{value:"Map API Reference",id:"map-api-reference",level:2},{value:"Adding Maps",id:"adding-maps",level:3},{value:"Using Maps",id:"using-maps",level:3},{value:"Map Expressions",id:"map-expressions",level:2},{value:"What Are Map Expressions?",id:"what-are-map-expressions",level:3},{value:"Configuration Format",id:"configuration-format",level:3},{value:"Expression Syntax",id:"expression-syntax",level:3},{value:"Selectors",id:"selectors",level:3},{value:"Processing and Results",id:"processing-and-results",level:3},{value:"Example Usage",id:"example-usage",level:3},{value:"Benefits of Map Expressions",id:"benefits-of-map-expressions",level:3},{value:"API Reference",id:"api-reference",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"rspamd-maps-a-comprehensive-guide",children:"Rspamd Maps: A Comprehensive Guide"})}),"\n",(0,a.jsx)(n.p,{children:"Maps are one of the most important and flexible features in Rspamd, allowing for dynamic configuration of various elements without requiring service restarts. This article provides a comprehensive overview of Rspamd maps, their types, configuration options, and best practices."}),"\n",(0,a.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#what-are-maps",children:"What Are Maps?"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#map-types",children:"Maps Types"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#map-configuration-formats",children:"Map Configuration Formats"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#map-content-format",children:"Map Content Format"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#http-maps-and-caching",children:"HTTP Maps and Caching"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#map-loading-lifecycle",children:"Map Loading Lifecycle"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#external-maps",children:"External Maps"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#authentication-for-http-maps",children:"Authentication for HTTP Maps"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#compression-support",children:"Compression Support"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#fallback-options",children:"Fallback Options"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#cdb-maps",children:"CDB Maps"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#map-api-reference",children:"Map API Reference"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"what-are-maps",children:"What Are Maps?"}),"\n",(0,a.jsx)(n.p,{children:"Maps in Rspamd are dynamic data sources that contain lists of keys or key-value pairs that can be reloaded at runtime without restarting the service. Maps can be defined using various backends including:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Local files"}),"\n",(0,a.jsx)(n.li,{children:"HTTP/HTTPS resources"}),"\n",(0,a.jsx)(n.li,{children:"Static data embedded in the configuration"}),"\n",(0,a.jsx)(n.li,{children:"CDB (Constant Database) files"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'The significant distinction between maps and static configuration elements is that maps can be updated "live" without the costly restart procedure. Rspamd automatically monitors maps for changes:'}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["For file maps: checking file modification time and the ",(0,a.jsx)(n.code,{children:"inotify"})," where available (meaning you must save maps files atomically using ",(0,a.jsx)(n.code,{children:"rename"})," as otherwise you might end up with an incomplete load)"]}),"\n",(0,a.jsx)(n.li,{children:"For HTTP maps: using HTTP caching headers (If-Modified-Since, ETag)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"map-types",children:"Map Types"}),"\n",(0,a.jsx)(n.p,{children:"Rspamd supports several map types, each with specific functionality:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"set"}),": Simple list of strings, optimized for fast lookups (membership tests)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"hash"}),": Key-value pairs where values can be arbitrary strings"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"radix"}),": IP address maps with optional CIDR notation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"regexp"}),": Regular expression patterns"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"regexp_multi"}),": Regular expressions that can match multiple captures"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"glob"}),": Glob-style pattern matching with wildcard characters"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"glob_multi"}),": Glob patterns that can match multiple captures"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"cdb"}),": Constant Database format for fast, read-only lookups"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Maps can specify their type using prefixes in URI definitions, like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"regexp;/path/to/file\nhash;http://example.com/map\nradix;/path/to/ip_list\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Performance consideration"}),": regular expression maps are slower than other type of maps especially if your Rspamd is built without ",(0,a.jsx)(n.code,{children:"Hyperscan"})," support."]}),"\n",(0,a.jsx)(n.h2,{id:"map-configuration-formats",children:"Map Configuration Formats"}),"\n",(0,a.jsx)(n.p,{children:"Maps can be defined in four main ways:"}),"\n",(0,a.jsx)(n.h3,{id:"1-simple-string-url",children:"1. Simple String URL"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'map = "http://example.com/file.txt"\n# or\nmap = "/path/to/local/file"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-composite-path-array",children:"2. Composite Path Array"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'map = [\n  "http://example.com/file.txt",\n  "/path/to/local/file"\n]\n'})}),"\n",(0,a.jsx)(n.p,{children:"When using composite paths, data from all sources is concatenated."}),"\n",(0,a.jsx)(n.h3,{id:"3-embedded-data",children:"3. Embedded Data"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'map = [\n  "foo bar",\n  "baz qux"\n]\n\n# For IP maps:\nip_list = [\n  "192.168.1.1/24",\n  "10.0.0.0/8"\n]\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-detailed-configuration-object",children:"4. Detailed Configuration Object"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'map = {\n  name = "My important map";\n  description = "Contains important data";\n  url = "http://example.com/map.txt";\n  timeout = 10.0; # in seconds\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Or for multiple URLs:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'map = {\n  name = "Multi-source map";\n  urls = [\n    "http://example.com/map.txt",\n    "/local/backup/map.txt"\n  ];\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"map-content-format",children:"Map Content Format"}),"\n",(0,a.jsx)(n.p,{children:"Maps can contain various elements depending on their type:"}),"\n",(0,a.jsx)(n.h3,{id:"basic-formats",children:"Basic Formats"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'key1 # Single key with comment\n# Full line comment is ignored\n\n# Empty line ignored\nkey2 1 # Key and value (for hash maps)\n"key3 with space"\n"key with \\" escaped" value with spaces\n'})}),"\n",(0,a.jsx)(n.h3,{id:"regular-expression-maps",children:"Regular Expression Maps"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"/regexp/i\n/regexp/is some other value\n"})}),"\n",(0,a.jsx)(n.p,{children:"Options after the final slash:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"i"})," - ignore case"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"u"})," - use UTF-8 regexp"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"m"})," - multi-line regular expression - this flag causes the string to be treated as multiple lines. This means that the ",(0,a.jsx)(n.code,{children:"^"})," and ",(0,a.jsx)(n.code,{children:"$"})," symbols match the start and end of each line within the string, rather than just the start and end of the first and last lines."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"x"})," - extended regular expression - this flag instructs the regular expression parser to ignore most white-space that is not escaped (",(0,a.jsx)(n.code,{children:"\\"}),") or within a bracketed character class. This makes it possible to break up the regular expression into more readable parts. Additionally, the ",(0,a.jsx)(n.code,{children:"#"})," character is treated as a meta-character that introduces a comment which runs up to the pattern's closing delimiter or to the end of the current line if the pattern extends onto the next line."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"s"})," - dot-all regular expression - this flag causes the string to be treated as a single line. This means that the ",(0,a.jsx)(n.code,{children:"."})," symbol matches any character whatsoever, including a newline, which it would not normally match. When used together as ",(0,a.jsx)(n.code,{children:"/ms"}),", they allow the ",(0,a.jsx)(n.code,{children:"."})," to match any character while still allowing ",(0,a.jsx)(n.code,{children:"^"})," and ",(0,a.jsx)(n.code,{children:"$"})," to respectively match just after and just before newlines within the string"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"O"})," - do not optimize regexp (rspamd optimizes regexps by default)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"r"})," - use non-UTF-8 regular expressions (raw bytes). Defaults to ",(0,a.jsx)(n.code,{children:"true"})," if ",(0,a.jsx)(n.code,{children:"raw_mode"})," is set to ",(0,a.jsx)(n.code,{children:"true"})," in the options section."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"A"})," - return and process all matches (useful for Lua prefilters)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"L"})," - match left part of regexp (useful for Lua prefilters in conjunction with Hyperscan)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Please note that you ",(0,a.jsx)(n.strong,{children:"must"})," use ",(0,a.jsx)(n.code,{children:"/u"})," modifier if you want to match UTF8 characters or classes."]}),"\n",(0,a.jsx)(n.h3,{id:"ip-maps",children:"IP Maps"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"192.168.0.1 # Mask is /32 (single IP)\n[::1] # IPv6, mask is /128\n[::1]/64 # IPv6 with CIDR\n192.168.0.1/19 # IPv4 with CIDR\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can mix both IPv4 and IPv6 addresses or networks in a single map."}),"\n",(0,a.jsx)(n.h2,{id:"http-maps-and-caching",children:"HTTP Maps and Caching"}),"\n",(0,a.jsx)(n.p,{children:"Rspamd implements sophisticated caching for HTTP maps:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"When a map is first loaded from HTTP, Rspamd caches it locally."}),"\n",(0,a.jsxs)(n.li,{children:["For subsequent requests, Rspamd:\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Uses HTTP conditional requests (If-Modified-Since, ETag)"}),"\n",(0,a.jsx)(n.li,{children:"Respects Cache-Control and Expires headers"}),"\n",(0,a.jsx)(n.li,{children:"Stores the cached data for quick loading on restart"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"There are two main startup scenarios:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Hot start"}),": Rspamd reuses cached maps immediately, then checks for updates."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cold start"}),": Rspamd fetches maps when workers start, which can cause a temporary gap."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"To provide resilience, you can configure fallback options:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'map = [\n  "https://maps.rspamd.com/rspamd/whitelist.inc.zst",\n  "${DBDIR}/local_whitelist.inc",\n  "fallback+file://${CONFDIR}/maps.d/whitelist.inc"\n];\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, the ",(0,a.jsx)(n.code,{children:"fallback+file://"})," option is used only when the HTTP source is unavailable during cold starts."]}),"\n",(0,a.jsx)(n.h2,{id:"map-loading-lifecycle",children:"Map Loading Lifecycle"}),"\n",(0,a.jsx)(n.p,{children:"When Rspamd is running, maps follow a specific lifecycle:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Initialization"}),": Maps are registered during configuration parsing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Initial Load"}),":\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"File maps are read directly"}),"\n",(0,a.jsx)(n.li,{children:"HTTP maps are loaded from cache if available, or fetched"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Periodic Checks"}),":\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"File maps: Rspamd watches for file modifications using a filesystem monitoring mechanism"}),"\n",(0,a.jsx)(n.li,{children:"HTTP maps: Rspamd schedules periodic checks based on cache headers or default poll interval"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The default poll interval can be adjusted in the configuration:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:"options {\n  map_timeout = 60s; # Default HTTP map poll interval\n  map_file_watch_multiplier = 0.1; # Local files are checked more frequently\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"how-to-sign-maps",children:"How to sign maps"}),"\n",(0,a.jsxs)(n.p,{children:["From Rspamd version 1.2 onwards, each map can have a digital signature using the ",(0,a.jsx)(n.code,{children:"EdDSA"})," algorithm. To sign a map, you can use ",(0,a.jsx)(n.code,{children:"rspamadm signtool"}),", and to generate a signing keypair, use ",(0,a.jsx)(n.code,{children:"rspamadm keypair -s -u"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'keypair {\n   pubkey = "zo4sejrs9e5idqjp8rn6r3ow3x38o8hi5pyngnz6ktdzgmamy48y";\n   privkey = "pwq38sby3yi68xyeeuup788z6suqk3fugrbrxieri637bypqejnqbipt1ec9tsm8h14qerhj1bju91xyxamz5yrcrq7in8qpsozywxy";\n   id = "bs4zx9tcf1cs5ed5mt4ox8za54984frudpzzny3jwdp8mkt3feh7nz795erfhij16b66piupje4wooa5dmpdzxeh5mi68u688ixu3yd";\n   encoding = "base32";\n   algorithm = "curve25519";\n   type = "sign";\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Then you can use ",(0,a.jsx)(n.code,{children:"signtool"})," to edit the map file:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"rspamadm signtool -e --editor=vim -k <keypair_file> <map_file>\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To enforce signing policies, you should add a ",(0,a.jsx)(n.code,{children:"sign+"})," string to your map definition:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'map = "sign+http://example.com/map"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["To specify the trusted key you could either put the ",(0,a.jsx)(n.strong,{children:"public"})," key from the keypair in the ",(0,a.jsx)(n.code,{children:"local.d/options.inc"})," file as following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'trusted_keys = ["<public key string>"];\n'})}),"\n",(0,a.jsxs)(n.p,{children:["or add it as a ",(0,a.jsx)(n.code,{children:"key"})," definition in the map string:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'map = "sign+key=<key_string>+http://example.com/map"\n'})}),"\n",(0,a.jsx)(n.h2,{id:"external-maps",children:"External Maps"}),"\n",(0,a.jsx)(n.p,{children:'Rspamd supports "external maps" for dynamic lookups to external services. These maps query an external service for each key lookup rather than loading the entire map into memory.'}),"\n",(0,a.jsxs)(n.p,{children:["External maps are configured with the ",(0,a.jsx)(n.code,{children:"external = true"})," parameter:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'external_map = {\n  external = true;\n  backend = "http://lookup-service.local/api";\n  method = "query"; # Can be "query", "header", or "body"\n  timeout = 1.0;    # Timeout in seconds\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"The external map API has three methods for passing lookup keys:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"query"}),": Appends the key as a URL query parameter"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"header"}),": Sends the key in an HTTP header"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"body"}),": Sends the key in the request body"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For complex data structures, you can specify an encoding:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'external_map = {\n  external = true;\n  backend = "http://lookup-service.local/api";\n  method = "body";\n  encode = "json";  # Can be "json" or "messagepack"\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"authentication-for-http-maps",children:"Authentication for HTTP Maps"}),"\n",(0,a.jsx)(n.p,{children:"HTTP maps support two authentication methods:"}),"\n",(0,a.jsx)(n.h3,{id:"1-basic-auth-in-url",children:"1. Basic Auth in URL"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'map = "http://user:password@example.com/map.txt"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-configuration-based-authentication",children:"2. Configuration-based Authentication"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'options {\n  http_auth {\n    example.com {\n      user = "username";\n      password = "secret";\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This approach is more secure as credentials aren't stored in map URLs."}),"\n",(0,a.jsx)(n.h2,{id:"compression-support",children:"Compression Support"}),"\n",(0,a.jsx)(n.p,{children:"Rspamd supports compressed maps with Zstandard (.zst or .zstd extension):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'map = "https://maps.rspamd.com/rspamd/whitelist.inc.zst"\n'})}),"\n",(0,a.jsx)(n.p,{children:"Compressed maps:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Reduce network bandwidth usage"}),"\n",(0,a.jsx)(n.li,{children:"Reduce storage requirements for larger maps"}),"\n",(0,a.jsx)(n.li,{children:"Are automatically decompressed when loaded"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"fallback-options",children:"Fallback Options"}),"\n",(0,a.jsx)(n.p,{children:"For resilience, Rspamd supports fallback options for maps:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'map = [\n  "https://maps.rspamd.com/rspamd/whitelist.inc.zst",\n  "fallback+file://${CONFDIR}/maps.d/whitelist.inc"\n];\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"fallback+"})," prefix indicates this source should only be used if other sources fail:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"During cold starts when HTTP maps aren't available"}),"\n",(0,a.jsx)(n.li,{children:"When the primary source becomes unreachable"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"cdb-maps",children:"CDB Maps"}),"\n",(0,a.jsx)(n.p,{children:"Rspamd supports Constant Database (CDB) maps, which provide extremely fast, read-only key-value lookups. CDB maps are especially useful for large datasets with frequent lookups."}),"\n",(0,a.jsx)(n.h3,{id:"configuring-cdb-maps",children:"Configuring CDB Maps"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'cdb_map = {\n  external = true;\n  cdb = "/var/lib/rspamd/domain_settings.cdb";\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"CDB maps can be used in regular maps or as external maps for per-key lookups."}),"\n",(0,a.jsx)(n.h3,{id:"creating-cdb-files",children:"Creating CDB Files"}),"\n",(0,a.jsx)(n.p,{children:"CDB files can be created using the Rspamd Lua API:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local rspamd_cdb = require \"rspamd_cdb\"\nlocal builder = rspamd_cdb.build('/path/to/map.cdb')\nbuilder:add('key1', 'value1')\nbuilder:add('key2', 'value2')\nbuilder:finalize()\n"})}),"\n",(0,a.jsx)(n.p,{children:"Benefits of CDB over other map types:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Constant-time lookups (O(1) complexity)"}),"\n",(0,a.jsx)(n.li,{children:"Zero locking requirements for reads"}),"\n",(0,a.jsx)(n.li,{children:"Compact storage format"}),"\n",(0,a.jsx)(n.li,{children:"Atomic updates (by creating a new file and renaming)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"map-api-reference",children:"Map API Reference"}),"\n",(0,a.jsx)(n.p,{children:"Rspamd provides several Lua functions for working with maps programmatically:"}),"\n",(0,a.jsx)(n.h3,{id:"adding-maps",children:"Adding Maps"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local lua_maps = require \"lua_maps\"\n\n-- Add a map from configuration\nlocal my_map = lua_maps.map_add('module_name', 'option_name', 'map_type', 'description')\n\n-- Add a map from UCL object\nlocal my_map = lua_maps.map_add_from_ucl(ucl_object, 'map_type', 'description')\n\n-- Bulk map configuration\nlocal map_defs = {\n  my_map = {\n    type = 'set',\n    description = 'My important list',\n    optional = true\n  },\n  ip_map = {\n    type = 'radix',\n    description = 'IP blocklist'\n  }\n}\n\nlua_maps.fill_config_maps('module_name', options, map_defs)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"using-maps",children:"Using Maps"}),"\n",(0,a.jsx)(n.p,{children:"Once a map is loaded, you can use it for lookups:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"-- Simple lookup\nlocal result = my_map:get_key('test_key')\n\n-- With callback\nmy_map:get_key('test_key', function(is_found, value, code, task)\n  if is_found then\n    -- Use the value\n  end\nend, task)\n\n-- Iterate through all entries\nmy_map:foreach(function(key, value)\n  -- Process each entry\n  return true -- Continue iteration\nend)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["After analyzing the ",(0,a.jsx)(n.code,{children:"lua_maps_expressions.lua"})," file, I'll add information about map expressions to your article. This is an important feature that allows combining multiple maps with selectors in powerful expressions."]}),"\n",(0,a.jsx)(n.h2,{id:"map-expressions",children:"Map Expressions"}),"\n",(0,a.jsx)(n.p,{children:"Map expressions provide a powerful way to combine multiple maps using boolean logic. This feature allows you to create complex filtering rules by combining simpler components using logical operators."}),"\n",(0,a.jsx)(n.h3,{id:"what-are-map-expressions",children:"What Are Map Expressions?"}),"\n",(0,a.jsx)(n.p,{children:"Map expressions allow you to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Define multiple maps with different data sources"}),"\n",(0,a.jsx)(n.li,{children:"Associate each map with a selector that extracts values from messages"}),"\n",(0,a.jsx)(n.li,{children:"Combine these maps using logical expressions"}),"\n",(0,a.jsx)(n.li,{children:"Act on the combined result"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This creates a flexible framework for defining complex conditions without writing custom Lua code."}),"\n",(0,a.jsx)(n.h3,{id:"configuration-format",children:"Configuration Format"}),"\n",(0,a.jsx)(n.p,{children:"Map expressions are defined using a structured format:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'whitelist_ip_from = {\n  rules {\n    ip {\n      selector = "ip";\n      map = "/path/to/whitelist_ip.map";\n      type = "radix"; # Optional, can be automatically inferred\n    }\n    from {\n      selector = "from(smtp)";\n      map = "/path/to/whitelist_from.map";\n    }\n  }\n  expression = "ip & from";\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"The key components are:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"rules"}),": A collection of named rules, each with:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"selector"}),": A selector expression to extract values from the message"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"map"}),": A map definition (any format supported by the maps API)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"type"}),": Optional map type (if omitted, it's inferred from the rule name)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"description"}),": Optional description for the map"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"expression"}),": A logical expression combining the rules, using rule names as atoms"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"expression-syntax",children:"Expression Syntax"}),"\n",(0,a.jsx)(n.p,{children:"The expression syntax supports the following operators:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"&"})," - logical AND"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"|"})," - logical OR"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"!"})," - logical NOT"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"+"})," - arithmetic plus (can be used for weighted combinations)"]}),"\n",(0,a.jsxs)(n.li,{children:["Parentheses ",(0,a.jsx)(n.code,{children:"()"})," for grouping"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"ip & from           # Both IP and From must match\nip | from           # Either IP or From must match\nip & !from          # IP matches but From does not match\n(ip & from) | asn   # Either both IP and From match, or ASN matches\n"})}),"\n",(0,a.jsx)(n.h3,{id:"selectors",children:"Selectors"}),"\n",(0,a.jsx)(n.p,{children:"Selectors are functions that extract specific values from a message. Common selectors include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ip"})," - IP address of the message sender"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"from(smtp)"})," - SMTP From address"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"from(mime)"})," - From header in the message"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"rcpt(smtp)"})," - SMTP recipient"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"header(name)"})," - Value of a specific header"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"url"})," - URLs in the message"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"asn"})," - Autonomous System Number of the sender"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"You can create custom selectors or use any of Rspamd's built-in selectors."}),"\n",(0,a.jsx)(n.h3,{id:"processing-and-results",children:"Processing and Results"}),"\n",(0,a.jsx)(n.p,{children:"When a task is processed against a map expression:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Each rule's selector extracts values from the message"}),"\n",(0,a.jsx)(n.li,{children:"Each extracted value is checked against the corresponding map"}),"\n",(0,a.jsx)(n.li,{children:"The expression combines the results of individual map lookups"}),"\n",(0,a.jsx)(n.li,{children:"If the expression evaluates to a positive number, it's considered a match"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"When a match occurs, the function returns:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"The value of the expression (typically 1.0)"}),"\n",(0,a.jsxs)(n.li,{children:["A detailed match table containing:\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Which rules matched"}),"\n",(0,a.jsx)(n.li,{children:"What values were extracted by selectors"}),"\n",(0,a.jsx)(n.li,{children:"What values were returned by maps"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,a.jsx)(n.p,{children:"Here's a complete example of creating and using a map expression:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'local lua_maps_expressions = require "lua_maps_expressions"\n\nlocal whitelist_config = {\n  rules = {\n    ip = {\n      selector = "ip",\n      map = "/path/to/whitelist_ip.map",\n      type = "radix"\n    },\n    from = {\n      selector = "from(smtp)",\n      map = "/path/to/whitelist_from.map",\n      type = "set"\n    },\n    domain = {\n      selector = "from(smtp).domain",\n      map = "/path/to/whitelist_domains.map",\n      type = "set"\n    }\n  },\n  expression = "(ip & from) | domain",\n  symbol = "WHITELIST_EXPRESSION" -- Optional symbol to register\n}\n\nlocal whitelist = lua_maps_expressions.create(rspamd_config, whitelist_config, "whitelist_module")\n\n-- Later in the code:\nlocal function symbol_callback(task)\n  local result, matched = whitelist:process(task)\n  \n  if result then\n    -- Matched! We can access details via the \'matched\' table\n    if matched.ip then\n      task:insert_result("IP_WHITELISTED", 1.0, matched.ip.matched)\n    end\n    if matched.from then\n      task:insert_result("FROM_WHITELISTED", 1.0, matched.from.matched)\n    end\n    if matched.domain then\n      task:insert_result("DOMAIN_WHITELISTED", 1.0, matched.domain.matched)\n    end\n  end\nend\n\nrspamd_config:register_symbol({\n  name = "CHECK_WHITELIST_EXPRESSION",\n  callback = symbol_callback\n})\n'})}),"\n",(0,a.jsx)(n.h3,{id:"benefits-of-map-expressions",children:"Benefits of Map Expressions"}),"\n",(0,a.jsx)(n.p,{children:"Map expressions offer several advantages:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Declarative configuration"}),": Define complex logic without custom code"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reusability"}),": The same maps can be reused in different expressions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Maintainability"}),": Easier to understand and modify than custom code"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance"}),": Optimized evaluation of expressions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Detailed results"}),": Access to which specific rules matched and their values"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"api-reference",children:"API Reference"}),"\n",(0,a.jsx)(n.p,{children:"The main API functions for map expressions include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"lua_maps_expressions.create(cfg, obj, module_name)"}),": Creates a map expression object"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"cfg"}),": Rspamd configuration object"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"obj"}),": Configuration table with ",(0,a.jsx)(n.code,{children:"rules"})," and ",(0,a.jsx)(n.code,{children:"expression"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"module_name"}),": Optional module name for logging"]}),"\n",(0,a.jsxs)(n.li,{children:["Returns: An expression object with a ",(0,a.jsx)(n.code,{children:"process(task)"})," method"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"expression:process(task)"}),": Evaluates the expression against a task"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Returns: ",(0,a.jsx)(n.code,{children:"nil"})," if no match, or two values if matched:\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"The expression result (typically 1.0)"}),"\n",(0,a.jsx)(n.li,{children:"A table of match details by rule name"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Maps are one of the most powerful features in Rspamd, allowing for dynamic configuration and real-time updates without service restarts. By understanding the different map types, configuration options, and best practices, you can build flexible and efficient filtering rules that adapt to changing conditions."}),"\n",(0,a.jsx)(n.p,{children:"When designing your Rspamd setup, consider:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Using HTTP maps for centralized management"}),"\n",(0,a.jsx)(n.li,{children:"Implementing fallback options for resilience"}),"\n",(0,a.jsx)(n.li,{children:"Choosing appropriate map types for your data"}),"\n",(0,a.jsx)(n.li,{children:"Leveraging compression for large maps"}),"\n",(0,a.jsx)(n.li,{children:"Using CDB for high-performance lookups of large datasets"}),"\n",(0,a.jsx)(n.li,{children:"Combining multiple maps with map expressions for complex logic"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>t});var i=s(6540);const a={},r=i.createContext(a);function l(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);