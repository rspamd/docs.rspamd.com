"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[3385],{28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>i});var t=n(96540);const r={},o=t.createContext(r);function a(e){const s=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(o.Provider,{value:s},e.children)}},29439:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"workers/fuzzy_storage","title":"Fuzzy storage worker","description":"Fuzzy storage worker is intended to store fuzzy hashes of messages.","source":"@site/docs/workers/fuzzy_storage.md","sourceDirName":"workers","slug":"/workers/fuzzy_storage","permalink":"/docs.rspamd.com/branches/master/workers/fuzzy_storage","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/workers/fuzzy_storage.md","tags":[],"version":"current","frontMatter":{"title":"Fuzzy storage worker"},"sidebar":"docs","previous":{"title":"Proxy worker","permalink":"/docs.rspamd.com/branches/master/workers/rspamd_proxy"},"next":{"title":"Modules documentation","permalink":"/docs.rspamd.com/branches/master/modules/"}}');var r=n(74848),o=n(28453);const a={title:"Fuzzy storage worker"},i="Fuzzy storage worker",l={},d=[{value:"Protocol format",id:"protocol-format",level:2},{value:"Storage format",id:"storage-format",level:2},{value:"Operation notes",id:"operation-notes",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Compatibility notes",id:"compatibility-notes",level:2}];function c(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"fuzzy-storage-worker",children:"Fuzzy storage worker"})}),"\n",(0,r.jsx)(s.p,{children:"Fuzzy storage worker is intended to store fuzzy hashes of messages."}),"\n",(0,r.jsx)(s.h2,{id:"protocol-format",children:"Protocol format"}),"\n",(0,r.jsxs)(s.p,{children:["Fuzzy storage accepts requests using ",(0,r.jsx)(s.code,{children:"UDP"})," protocol with the following structure:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-C",children:"struct fuzzy_cmd  { /* attribute(packed) */\n\tunit8_t version;        /* command version, must be 0x2 */\n\tunit8_t cmd;            /* numeric command */\n\tunit8_t shingles_count; /* number of shingles */\n\tunit8_t flag;           /* flag number */\n\tint32_t value;          /* value to store */\n\tuint32_t tag;           /* random tag */\n\tchar digest[64];        /* blake2b digest */\n};\n"})}),"\n",(0,r.jsx)(s.p,{children:"All numbers are in host byte order, so if you want to check fuzzy hashes from a\nhost with a different byte order, you need some additional conversions (not currently\nsupported by Rspamd). In the future, Rspamd might use little-endian byte order for all\noperations."}),"\n",(0,r.jsx)(s.p,{children:"Fuzzy storage accepts the following commands:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"FUZZY_CHECK"})," - check for a fuzzy hash"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"FUZZY_ADD"})," - add a new hash"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"FUZZY_DEL"})," - remove a hash"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"flag"})," field is used to store different hashes in a single storage. For example,\nit allows storing blacklists and whitelists in the same fuzzy storage worker.\nA client should set the ",(0,r.jsx)(s.code,{children:"flag"})," field when adding or deleting hashes and check it\nwhen querying for a hash."]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"value"})," is added to the currently stored value of a hash if that hash has been found.\nThis field can handle negative numbers as well."]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"tag"})," is used to distinguish requests by a client. Fuzzy storage just sets this\nfield in the reply equal to the value in the request."]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"digest"})," field contains the content of the hash. Currently, Rspamd uses the ",(0,r.jsx)(s.code,{children:"blake2b"})," hash\nin its binary form, providing ",(0,r.jsx)(s.code,{children:"2^512"})," possible hashes with negligible collision\nprobability. At the same time, Rspamd saves the legacy format of fuzzy hashes by\nmeans of this field. Old Rspamd can work with legacy hashes only."]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"shingles_count"})," defines how many ",(0,r.jsx)(s.code,{children:"shingles"})," are attached to this command.\nCurrently, Rspamd uses 32 shingles, so this value should be set to 32 for commands\nwith shingles. Shingles should be included in the same packet and follow the command as\nan array of int64_t values. Please note that Rspamd rejects commands that have the wrong\nshingle count or if their size is not equal to the desired one:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"sizeof(fuzzy_cmd) + shingles_count * sizeof(int64_t)\n"})}),"\n",(0,r.jsx)(s.p,{children:"The reply format of fuzzy storage is also presented as a structure:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-C",children:"struct fuzzy_cmd  { /* attribute(packed) */\n\tint32_t value;\n\tuint32_t flag;\n\tuint32_t tag;\n\tfloat prob;\n};\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"prob"})," field is used to store the probability of match. This value is changed from\n",(0,r.jsx)(s.code,{children:"0.0"})," (no match) to ",(0,r.jsx)(s.code,{children:"1.0"})," (full match)."]}),"\n",(0,r.jsx)(s.h2,{id:"storage-format",children:"Storage format"}),"\n",(0,r.jsxs)(s.p,{children:["Rspamd's fuzzy storage uses ",(0,r.jsx)(s.code,{children:"sqlite3"})," for storing hashes. All update operations are\nperformed in a transaction, which is committed to the main database approximately once\nper minute. The ",(0,r.jsx)(s.code,{children:"VACUUM"})," command is executed on startup, and hash expiration is performed\nwhen the Rspamd fuzzy storage worker terminates."]}),"\n",(0,r.jsx)(s.p,{children:"Here is the internal database structure:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"CREATE TABLE digests(id INTEGER PRIMARY KEY,\n\tflag INTEGER NOT NULL,\n\tdigest TEXT NOT NULL,\n\tvalue INTEGER,\n\ttime INTEGER);\n\nCREATE TABLE shingles(value INTEGER NOT NULL,\n\tnumber INTEGER NOT NULL,\n\tdigest_id INTEGER REFERENCES digests(id) ON DELETE CASCADE ON UPDATE CASCADE);\n"})}),"\n",(0,r.jsx)(s.p,{children:"Since Rspamd uses normal sqlite3 you can use all tools for working with the hashes\ndatabase to perform, for example backup or analysis."}),"\n",(0,r.jsx)(s.h2,{id:"operation-notes",children:"Operation notes"}),"\n",(0,r.jsxs)(s.p,{children:["To check a hash, Rspamd fuzzy storage initially queries for a direct match using\nthe ",(0,r.jsx)(s.code,{children:"digest"})," field as a key. If that match succeeds, the value is returned immediately.\nOtherwise, if a command contains shingles, then Rspamd checks for a fuzzy match by attempting\nto find the value for each shingle. If more than 50% of the shingles match the same digest,\nRspamd returns that digest's value along with the probability of the match, which generally\nequals ",(0,r.jsx)(s.code,{children:"match_count / shingles_count"}),"."]}),"\n",(0,r.jsx)(s.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(s.p,{children:"Fuzzy storage accepts the following extra options:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"hashfile"})," - path to the sqlite storage (where are also few outdated aliases for this command exist: hash_file, file, database)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"backend"})," - set it to ",(0,r.jsx)(s.code,{children:"redis"})," if you want to use a redis server"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"sync"})," - time to perform database sync in seconds, default value: 60"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"expire"})," - time value for hashes expiration in seconds, default value: 2 days"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"keypair"})," - encryption keypair (can be repeated as list for different keys), can be obtained via ",(0,r.jsx)(s.em,{children:"rspamadm keypair -u"})," command"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"keypair_cache_size"})," - Size of keypairs cache, default value: 512"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"encrypted_only"})," - allow encrypted requests only (and forbid all unknown keys or plaintext requests)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"master_timeout"})," - master protocol IO timeout"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"sync_keypair"})," - encryption key for master/slave updates"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"masters"})," - string, allow master/slave updates from the following IP addresses"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"master_key"})," - allow master/slave updates merely using the specified key"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"slave"})," - list of slave hosts."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"mirror"})," - list of slave hosts, same as ",(0,r.jsx)(s.code,{children:"slave"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"allow_update"})," - string, array of strings or a map of IP addresses that are allowed\nto perform changes to fuzzy storage (you should also set ",(0,r.jsx)(s.code,{children:"read_only = no"})," in your fuzzy_check plugin)."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Here is an example configuration of fuzzy storage:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-hcl",children:'worker "fuzzy" {\n   bind_socket = "*:11335";\n   hashfile = "${DBDIR}/fuzzy.db"\n   expire = 90d;\n   allow_update = ["127.0.0.1", "::1"];\n   keypair = [\n   {\n     pubkey = ...\n     privkey = ...\n   },\n   {\n     pubkey = ...\n     privkey = ...\n   },\n   {\n     pubkey = ...\n     privkey = ...\n   }\n   ]\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"compatibility-notes",children:"Compatibility notes"}),"\n",(0,r.jsxs)(s.p,{children:["Rspamd fuzzy storage version ",(0,r.jsx)(s.code,{children:"0.8"})," is compatible with Rspamd clients of all versions.\nHowever, all updates from legacy versions (less than ",(0,r.jsx)(s.code,{children:"0.8"}),") won't update the fuzzy shingles\ndatabase. The Rspamd ",(0,r.jsx)(s.a,{href:"/modules/fuzzy_check",children:"fuzzy check module"})," can work ",(0,r.jsx)(s.strong,{children:"only"}),"\nwith the recent Rspamd fuzzy storage and won't retrieve anything from the legacy storages."]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);