"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[1686],{28453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>l});var i=n(96540);const a={},r=i.createContext(a);function t(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(r.Provider,{value:s},e.children)}},87502:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"configuration/statistic","title":"Statistics settings","description":"Introduction","source":"@site/docs/configuration/statistic.md","sourceDirName":"configuration","slug":"/configuration/statistic","permalink":"/docs.rspamd.com/branches/master/configuration/statistic","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/configuration/statistic.md","tags":[],"version":"current","frontMatter":{"title":"Statistics settings"},"sidebar":"docs","previous":{"title":"Selectors","permalink":"/docs.rspamd.com/branches/master/configuration/selectors"},"next":{"title":"Redis configuration","permalink":"/docs.rspamd.com/branches/master/configuration/redis"}}');var a=n(74848),r=n(28453);const t={title:"Statistics settings"},l="Rspamd statistic settings",c={},o=[{value:"Introduction",id:"introduction",level:2},{value:"Statistics Architecture",id:"statistics-architecture",level:2},{value:"Statistics Configuration",id:"statistics-configuration",level:2},{value:"Autolearn configuration reference (3.14+)",id:"autolearn-configuration-reference-314",level:3},{value:"Multi-class Bayes (3.13+)",id:"multi-class-bayes-313",level:2},{value:"Configuration model and incompatibilities",id:"configuration-model-and-incompatibilities",level:3},{value:"Recommended layout: two separate classifiers",id:"recommended-layout-two-separate-classifiers",level:3},{value:"Learning",id:"learning",level:3},{value:"Backwards compatibility (existing Bayes database)",id:"backwards-compatibility-existing-bayes-database",level:3},{value:"Classifier and headers",id:"classifier-and-headers",level:3},{value:"Redis statistics",id:"redis-statistics",level:2},{value:"Required parameters",id:"required-parameters",level:3},{value:"Optional parameters",id:"optional-parameters",level:3},{value:"Autolearning",id:"autolearning",level:2},{value:"Extending the helper in Lua (3.14+)",id:"extending-the-helper-in-lua-314",level:3},{value:"Per-user statistics",id:"per-user-statistics",level:3},{value:"Sharding",id:"sharding",level:4}];function d(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"rspamd-statistic-settings",children:"Rspamd statistic settings"})}),"\n",(0,a.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(s.p,{children:["Rspamd utilizes statistics to determine the classification of messages into either spam or ham categories. This classification process is based on the Bayesian theorem, which combines probabilities to assess the likelihood of a message belonging to a particular class, such as ",(0,a.jsx)(s.code,{children:"spam"})," or ",(0,a.jsx)(s.code,{children:"ham"}),". The following factors play a role in determining this probability:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"the probability of a specific token to be spam or ham (which means efficiently count of a token's occurrences in spam and ham messages)"}),"\n",(0,a.jsx)(s.li,{children:"the probability of a specific token to appear in a message (which efficiently means frequency of a token divided by a number of tokens in a message)"}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"statistics-architecture",children:"Statistics Architecture"}),"\n",(0,a.jsx)(s.p,{children:"However, Rspamd employs more advanced techniques to combine probabilities, including sparsed bigrams (OSB) and the inverse chi-square distribution."}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"OSB"})," algorithm goes beyond considering single words as tokens and instead takes into account combinations of words, taking into consideration their positions. This schema is visually represented in the following diagram:"]}),"\n",(0,a.jsx)(s.img,{className:"img-fluid",width:"50%",src:"/img/rspamd-schemes.004.png"}),"\n",(0,a.jsxs)(s.p,{children:["The main drawback of this approach is the increased number of tokens, which is multiplied by the size of the window. In Rspamd, we use a window size of 5 tokens, resulting in the number of tokens being approximately ",(0,a.jsx)(s.strong,{children:"5 times larger"})," than the number of words."]}),"\n",(0,a.jsx)(s.p,{children:"Statistical tokens are stored in statfiles, which are then mapped to specific backends. This architecture is visually represented in the following diagram:"}),"\n",(0,a.jsx)(s.img,{className:"img-fluid",width:"50%",src:"/img/rspamd-schemes.005.png"}),"\n",(0,a.jsx)(s.h2,{id:"statistics-configuration",children:"Statistics Configuration"}),"\n",(0,a.jsxs)(s.p,{children:["Starting from Rspamd 2.0, we recommend using ",(0,a.jsx)(s.code,{children:"redis"})," as the backend and ",(0,a.jsx)(s.code,{children:"osb"})," as the tokenizer, which are set as the default settings."]}),"\n",(0,a.jsxs)(s.p,{children:["The default configuration settings can be found in the ",(0,a.jsx)(s.code,{children:"$CONFDIR/statistic.conf"})," file."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-hcl",children:'classifier "bayes" {\n  # name = "custom";  # \'name\' parameter must be set if multiple classifiers are defined\n  tokenizer {\n    name = "osb";\n  }\n  cache {\n  }\n  new_schema = true; # Always use new schema\n  store_tokens = false; # Redefine if storing of tokens is desired\n  signatures = false; # Store learn signatures\n  #per_user = true; # Enable per user classifier\n  min_tokens = 11;\n  backend = "redis";\n  min_learns = 200;\n\n  statfile {\n    symbol = "BAYES_HAM";\n    spam = false;\n  }\n  statfile {\n    symbol = "BAYES_SPAM";\n    spam = true;\n  }\n  # Reuse the shared Bayes helper introduced in 3.14+\n  learn_condition = "return require(\'lua_bayes_learn\').can_learn";\n\n  # Autolearn sample\n  # autolearn {\n  #  spam_threshold = 6.0; # Learn spam when score >= threshold (3.14+)\n  #  junk_threshold = 4.0; # Learn spam from junk verdicts (3.14+)\n  #  ham_threshold = -0.5; # Learn ham when score <= threshold\n  #  check_balance = true; # Keep spam/ham learns roughly balanced\n  #  min_balance = 0.9; # Allow at most 1/min_balance ratio difference\n  #  options { # Optional fine grained overrides merged into defaults (3.14+)\n  #    probability_check {\n  #      spam_min = 0.9; # Treat P>=0.9 as already spam\n  #      ham_max = 0.1; # Treat P<=0.1 as already ham\n  #    }\n  #    logging { enabled = true; } # Disable if quieter logs are required\n  #  }\n  #}\n\n  .include(try=true; priority=1) "$LOCAL_CONFDIR/local.d/classifier-bayes.conf"\n  .include(try=true; priority=10) "$LOCAL_CONFDIR/override.d/classifier-bayes.conf"\n}\n\n.include(try=true; priority=1) "$LOCAL_CONFDIR/local.d/statistic.conf"\n.include(try=true; priority=10) "$LOCAL_CONFDIR/override.d/statistic.conf"\n'})}),"\n",(0,a.jsx)(s.h3,{id:"autolearn-configuration-reference-314",children:"Autolearn configuration reference (3.14+)"}),"\n",(0,a.jsxs)(s.p,{children:["Rspamd 3.14 refreshes the shared Bayes helper (",(0,a.jsx)(s.code,{children:"lua_bayes_learn"}),") so that automatic learning can be adjusted from configuration files.  The ",(0,a.jsx)(s.code,{children:"autolearn {}"})," block accepts the following keys:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:(0,a.jsx)(s.code,{children:"spam_threshold"})})," ",(0,a.jsx)(s.em,{children:"(float, optional)"})," \u2013 learn spam when a message score is greater than or equal to this value."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:(0,a.jsx)(s.code,{children:"junk_threshold"})})," ",(0,a.jsx)(s.em,{children:"(float, optional, 3.14+)"})," \u2013 treat verdict ",(0,a.jsx)(s.code,{children:"junk"})," as spam if the score is above this value. Leave unset to ignore junk."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:(0,a.jsx)(s.code,{children:"ham_threshold"})})," ",(0,a.jsx)(s.em,{children:"(float, optional)"})," \u2013 learn ham when the score is less than or equal to this value."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:(0,a.jsx)(s.code,{children:"check_balance"})})," ",(0,a.jsxs)(s.em,{children:["(boolean, default ",(0,a.jsx)(s.code,{children:"true"}),")"]})," \u2013 enable the balance guard that prevents one class from overwhelming the other."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:(0,a.jsx)(s.code,{children:"min_balance"})})," ",(0,a.jsxs)(s.em,{children:["(float, default ",(0,a.jsx)(s.code,{children:"0.9"}),")"]})," \u2013 minimum acceptable ratio between ham and spam learns. With the default value Rspamd skips learning when one side grows ~11\u202f% larger (",(0,a.jsx)(s.code,{children:"1 / 0.9"}),")."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:(0,a.jsx)(s.code,{children:"options { ... }"})})," ",(0,a.jsx)(s.em,{children:"(table, 3.14+)"})," \u2013 advanced overrides that are merged with the helper defaults. Common fields include:\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"probability_check { spam_min = 0.95; ham_max = 0.05; }"})," to adjust the \u201calready in class\u201d guard."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"logging { enabled = false; }"})," to silence the informational autolearn log line."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"balance { enabled = false; }"})," to disable the balance guard entirely."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["Example (",(0,a.jsx)(s.code,{children:"local.d/classifier-bayes.conf"}),"):"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-hcl",children:"autolearn {\n  spam_threshold = 6.0;\n  junk_threshold = 4.0;\n  ham_threshold = -0.5;\n  check_balance = true;\n  min_balance = 0.9;\n  options {\n    probability_check {\n      spam_min = 0.92;\n      ham_max = 0.08;\n    }\n    logging { enabled = false; }\n  }\n}\n"})}),"\n",(0,a.jsxs)(s.p,{children:["You are also recommended to use the ",(0,a.jsxs)(s.a,{href:"/modules/bayes_expiry",children:[(0,a.jsx)(s.code,{children:"bayes_expiry"})," module"]})," to maintain your statistics database."]}),"\n",(0,a.jsxs)(s.p,{children:["Please note that ",(0,a.jsx)(s.code,{children:"statistic.conf"})," includes the configuration from ",(0,a.jsx)(s.code,{children:"classifier-bayes.conf"})," for your convenience."]}),"\n",(0,a.jsxs)(s.p,{children:["In most setups (where a single classifier is used) you can tune the bayes classifier in ",(0,a.jsx)(s.code,{children:"local.d/classifier-bayes.conf"}),", and ",(0,a.jsx)(s.code,{children:"statistic.conf"})," can remain unmodified."]}),"\n",(0,a.jsxs)(s.p,{children:["However, if you need to define multiple classifiers, you should create a ",(0,a.jsx)(s.code,{children:"local.d/statistic.conf"})," file. There you must describe each classifier section explicitly: each classifier ",(0,a.jsx)(s.strong,{children:"must"})," have its own ",(0,a.jsx)(s.code,{children:"name"})," and define ",(0,a.jsx)(s.strong,{children:"all options"})," of the default configuration as no fallback will be applied. A common use case for this setup is when one classifier is configured as ",(0,a.jsx)(s.code,{children:"per_user"})," and another is not."]}),"\n",(0,a.jsx)(s.h2,{id:"multi-class-bayes-313",children:"Multi-class Bayes (3.13+)"}),"\n",(0,a.jsx)(s.p,{children:"Starting with Rspamd 3.13, the Bayes classifier supports multiple classes (e.g. newsletters, transactional, phishing) in addition to the classic binary spam/ham. For production setups we strongly recommend keeping spam/ham as a separate classifier and adding another classifier for non-binary classes. This preserves clear decision making for actions (reject, add header, etc.) while allowing additional categorisation."}),"\n",(0,a.jsx)(s.h3,{id:"configuration-model-and-incompatibilities",children:"Configuration model and incompatibilities"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["In a multi-class classifier every ",(0,a.jsx)(s.code,{children:"statfile"})," must define ",(0,a.jsx)(s.code,{children:'class = "<name>"'}),"."]}),"\n",(0,a.jsxs)(s.li,{children:["Do not mix ",(0,a.jsx)(s.code,{children:"spam = true/false"})," with ",(0,a.jsx)(s.code,{children:'class = "..."'})," in the same classifier."]}),"\n",(0,a.jsxs)(s.li,{children:["A multi-class classifier must have at least two classes (two or more ",(0,a.jsx)(s.code,{children:"statfile"})," sections with distinct ",(0,a.jsx)(s.code,{children:"class"}),")."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"min_learns"})," (if set) is applied per class."]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"recommended-layout-two-separate-classifiers",children:"Recommended layout: two separate classifiers"}),"\n",(0,a.jsxs)(s.p,{children:["Create two classifiers in ",(0,a.jsx)(s.code,{children:"local.d/statistic.conf"}),": one strictly binary (spam/ham), and a second one for other classes."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-hcl",children:'# local.d/statistic.conf\n\n# 1) Binary classifier: spam/ham only (reuses existing data if you already have it)\nclassifier "bayes" {\n  name = "bayes_binary";\n  tokenizer { name = "osb"; }\n  backend = "redis";\n  min_tokens = 11;\n  min_learns = 200;\n\n  statfile { symbol = "BAYES_HAM"; spam = false; }\n  statfile { symbol = "BAYES_SPAM"; spam = true; }\n\n  learn_condition = \'return require("lua_bayes_learn").can_learn\';\n}\n\n# 2) Multi-class classifier: additional categories (builds its own data)\nclassifier "bayes" {\n  name = "bayes_multi";\n  tokenizer { name = "osb"; }\n  backend = "redis";\n  min_tokens = 11;\n  min_learns = 200;\n\n  # Define non-binary classes\n  statfile { symbol = "BAYES_NEWSLETTER"; class = "newsletter"; }\n  statfile { symbol = "BAYES_TRANSACTIONAL"; class = "transactional"; }\n  statfile { symbol = "BAYES_PHISHING"; class = "phishing"; }\n\n  # Optional:\n  # per_user = true;  # enable per-user multi-class stats if desired\n\n  learn_condition = \'return require("lua_bayes_learn").can_learn\';\n}\n'})}),"\n",(0,a.jsx)(s.h3,{id:"learning",children:"Learning"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Binary classifier (unchanged):"}),"\n"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"rspamc learn_spam message.eml\nrspamc learn_ham message.eml\n"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Multi-class classifier (new command format):"}),"\n"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"rspamc learn_class:newsletter newsletter.eml\nrspamc learn_class:transactional order_confirmation.eml\n"})}),"\n",(0,a.jsx)(s.h3,{id:"backwards-compatibility-existing-bayes-database",children:"Backwards compatibility (existing Bayes database)"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"If you already have Bayes data for spam/ham in Redis, keep your existing binary classifier section intact (same symbols, same backend parameters). No relearning is needed for spam/ham."}),"\n",(0,a.jsxs)(s.li,{children:["Add the new ",(0,a.jsx)(s.code,{children:"bayes_multi"})," classifier alongside it as shown above. It will build its own database independently from the binary classifier."]}),"\n",(0,a.jsx)(s.li,{children:"Avoid changing symbol names or backend addressing for the binary classifier to ensure it continues using the old database."}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"See the Migration notes for 3.13.0 for a concise upgrade checklist."}),"\n",(0,a.jsx)(s.h3,{id:"classifier-and-headers",children:"Classifier and headers"}),"\n",(0,a.jsxs)(s.p,{children:["The classifier in Rspamd learns headers that are specifically defined in the ",(0,a.jsx)(s.code,{children:"classify_headers"})," section of the ",(0,a.jsx)(s.code,{children:"options.inc "}),"file. Therefore, there is no need to remove any additional headers (e.g., X-Spam) before the learning process, as these headers will not be utilized for classification purposes. Rspamd also takes into account the ",(0,a.jsx)(s.code,{children:"Subject"})," header, which is tokenized according to the aforementioned rules. Additionally, Rspamd considers various meta-tokens, such as message size or the number of attachments, which are extracted from the messages for further analysis."]}),"\n",(0,a.jsx)(s.h2,{id:"redis-statistics",children:"Redis statistics"}),"\n",(0,a.jsx)(s.p,{children:"Supported parameters for the Redis backend are:"}),"\n",(0,a.jsx)(s.h3,{id:"required-parameters",children:"Required parameters"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"name"}),": Unique name of the classifier. Must be set when multiple classifiers are defined; otherwise, optional."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"tokenizer"}),": Currently, only OSB is supported. Must be set as shown in the default configuration."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"new_schema"}),": Must be set to ",(0,a.jsx)(s.code,{children:"true"}),"."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"backend"}),": Must be set to ",(0,a.jsx)(s.code,{children:'"redis"'}),"."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"learn_condition"}),": Lua function that verifies that learning is needed. The default function ",(0,a.jsx)(s.strong,{children:"must"})," be set if you have not written your own. Omitting ",(0,a.jsx)(s.code,{children:"learn_condition"})," from ",(0,a.jsx)(s.code,{children:"statistic.conf"})," will lead to losing protection from overlearning."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"servers"}),": IP or hostname with a port for the Redis server. Use an IP for the loopback interface if you have defined localhost in /etc/hosts for IPv4 and IPv6, or your Redis server will not be found!"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"min_tokens"}),": Minimum number of words required for statistics processing."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"statfile"}),": Defines keys for spam and ham mails."]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"optional-parameters",children:"Optional parameters"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"write_servers"}),": For write-only Redis servers (usually masters)."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"read_servers"}),": For read-only Redis servers (usually replicas)."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"password"}),": Password for the Redis server."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"db"}),": Database to use, ",(0,a.jsx)(s.strong,{children:"must be a non-negative integer"})," (though it is recommended to use dedicated Redis instances and not databases in Redis)."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"min_learns"}),": Minimum learn to count for ",(0,a.jsx)(s.strong,{children:"both"})," spam and ham classes to perform classification."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:(0,a.jsx)(s.code,{children:"autolearn {}"})}),": This section defines the behavior of automatic learning for spam and ham messages based on specific thresholds and balance settings. It includes the following options:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"spam_threshold"})," (No default value): Specifies the score threshold above which a message is considered spam and is eligible for automatic spam learning. If a message\u2019s score exceeds this threshold, it will be learned as spam. If not set, autolearning for spam will depend on the verdict of the message."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"ham_threshold"})," (No default value): Specifies the score threshold below which a message is considered ham and is eligible for automatic ham learning. If a message\u2019s score is below this threshold, it will be learned as ham. If not set, autolearning for ham will depend on the verdict of the message."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"check_balance"})," (Default: ",(0,a.jsx)(s.code,{children:"true"}),"): Enables checking of the balance between spam and ham learns. If the balance is too skewed, learning will be skipped based on the ratio defined by ",(0,a.jsx)(s.code,{children:"min_balance"}),"."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"min_balance"})," (Default: ",(0,a.jsx)(s.code,{children:"0.9"}),"): Ensures balance between spam and ham learns. If the ratio of spam learns to ham learns (or vice versa) exceeds ",(0,a.jsx)(s.code,{children:"1 / min_balance"}),", learning for the more frequent type is skipped until the other type catches up. For example, with the default value of ",(0,a.jsx)(s.code,{children:"0.9"}),", learning is skipped if one type exceeds the other by a ratio of approximately ",(0,a.jsx)(s.code,{children:"1.11"})," (1/0.9). This helps prevent bias in the learning process."]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["For further details, see the ",(0,a.jsx)(s.a,{href:"#autolearning",children:"Autolearning section"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"per_user"}),": For more details, see the Per-user statistics section."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"cache_prefix"}),": Prefix used to create keys where to store hashes of already learned IDs, defaults to ",(0,a.jsx)(s.code,{children:'"learned_ids"'}),"."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"cache_max_elt"}),": Amount of elements to store in one ",(0,a.jsx)(s.code,{children:"learned_ids"})," key."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"cache_max_keys"}),": Amount of ",(0,a.jsx)(s.code,{children:"learned_ids"})," keys to store."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"cache_elt_len"}),": Length of hash to store in one element of ",(0,a.jsx)(s.code,{children:"learned_ids"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"autolearning",children:"Autolearning"}),"\n",(0,a.jsxs)(s.p,{children:["Starting from version 1.1, Rspamd introduces autolearning functionality for statfiles. Autolearning occurs after all rules, including statistics, have been processed. However, it only applies if the same symbol has not already been added. For example, if ",(0,a.jsx)(s.code,{children:"BAYES_SPAM"})," is already present in the checking results, the message will not be learned as spam."]}),"\n",(0,a.jsxs)(s.p,{children:["In Rspamd ",(0,a.jsx)(s.strong,{children:"3.14 and newer"})," we recommend configuring autolearning via the dedicated ",(0,a.jsx)(s.code,{children:"autolearn {}"})," block (see ",(0,a.jsx)(s.a,{href:"#autolearn-configuration-reference-314",children:"Autolearn configuration reference"}),").  For legacy configurations, or when you need full control from Lua, you can still use the classic forms supported by older releases:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"autolearn = true"}),": learn spam if the final action is ",(0,a.jsx)(s.code,{children:"reject"}),", learn ham if the score is negative."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"autolearn = [-5, 5]"}),": learn ham when the score is below ",(0,a.jsx)(s.code,{children:"-5"}),", learn spam when the score is above ",(0,a.jsx)(s.code,{children:"5"}),"."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:'autolearn = "return function(task) ... end"'}),": provide a Lua function that returns ",(0,a.jsx)(s.code,{children:"'ham'"})," or ",(0,a.jsx)(s.code,{children:"'spam'"})," when learning should happen. Any other return value (including ",(0,a.jsx)(s.code,{children:"nil"}),") cancels learning."]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"Redis backend is highly recommended for autolearning purposes due to its ability to handle high concurrency levels when multiple writers are synchronized properly. Using Redis as the backend ensures efficient and reliable autolearning functionality."}),"\n",(0,a.jsx)(s.h3,{id:"extending-the-helper-in-lua-314",children:"Extending the helper in Lua (3.14+)"}),"\n",(0,a.jsxs)(s.p,{children:["The shared helper ",(0,a.jsx)(s.code,{children:"lua_bayes_learn"})," exposes hook points that let you add site-specific logic without copying the whole module.  Guards fire for ",(0,a.jsx)(s.strong,{children:"every"})," learn attempt (manual or automatic) and can veto or allow learning."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-lua",children:'-- local.d/lua/bayes_overrides.lua\nlocal lua_bayes_learn = require "lua_bayes_learn"\n\n-- Globally tighten the probability guard\nlua_bayes_learn.configure_can_learn({\n  probability_check = {\n    spam_min = 0.97,\n    ham_max = 0.03,\n  },\n})\n\n-- Skip autolearn for messages larger than 2 MiB\nlua_bayes_learn.register_autolearn_guard("skip_large_messages", function(ctx)\n  local size = ctx.task:get_size()\n  if size > 2 * 1024 * 1024 then\n    return {\n      ok = false,\n      reason = string.format("message too large for autolearn (%d bytes)", size),\n    }\n  end\n  return true\nend)\n\n-- Prevent learning for specific QA mailboxes\nlua_bayes_learn.register_can_learn_guard("qa_opt_out", function(ctx)\n  local rcpt = ctx.task:get_recipients(\'smtp\')\n  if rcpt and rcpt[1] and rcpt[1].user == \'qa@example.com\' then\n    return { ok = false, reason = \'learning disabled for QA inbox\' }\n  end\n  return true\nend)\n'})}),"\n",(0,a.jsxs)(s.p,{children:["Each guard receives a context table with the ",(0,a.jsx)(s.code,{children:"task"}),", the computed options, and a mutable ",(0,a.jsx)(s.code,{children:"result"}),".  Return ",(0,a.jsx)(s.code,{children:"true"})," to continue, or ",(0,a.jsx)(s.code,{children:"{ ok = false, reason = '...' }"})," to block learning with a human-readable explanation.  Adding ",(0,a.jsx)(s.code,{children:"stop = true"})," lets a guard short-circuit the remaining checks when a decision is final."]}),"\n",(0,a.jsx)(s.h3,{id:"per-user-statistics",children:"Per-user statistics"}),"\n",(0,a.jsxs)(s.p,{children:["To enable per-user statistics, you can add the ",(0,a.jsx)(s.code,{children:"per_user = true"})," property to the configuration of the classifier. However, it is ",(0,a.jsx)(s.em,{children:"important"})," to ensure that Rspamd is called at the final delivery stage (e.g., LDA mode) to avoid issues with multi-recipient messages. When dealing with multi-recipient messages, Rspamd will use the first recipient for user-based statistics."]}),"\n",(0,a.jsxs)(s.p,{children:["Rspamd prioritizes SMTP recipients over MIME ones and gives preference to the special LDA header called ",(0,a.jsx)(s.code,{children:"Delivered-To"}),", which can be appended using the ",(0,a.jsx)(s.code,{children:"-d"})," option for ",(0,a.jsx)(s.code,{children:"rspamc"}),". This allows for more accurate per-user statistics in your configuration."]}),"\n",(0,a.jsxs)(s.p,{children:["You can change per-user statistics to per-domain (or any other) by utilizing a Lua function. The function should return the user as a string or ",(0,a.jsx)(s.code,{children:"nil"})," as a fallback. For example:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-lua",children:"per_user = <<EOD\nreturn function(task)\n  local rcpt = task:get_recipients('any')\n  if rcpt then\n    local first_rcpt = rcpt[1]\n    if first_rcpt['domain'] then\n      return first_rcpt['domain']\n    end\n  end\n  return nil\nend\nEOD\n"})}),"\n",(0,a.jsx)(s.h4,{id:"sharding",children:"Sharding"}),"\n",(0,a.jsxs)(s.p,{children:["Starting from version 3.9, per-user statistics can be sharded across different Redis servers using the ",(0,a.jsx)(s.a,{href:"/configuration/upstream#hash-algorithm",children:"hash algorithm"}),"."]}),"\n",(0,a.jsx)(s.p,{children:"Example of using two stand-alone master shards without read replicas:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-hcl",children:'servers = "hash:bayes-peruser-0-master,bayes-peruser-1-master";\n'})}),"\n",(0,a.jsx)(s.p,{children:"Example of using a setup with three master-replica shards:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-hcl",children:'write_servers = "hash:bayes-peruser-0-master,bayes-peruser-1-master,bayes-peruser-2-master";\nread_servers = "hash:bayes-peruser-0-replica,bayes-peruser-1-replica,bayes-peruser-2-replica";\n'})}),"\n",(0,a.jsx)(s.p,{children:"Important notes:"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsx)(s.li,{children:"Changing the shard count requires dropping all Bayes statistics, so please make decisions wisely."}),"\n",(0,a.jsxs)(s.li,{children:["Each replica should have the same position in ",(0,a.jsx)(s.code,{children:"read_servers"})," as its master in ",(0,a.jsx)(s.code,{children:"write_servers"}),"; otherwise, this will result in misaligned read-write hash slot assignments."]}),"\n",(0,a.jsx)(s.li,{children:"You can't use more than one replica per master in a sharded setup; this will result in misaligned read-write hash slot assignments."}),"\n",(0,a.jsx)(s.li,{children:"Redis Sentinel cannot be used for a sharded setup."}),"\n",(0,a.jsxs)(s.li,{children:["In the controller, you will see incorrect ",(0,a.jsx)(s.code,{children:"Bayesian statistics"})," for the count of learns and users."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);