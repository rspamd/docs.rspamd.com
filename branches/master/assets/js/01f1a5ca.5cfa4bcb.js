"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[5443],{4698(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>a,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"configuration/composites","title":"Composite symbols","description":"Composites combine multiple rules into more complex conditions. When a composite matches, it can add its own symbol and optionally remove the triggering symbols and/or their weights.","source":"@site/docs/configuration/composites.md","sourceDirName":"configuration","slug":"/configuration/composites","permalink":"/docs.rspamd.com/branches/master/configuration/composites","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/configuration/composites.md","tags":[],"version":"current","frontMatter":{"title":"Composite symbols"},"sidebar":"docs","previous":{"title":"Common options","permalink":"/docs.rspamd.com/branches/master/configuration/options"},"next":{"title":"Rspamd maps","permalink":"/docs.rspamd.com/branches/master/configuration/maps"}}');var r=s(4848),l=s(8453);const o={title:"Composite symbols"},t="Rspamd Composite Symbols",d={},c=[{value:"Quick Reference",id:"quick-reference",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Composite Properties",id:"composite-properties",level:3},{value:"Execution Architecture",id:"execution-architecture",level:2},{value:"Task Processing Stages",id:"task-processing-stages",level:3},{value:"Two-Pass Evaluation",id:"two-pass-evaluation",level:3},{value:"Symbol Removal Timing",id:"symbol-removal-timing",level:3},{value:"Inverted Index Optimization",id:"inverted-index-optimization",level:3},{value:"Expression Syntax",id:"expression-syntax",level:2},{value:"Boolean Operators",id:"boolean-operators",level:3},{value:"Composites Referencing Composites",id:"composites-referencing-composites",level:3},{value:"Symbol Removal Policies",id:"symbol-removal-policies",level:2},{value:"Prefix Modifiers",id:"prefix-modifiers",level:3},{value:"How Removal Works",id:"how-removal-works",level:3},{value:"Conflict Resolution",id:"conflict-resolution",level:3},{value:"Policy Setting",id:"policy-setting",level:3},{value:"Weight Calculation Examples",id:"weight-calculation-examples",level:3},{value:"Symbol Groups",id:"symbol-groups",level:2},{value:"Symbol Options",id:"symbol-options",level:2},{value:"Option Matching",id:"option-matching",level:3},{value:"Whitelist Composites",id:"whitelist-composites",level:2},{value:"Disabling Composites",id:"disabling-composites",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Combine Related Signals",id:"combine-related-signals",level:3},{value:"Whitelist Exception",id:"whitelist-exception",level:3},{value:"Escalate When Multiple Signals",id:"escalate-when-multiple-signals",level:3},{value:"Remove Noise, Keep Score",id:"remove-noise-keep-score",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Composite Not Firing",id:"composite-not-firing",level:3},{value:"Unexpected Symbol Removal",id:"unexpected-symbol-removal",level:3},{value:"Debugging",id:"debugging",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"rspamd-composite-symbols",children:"Rspamd Composite Symbols"})}),"\n",(0,r.jsx)(n.p,{children:"Composites combine multiple rules into more complex conditions. When a composite matches, it can add its own symbol and optionally remove the triggering symbols and/or their weights."}),"\n",(0,r.jsx)(n.h2,{id:"quick-reference",children:"Quick Reference"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"Syntax"}),(0,r.jsx)(n.th,{children:"Effect"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Default removal"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"SYMBOL"})}),(0,r.jsx)(n.td,{children:"Remove symbol and weight"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Keep weight"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"~SYMBOL"})}),(0,r.jsx)(n.td,{children:"Remove symbol, keep weight"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Keep both"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"-SYMBOL"})}),(0,r.jsx)(n.td,{children:"Keep symbol and weight"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Force remove"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"^SYMBOL"})}),(0,r.jsxs)(n.td,{children:["Force remove (overrides ",(0,r.jsx)(n.code,{children:"-"}),")"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Symbol options"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"SYMBOL[opt1,opt2]"})}),(0,r.jsx)(n.td,{children:"Match only with specific options"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Group match"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g:groupname"})}),(0,r.jsx)(n.td,{children:"Match any symbol from group"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Positive group"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g+:groupname"})}),(0,r.jsx)(n.td,{children:"Match positive-scoring symbols"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Negative group"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g-:groupname"})}),(0,r.jsx)(n.td,{children:"Match negative-scoring symbols"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Define composites in ",(0,r.jsx)(n.code,{children:"local.d/composites.conf"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'TEST_COMPOSITE {\n    expression = "SYMBOL1 and SYMBOL2";\n    score = 5.0;\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When both ",(0,r.jsx)(n.code,{children:"SYMBOL1"})," and ",(0,r.jsx)(n.code,{children:"SYMBOL2"})," match, they are replaced by ",(0,r.jsx)(n.code,{children:"TEST_COMPOSITE"})," with score 5.0."]}),"\n",(0,r.jsx)(n.h3,{id:"composite-properties",children:"Composite Properties"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Property"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"expression"})}),(0,r.jsx)(n.td,{children:"string"}),(0,r.jsx)(n.td,{children:"Boolean expression defining when composite fires"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"score"})}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Score assigned to the composite symbol"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"group"})}),(0,r.jsx)(n.td,{children:"string"}),(0,r.jsx)(n.td,{children:"Symbol group for the composite"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"policy"})}),(0,r.jsx)(n.td,{children:"string"}),(0,r.jsx)(n.td,{children:"Default removal policy for all atoms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"enabled"})}),(0,r.jsx)(n.td,{children:"boolean"}),(0,r.jsxs)(n.td,{children:["Set to ",(0,r.jsx)(n.code,{children:"false"})," to disable"]})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"execution-architecture",children:"Execution Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Understanding how composites execute is essential for writing correct rules, especially when composites depend on each other or on symbols from different processing stages."}),"\n",(0,r.jsx)(n.h3,{id:"task-processing-stages",children:"Task Processing Stages"}),"\n",(0,r.jsx)(n.p,{children:"Rspamd processes messages through ordered stages. Composites execute at two specific points:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"PREFILTERS \u2192 FILTERS \u2192 CLASSIFIERS \u2192 COMPOSITES \u2192 POST_FILTERS \u2192 COMPOSITES_POST \u2192 IDEMPOTENT\n                                          \u2191                              \u2191\n                                     First pass                    Second pass\n"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Stage"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"FILTERS"}),(0,r.jsx)(n.td,{children:"Regular filter rules execute"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"CLASSIFIERS"}),(0,r.jsx)(n.td,{children:"Bayes classifier runs"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"COMPOSITES"})}),(0,r.jsx)(n.td,{children:"First-pass composites evaluate"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST_FILTERS"}),(0,r.jsx)(n.td,{children:"Post-filter rules execute"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"COMPOSITES_POST"})}),(0,r.jsx)(n.td,{children:"Second-pass composites evaluate"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"IDEMPOTENT"}),(0,r.jsx)(n.td,{children:"Final processing (logging, history)"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"two-pass-evaluation",children:"Two-Pass Evaluation"}),"\n",(0,r.jsx)(n.p,{children:"Rspamd automatically analyzes composite dependencies and assigns each composite to the appropriate pass:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"First pass"})," (COMPOSITES stage):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Composites that only depend on symbols from FILTERS, PREFILTERS, or CLASSIFIERS"}),"\n",(0,r.jsx)(n.li,{children:"The majority of composites execute here"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Second pass"})," (COMPOSITES_POST stage):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Composites that depend on POST_FILTER symbols"}),"\n",(0,r.jsx)(n.li,{children:"Composites that depend on other second-pass composites"}),"\n",(0,r.jsxs)(n.li,{children:["Composites that depend on symbols marked as ",(0,r.jsx)(n.code,{children:"idempotent"})," or ",(0,r.jsx)(n.code,{children:"trivial"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# First pass - only depends on filter symbols\nFIRST_PASS_EXAMPLE {\n    expression = "DKIM_SIGNED & SPF_ALLOW";\n}\n\n# Second pass - depends on post-filter symbol\nSECOND_PASS_EXAMPLE {\n    expression = "FIRST_PASS_EXAMPLE & SOME_POSTFILTER_SYMBOL";\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Rspamd determines pass assignment by analyzing:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Direct dependencies (symbols in the expression)"}),"\n",(0,r.jsx)(n.li,{children:"Transitive dependencies (if atom A depends on composite B, and B is second-pass, then A becomes second-pass)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"symbol-removal-timing",children:"Symbol Removal Timing"}),"\n",(0,r.jsxs)(n.p,{children:["Symbol removal happens ",(0,r.jsx)(n.strong,{children:"after"})," all composites in a pass are evaluated, not during evaluation. This has important implications:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'COMP_A {\n    expression = "SYMBOL1 & SYMBOL2";\n    # Removes SYMBOL1 and SYMBOL2\n}\n\nCOMP_B {\n    expression = "SYMBOL1 & SYMBOL3";\n    # Also sees SYMBOL1 during evaluation (not yet removed)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Both composites evaluate against the original symbol set. Removal decisions are collected and applied afterward."}),"\n",(0,r.jsx)(n.h3,{id:"inverted-index-optimization",children:"Inverted Index Optimization"}),"\n",(0,r.jsx)(n.p,{children:"Rspamd builds an inverted index mapping symbols to composites that use them. When a symbol fires:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Rspamd looks up which composites contain that symbol"}),"\n",(0,r.jsx)(n.li,{children:"Only those composites are evaluated"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Composites with only negated atoms (like ",(0,r.jsx)(n.code,{children:"!SYMBOL1 & !SYMBOL2"}),") are always evaluated since they don't appear in the inverted index."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"expression-syntax",children:"Expression Syntax"}),"\n",(0,r.jsx)(n.h3,{id:"boolean-operators",children:"Boolean Operators"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operator"}),(0,r.jsx)(n.th,{children:"Alternatives"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"AND"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"&"}),", ",(0,r.jsx)(n.code,{children:"and"})]}),(0,r.jsx)(n.td,{children:"Both operands must be true"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"OR"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"|"}),", ",(0,r.jsx)(n.code,{children:"or"})]}),(0,r.jsx)(n.td,{children:"Either operand must be true"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"NOT"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"!"}),", ",(0,r.jsx)(n.code,{children:"not"})]}),(0,r.jsx)(n.td,{children:"Operand must be false"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Use parentheses to control precedence. Without them, operators evaluate left-to-right:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'EXAMPLE {\n    expression = "SYMBOL1 and SYMBOL2 and (not SYMBOL3 | not SYMBOL4)";\n    score = 10.0;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"composites-referencing-composites",children:"Composites Referencing Composites"}),"\n",(0,r.jsx)(n.p,{children:"Composites can include other composites. Definition order doesn't matter:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'PARENT {\n    expression = "SYMBOL1 AND CHILD";\n}\nCHILD {\n    expression = "SYMBOL2 OR NOT SYMBOL3";\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"When a composite references another composite:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If the referenced composite is second-pass, the referencing composite becomes second-pass too"}),"\n",(0,r.jsx)(n.li,{children:"Rspamd detects and prevents recursive definitions"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"symbol-removal-policies",children:"Symbol Removal Policies"}),"\n",(0,r.jsxs)(n.p,{children:["When a composite matches, it can remove the triggering symbols, their weights, or both. This is controlled through prefix modifiers or the ",(0,r.jsx)(n.code,{children:"policy"})," setting."]}),"\n",(0,r.jsx)(n.h3,{id:"prefix-modifiers",children:"Prefix Modifiers"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Prefix"}),(0,r.jsx)(n.th,{children:"Symbol"}),(0,r.jsx)(n.th,{children:"Weight"}),(0,r.jsx)(n.th,{children:"Use Case"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"(none)"}),(0,r.jsx)(n.td,{children:"Removed"}),(0,r.jsx)(n.td,{children:"Removed"}),(0,r.jsx)(n.td,{children:"Replace symbols with composite"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"~"})}),(0,r.jsx)(n.td,{children:"Removed"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Kept"})}),(0,r.jsx)(n.td,{children:"Hide symbol but count its weight"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"-"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Kept"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Kept"})}),(0,r.jsx)(n.td,{children:"Additive scoring"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"^"})}),(0,r.jsx)(n.td,{children:"Removed"}),(0,r.jsx)(n.td,{children:"Removed"}),(0,r.jsxs)(n.td,{children:["Force removal (overrides ",(0,r.jsx)(n.code,{children:"-"}),")"]})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"how-removal-works",children:"How Removal Works"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Each composite collects removal decisions for its atoms"}),"\n",(0,r.jsx)(n.li,{children:"After all composites in a pass evaluate, Rspamd processes the collected decisions"}),"\n",(0,r.jsx)(n.li,{children:"For each symbol, all removal requests are combined using bitwise OR"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The removal decision for each symbol tracks three flags:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remove symbol"}),": Hide the symbol name from output"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remove weight"}),": Subtract the symbol's weight from total score"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forced"}),': Override any "keep" requests']}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"conflict-resolution",children:"Conflict Resolution"}),"\n",(0,r.jsx)(n.p,{children:"When multiple composites reference the same symbol with different modifiers:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Scenario"}),(0,r.jsx)(n.th,{children:"Result"}),(0,r.jsx)(n.th,{children:"Reason"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["One uses default, another uses ",(0,r.jsx)(n.code,{children:"-"})]}),(0,r.jsx)(n.td,{children:"Symbol kept"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"-"})," sets no removal flags, nothing to OR"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["One uses ",(0,r.jsx)(n.code,{children:"~"}),", another uses ",(0,r.jsx)(n.code,{children:"-"})]}),(0,r.jsx)(n.td,{children:"Symbol kept, weight kept"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"-"})," prevents symbol removal"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["One uses ",(0,r.jsx)(n.code,{children:"^"}),", another uses ",(0,r.jsx)(n.code,{children:"-"})]}),(0,r.jsx)(n.td,{children:"Symbol removed"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"^"})," sets forced flag, overrides everything"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Multiple use default"}),(0,r.jsx)(n.td,{children:"Symbol removed"}),(0,r.jsx)(n.td,{children:"Flags combine identically"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# Assume SPAM_INDICATOR exists in scan results\n\nCOMPOSITE_A {\n    expression = "SPAM_INDICATOR & OTHER_SYM";\n    # Default: requests remove_symbol + remove_weight\n}\n\nCOMPOSITE_B {\n    expression = "-SPAM_INDICATOR & DIFFERENT_SYM";\n    # The `-` sets no removal flags for SPAM_INDICATOR\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Result: ",(0,r.jsx)(n.code,{children:"SPAM_INDICATOR"})," is ",(0,r.jsx)(n.strong,{children:"kept"}),'. COMPOSITE_A\'s removal flags (remove_symbol | remove_weight) are ORed with COMPOSITE_B\'s flags (none). But since COMPOSITE_B explicitly requests "leave", Rspamd interprets this as "at least one composite wants it kept" and preserves the symbol.']}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Force removal overrides:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'COMPOSITE_C {\n    expression = "^SPAM_INDICATOR & FORCE_CLEANUP";\n    # The `^` sets forced flag\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Now ",(0,r.jsx)(n.code,{children:"SPAM_INDICATOR"})," is ",(0,r.jsx)(n.strong,{children:"removed"})," despite COMPOSITE_B wanting to keep it, because the forced flag overrides the keep request."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key insight"}),": The ",(0,r.jsx)(n.code,{children:"-"}),' modifier doesn\'t just "not remove" \u2014 it actively protects the symbol from removal by other composites. Use ',(0,r.jsx)(n.code,{children:"^"})," when you need to guarantee removal regardless of other composites."]}),"\n",(0,r.jsx)(n.h3,{id:"policy-setting",children:"Policy Setting"}),"\n",(0,r.jsx)(n.p,{children:"Set a default policy for all atoms in an expression:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'ADDITIVE_COMPOSITE {\n    expression = "SYMBOL1 and SYMBOL2";\n    policy = "leave";  # Both symbols and weights preserved\n}\n'})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Policy"}),(0,r.jsx)(n.th,{children:"Effect"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"default"})}),(0,r.jsx)(n.td,{children:"Remove symbol and weight"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"remove_weight"})}),(0,r.jsx)(n.td,{children:"Remove weight only, keep symbol"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"remove_symbol"})}),(0,r.jsx)(n.td,{children:"Remove symbol only, keep weight"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"leave"})}),(0,r.jsx)(n.td,{children:"Keep both symbol and weight"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Prefix modifiers override the policy for individual symbols."}),"\n",(0,r.jsx)(n.h3,{id:"weight-calculation-examples",children:"Weight Calculation Examples"}),"\n",(0,r.jsxs)(n.p,{children:["Given: ",(0,r.jsx)(n.code,{children:"SYMBOL_A"})," (weight 2.0), ",(0,r.jsx)(n.code,{children:"SYMBOL_B"})," (weight 3.0), composite score 5.0"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Expression"}),(0,r.jsx)(n.th,{children:"Symbols Shown"}),(0,r.jsx)(n.th,{children:"Total Score"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"SYMBOL_A & SYMBOL_B"})}),(0,r.jsx)(n.td,{children:"Composite only"}),(0,r.jsx)(n.td,{children:"5.0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"~SYMBOL_A & SYMBOL_B"})}),(0,r.jsx)(n.td,{children:"Composite only"}),(0,r.jsx)(n.td,{children:"7.0 (2.0 + 5.0)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"-SYMBOL_A & SYMBOL_B"})}),(0,r.jsx)(n.td,{children:"SYMBOL_A + Composite"}),(0,r.jsx)(n.td,{children:"7.0 (2.0 + 5.0)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"-SYMBOL_A & -SYMBOL_B"})}),(0,r.jsx)(n.td,{children:"Both + Composite"}),(0,r.jsx)(n.td,{children:"10.0 (2.0 + 3.0 + 5.0)"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"symbol-groups",children:"Symbol Groups"}),"\n",(0,r.jsx)(n.p,{children:"Match any symbol from a defined group:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Syntax"}),(0,r.jsx)(n.th,{children:"Matches"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g:groupname"})}),(0,r.jsx)(n.td,{children:"Any symbol from the group"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g+:groupname"})}),(0,r.jsx)(n.td,{children:"Symbols with positive score"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g-:groupname"})}),(0,r.jsx)(n.td,{children:"Symbols with negative score"})]})]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'FUZZY_AND_DKIM_FAIL {\n    expression = "g+:fuzzy & !g:dkim";\n    # Matches if any positive fuzzy symbol AND no DKIM symbols\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Removal policies apply only to the matched symbol, not the entire group."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"symbol-options",children:"Symbol Options"}),"\n",(0,r.jsx)(n.p,{children:"Match symbols only when they have specific options (added in 2.0):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'SPECIFIC_DMARC {\n    expression = "DMARC_POLICY_REJECT[sp]";\n    # Only matches if DMARC_POLICY_REJECT has "sp" option\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"option-matching",children:"Option Matching"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Syntax"}),(0,r.jsx)(n.th,{children:"Requirement"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"[opt1]"})}),(0,r.jsxs)(n.td,{children:["Must have ",(0,r.jsx)(n.code,{children:"opt1"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"[opt1,opt2]"})}),(0,r.jsxs)(n.td,{children:["Must have both ",(0,r.jsx)(n.code,{children:"opt1"})," AND ",(0,r.jsx)(n.code,{children:"opt2"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"[/regex/i]"})}),(0,r.jsx)(n.td,{children:"Must have option matching regex"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"[/regex/,opt1]"})}),(0,r.jsxs)(n.td,{children:["Must match regex AND have ",(0,r.jsx)(n.code,{children:"opt1"})]})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"All specified options must be present (AND logic):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'COMBINED_OPTIONS {\n    expression = "SYMBOL[/user@.*/i, authenticated]";\n    # Must have an option matching the regex AND "authenticated"\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"whitelist-composites",children:"Whitelist Composites"}),"\n",(0,r.jsx)(n.p,{children:"Composites with negative scores act as whitelists. Rspamd handles these specially:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'WHITELIST_SENDER {\n    expression = "GOOD_SENDER & DKIM_VALID";\n    score = -10.0;  # Negative score = whitelist\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:'When a composite has negative score, Rspamd marks its atoms as "FINE" symbols. This prevents the spam filtering logic from short-circuiting before these symbols are evaluated, ensuring whitelist composites have a chance to match.'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"disabling-composites",children:"Disabling Composites"}),"\n",(0,r.jsxs)(n.p,{children:["Disable a stock composite in ",(0,r.jsx)(n.code,{children:"local.d/composites.conf"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:"DKIM_MIXED {\n    enabled = false;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can also disable composites via ",(0,r.jsx)(n.a,{href:"/configuration/settings",children:"user settings"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"combine-related-signals",children:"Combine Related Signals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'PHISHING_COMBO {\n    expression = "PHISHING & (SUSPICIOUS_URL | REDIRECTOR_URL)";\n    score = 8.0;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"whitelist-exception",children:"Whitelist Exception"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'TRUSTED_FORWARDER {\n    expression = "-FORGED_SENDER & KNOWN_FORWARDER & DKIM_VALID";\n    score = -5.0;\n    # Keeps FORGED_SENDER visible but reduces overall score\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"escalate-when-multiple-signals",children:"Escalate When Multiple Signals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'HIGH_CONFIDENCE_SPAM {\n    expression = "g+:fuzzy & BAYES_SPAM & (RBL_SPAMHAUS | RBL_BARRACUDA)";\n    score = 15.0;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"remove-noise-keep-score",children:"Remove Noise, Keep Score"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'CONSOLIDATED_RBL {\n    expression = "~RBL_A & ~RBL_B & ~RBL_C";\n    score = 0;  # Weight from individual RBLs is preserved\n    # Hides individual RBL symbols, shows only this composite\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"composite-not-firing",children:"Composite Not Firing"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check symbol availability"}),": Use ",(0,r.jsx)(n.code,{children:"rspamc symbols"})," to see available symbols"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Verify execution stage"}),": If the composite depends on post-filter symbols, it runs in the second pass"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check for typos"}),": Symbol names are case-sensitive"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test expression logic"}),": Simplify the expression to isolate the issue"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"unexpected-symbol-removal",children:"Unexpected Symbol Removal"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check all composites"}),": Search for the symbol across all composite definitions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Look for ",(0,r.jsx)(n.code,{children:"^"})," prefix"]}),": Force removal overrides keep (",(0,r.jsx)(n.code,{children:"-"}),") requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider pass ordering"}),": Second-pass composites see results of first-pass removals"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"debugging",children:"Debugging"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"rspamc"})," to test composites:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Check which composites matched\nrspamc -v < test_message.eml | grep -i composite\n\n# See all symbols including removed ones\nrspamc --header="extended-symbols: 1" < test_message.eml\n'})})]})}function a(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453(e,n,s){s.d(n,{R:()=>o,x:()=>t});var i=s(6540);const r={},l=i.createContext(r);function o(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);