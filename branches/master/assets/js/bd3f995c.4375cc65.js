"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[4612],{6960:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"modules/bayes_expiry","title":"Bayes expiry module","description":"The Bayes expiry module provides intelligent expiration of statistical tokens for the new schema of Redis statistics storage.","source":"@site/docs/modules/bayes_expiry.md","sourceDirName":"modules","slug":"/modules/bayes_expiry","permalink":"/docs.rspamd.com/branches/master/modules/bayes_expiry","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/modules/bayes_expiry.md","tags":[],"version":"current","frontMatter":{"title":"Bayes expiry module"},"sidebar":"docs","previous":{"title":"ASN module","permalink":"/docs.rspamd.com/branches/master/modules/asn"},"next":{"title":"Chartable module","permalink":"/docs.rspamd.com/branches/master/modules/chartable"}}');var t=n(4848),o=n(8453);const r={title:"Bayes expiry module"},a="Bayes expiry module",l={},c=[{value:"Module configuration",id:"module-configuration",level:2},{value:"Principles of operation",id:"principles-of-operation",level:2},{value:"Tokens classification",id:"tokens-classification",level:2},{value:"Expiration modes",id:"expiration-modes",level:2},{value:"Default expiration mode (before 2.0)",id:"default-expiration-mode-before-20",level:3},{value:"Lazy expiration mode (1.7.4+)",id:"lazy-expiration-mode-174",level:3},{value:"Changing expiration mode (before 2.0)",id:"changing-expiration-mode-before-20",level:3},{value:"Changing expire value",id:"changing-expire-value",level:3},{value:"Limiting memory usage to a fixed amount",id:"limiting-memory-usage-to-a-fixed-amount",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"bayes-expiry-module",children:"Bayes expiry module"})}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"Bayes expiry"})," module provides intelligent expiration of statistical tokens for the ",(0,t.jsx)(i.code,{children:"new schema"})," of Redis statistics storage."]}),"\n",(0,t.jsx)(i.h2,{id:"module-configuration",children:"Module configuration"}),"\n",(0,t.jsxs)(i.p,{children:["For the ",(0,t.jsx)(i.code,{children:"bayes expiry"})," module, classifier-related configuration settings should be incorporated into the corresponding ",(0,t.jsx)(i.code,{children:"classifier"})," section, such as the ",(0,t.jsx)(i.code,{children:"local.d/classifier-bayes.conf"})," file. Additionally, as the ",(0,t.jsx)(i.code,{children:"Bayes expiry"})," module necessitates the use of the new statistics schema, it is imperative to enable it within the classifier configuration:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-hcl",children:'new_schema = true;    # Enabled by default for classifier "bayes" in the stock statistic.conf since 2.0\n'})}),"\n",(0,t.jsx)(i.p,{children:"The following settings are valid:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"expire"}),": sets the TTL (time to live) for tokens. Tokens in the ",(0,t.jsx)(i.code,{children:"common"})," category are not affected. For more information, see the ",(0,t.jsx)(i.a,{href:"#expiration-modes",children:"expiration modes"})," for detail. Supported values are:\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"time in seconds (time unit suffixes are supported). The maximum possible TTL value in Redis is 2147483647 (int32);"}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"-1"}),": make tokens persistent;"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"false"}),": disable ",(0,t.jsx)(i.code,{children:"bayes expiry"})," for the classifier. Note that this does not change the TTLs of existing tokens, but new learned tokens will be persistent."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"lazy"})," (before 2.0): ",(0,t.jsx)(i.code,{children:"true"})," - enable lazy expiration mode (disabled by default). See ",(0,t.jsx)(i.a,{href:"#expiration-modes",children:"expiration modes"})," for detail."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Configuration example:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-hcl",children:'new_schema = true;    # Enabled by default for classifier "bayes" in the stock statistic.conf since 2.0\nexpire = 8640000;\n#lazy = true;    # Before 2.0\n'})}),"\n",(0,t.jsxs)(i.p,{children:["To modify the global settings of the ",(0,t.jsx)(i.code,{children:"bayes expiry"})," module, you can configure them in either the ",(0,t.jsx)(i.code,{children:"local.d/bayes_expiry.conf"})," or ",(0,t.jsx)(i.code,{children:"override.d/bayes_expiry.conf"})," file."]}),"\n",(0,t.jsx)(i.p,{children:"The following settings are valid:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"interval"}),": time interval in seconds between each run of the expiry step on the controller. Default is ",(0,t.jsx)(i.code,{children:"60"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"count"}),": the number of keys to check during each expiry step. The module utilizes a cursor-based iterator to ensure that the next step continues from where the previous one stopped. Default is ",(0,t.jsx)(i.code,{children:"1000"}),". Consider increasing it to a higher value if your Redis instance is overwhelmed with too many persistent keys, suggesting faster learning compared to the module's processing."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"epsilon_common"}),": a comparison tolerance used to determine if a token is considered ",(0,t.jsx)(i.code,{children:"common"}),". Tokens with a difference between spam and ham relative frequencies not greater than this value are classified as ",(0,t.jsx)(i.code,{children:"common"}),". Default is ",(0,t.jsx)(i.code,{children:"0.01"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"common_ttl"}),": the initial TTL for ",(0,t.jsx)(i.code,{children:"common"})," tokens. Default is ",(0,t.jsx)(i.code,{children:"10 * 86400"}),", equivalent to 10 days."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"significant_factor"}),": the threshold for token significance. Tokens with a relative frequency greater than this value are considered ",(0,t.jsx)(i.code,{children:"significant"}),"; otherwise, they are ",(0,t.jsx)(i.code,{children:"insignificant"}),". Defaults is ",(0,t.jsx)(i.code,{children:"3.0 / 4.0"}),", which corresponds to 75%."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Configuration example:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-hcl",children:"interval = 90;\ncount = 15000;\n"})}),"\n",(0,t.jsx)(i.h2,{id:"principles-of-operation",children:"Principles of operation"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"bayes expiry"})," module performs an expiry step every minute. During each step, it examines the frequency of approximately 1000 statistical tokens and adjusts their TTLs if needed. The duration of a full iteration varies based on the number of tokens; for example, a full cycle for 10 million tokens takes approximately one week to complete. Once the ",(0,t.jsx)(i.code,{children:"bayes expiry"})," module finishes a full iteration, it starts over again."]}),"\n",(0,t.jsx)(i.h2,{id:"tokens-classification",children:"Tokens classification"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"Bayes expiry"})," module categorizes tokens into four groups based on their frequency of occurrence in ham and spam classes:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"infrequent"}),": occur too infrequently (the total number of occurrences is very low)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"significant"}),": occur significantly more frequently in one class (ham or spam) than in the other one;"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"common"})," (meaningless): occur in both ham and spam classes with approximately the same frequency;"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"insignificant"}),": the difference of their occurrences in classes lies somewhere between ",(0,t.jsx)(i.code,{children:"significant"})," and ",(0,t.jsx)(i.code,{children:"common"})," tokens."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"expiration-modes",children:"Expiration modes"}),"\n",(0,t.jsx)(i.h3,{id:"default-expiration-mode-before-20",children:"Default expiration mode (before 2.0)"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"default"})," mode has been removed in Rspamd 2.0 as it offers no benefits compared to the",(0,t.jsx)(i.code,{children:"lazy"})," mode."]}),"\n",(0,t.jsx)(i.p,{children:"Operation:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Extend a ",(0,t.jsx)(i.code,{children:"significant"})," token's lifetime: update token's TTL every time to ",(0,t.jsx)(i.code,{children:"expire"})," value."]}),"\n",(0,t.jsxs)(i.li,{children:["Do nothing with an ",(0,t.jsx)(i.code,{children:"insignificant"})," or ",(0,t.jsx)(i.code,{children:"infrequent"})," token."]}),"\n",(0,t.jsxs)(i.li,{children:["Discriminate a ",(0,t.jsx)(i.code,{children:"common"})," token: reset TTL to a low value (10d) if the token has greater TTL."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Disadvantages:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Statistics must not be stored offline for longer than the",(0,t.jsx)(i.code,{children:"expire"})," time. The Bayes Expiry module must periodically update their TTLs, which means special backup procedures are required. Simply copying the ",(0,t.jsx)(i.code,{children:"*.rdb"})," file will result in its expiration after the ",(0,t.jsx)(i.code,{children:"expire"})," time has passed."]}),"\n",(0,t.jsxs)(i.li,{children:["If no eviction policy is set in Redis that targets ",(0,t.jsx)(i.code,{children:"significant"})," tokens, constant updating of their TTLs is not necessary."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"lazy-expiration-mode-174",children:"Lazy expiration mode (1.7.4+)"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"lazy"})," mode is the only expiration mode since Rspamd 2.0."]}),"\n",(0,t.jsxs)(i.p,{children:["This mode ensures that ",(0,t.jsx)(i.code,{children:"significant"})," tokens with a TTL are persistently kept (the module sets significant tokens TTLs to -1, i.e. makes them persistent if they are not), while TTL of ",(0,t.jsx)(i.code,{children:"insignificant"})," or ",(0,t.jsx)(i.code,{children:"infrequent"})," tokens is reduced to the ",(0,t.jsx)(i.code,{children:"expire"})," value if its current TTL exceeds ",(0,t.jsx)(i.code,{children:"expire"}),". ",(0,t.jsx)(i.code,{children:"Common"})," tokens are discriminated by resetting their TTL to a lower value of 10 days, if their TTL exceed this threshold."]}),"\n",(0,t.jsx)(i.p,{children:'The advantages of the "lazy" mode include:'}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["The ability to keep statistics offline for an infinite period without the risk of losing ",(0,t.jsx)(i.code,{children:"significant"})," tokens."]}),"\n",(0,t.jsx)(i.li,{children:"Minimizing unnecessary TTL updates as much as possible."}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["To activate the lazy expiration mode in Rspamd versions prior to 2.0, simply add ",(0,t.jsx)(i.code,{children:"lazy = true;"})," to the classifier configuration."]}),"\n",(0,t.jsx)(i.h3,{id:"changing-expiration-mode-before-20",children:"Changing expiration mode (before 2.0)"}),"\n",(0,t.jsx)(i.p,{children:"The expiration mode for an existing statistics database can be altered in the configuration at any moment. Token's TTLs will be updated as required during the subsequent expiration cycle."}),"\n",(0,t.jsx)(i.h3,{id:"changing-expire-value",children:"Changing expire value"}),"\n",(0,t.jsxs)(i.p,{children:["When a new ",(0,t.jsx)(i.code,{children:"expire"})," value is set to a lower value than the current one, the TTLs exceeding the new ",(0,t.jsx)(i.code,{children:"expire"})," value will be updated during the next expiration cycle."]}),"\n",(0,t.jsxs)(i.p,{children:["To increase the ",(0,t.jsx)(i.code,{children:"expire"})," value, it is necessary first to make the tokens persistent by setting ",(0,t.jsx)(i.code,{children:"expire = -1;"})," and waiting until at least one expiration cycle is completed. Only then the new ",(0,t.jsx)(i.code,{children:"expire"})," value can be set."]}),"\n",(0,t.jsx)(i.h2,{id:"limiting-memory-usage-to-a-fixed-amount",children:"Limiting memory usage to a fixed amount"}),"\n",(0,t.jsxs)(i.p,{children:["The memory usage of the statistics dataset can be managed using the Redis ",(0,t.jsx)(i.code,{children:"maxmemory"})," directive and ",(0,t.jsx)(i.code,{children:"volatile-ttl"}),' eviction policy. If the memory usage exceeds the set "maxmemory" limit, Redis will evict keys with shorter TTLs in accordance with the policy. Additionally, memory usage can be maintained at a nearly constant level by setting the TTL to an extremely high value, causing keys to be evicted instead of expiring.']}),"\n",(0,t.jsxs)(i.p,{children:["To ensure that the memory limit and eviction policy only apply to the Bayesian statistics dataset, it should be stored in a separate Redis instance. A comprehensive explanation on configuring multi-instance Redis can be found in the ",(0,t.jsx)(i.a,{href:"/tutorials/redis_replication",children:"Redis replication"})," tutorial."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"local.d/classifier-bayes.conf"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-hcl",children:'backend = "redis";    # Enabled by default for classifier "bayes" in the stock statistic.conf since 2.0 \nservers = "localhost:6378";\n\nnew_schema = true;    # Enabled by default for classifier "bayes" in the stock statistic.conf since 2.0\nexpire = 2144448000;\nlazy = true;    # Before 2.0\n'})}),"\n",(0,t.jsxs)(i.p,{children:["Setting ",(0,t.jsx)(i.code,{children:"expire = 2144448000;"})," sets a very high TTL of 68 years, as there is no need for the actual expiration of keys."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"/usr/local/etc/redis-bayes.conf"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sh",children:"include /usr/local/etc/redis.conf\n\nport 6378\n\npidfile /var/run/redis/bayes.pid\nlogfile /var/log/redis/bayes.log\ndbfilename bayes.rdb\ndir /var/db/redis/bayes/\n\nmaxmemory 500MB\nmaxmemory-policy volatile-ttl\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Where ",(0,t.jsx)(i.code,{children:"maxmemory 500MB"})," sets Redis to use the specified amount of memory for the instance's dataset and ",(0,t.jsx)(i.code,{children:"maxmemory-policy volatile-ttl"})," sets Redis to use the eviction policy when the ",(0,t.jsx)(i.code,{children:"maxmemory"})," limit is reached."]})]})}function h(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>a});var s=n(6540);const t={},o=s.createContext(t);function r(e){const i=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:i},e.children)}}}]);