"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[9593],{67:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"modules/external_relay","title":"External Relay module","description":"This plugin is designed for users who need to conduct scans after the MX has processed a message, such as those who receive mail over POP3 and forward it to a local MTA. Most users can disregard it.","source":"@site/docs/modules/external_relay.md","sourceDirName":"modules","slug":"/modules/external_relay","permalink":"/docs.rspamd.com/branches/master/modules/external_relay","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/modules/external_relay.md","tags":[],"version":"current","frontMatter":{"title":"External Relay module"},"sidebar":"docs","previous":{"title":"Emails module","permalink":"/docs.rspamd.com/branches/master/modules/emails"},"next":{"title":"External Services module","permalink":"/docs.rspamd.com/branches/master/modules/external_services"}}');var a=n(4848),r=n(8453);const i={title:"External Relay module"},l="External Relay module",o={},d=[{value:"Strategies",id:"strategies",level:2},{value:"Rule syntax",id:"rule-syntax",level:2},{value:"authenticated",id:"authenticated",level:3},{value:"count",id:"count",level:3},{value:"hostname_map",id:"hostname_map",level:3},{value:"ip_map",id:"ip_map",level:3}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"external-relay-module",children:"External Relay module"})}),"\n",(0,a.jsx)(s.p,{children:"This plugin is designed for users who need to conduct scans after the MX has processed a message, such as those who receive mail over POP3 and forward it to a local MTA. Most users can disregard it."}),"\n",(0,a.jsxs)(s.p,{children:["For users with such setups, it is important to disable the reject action to prevent generating backscatter. Refer to ",(0,a.jsx)(s.a,{href:"/faq#how-can-i-disable-some-rspamd-action",children:"the FAQ"})," for instructions."]}),"\n",(0,a.jsx)(s.p,{children:"If possible, it is better to run Rspamd on the MX."}),"\n",(0,a.jsx)(s.h2,{id:"strategies",children:"Strategies"}),"\n",(0,a.jsxs)(s.p,{children:["This plugin seeks to identify the real point of hand-off for a message in its ",(0,a.jsx)(s.code,{children:"Received"})," headers and set the sending IP and hostname correctly, as well as an assumed ",(0,a.jsx)(s.code,{children:"HELO"})," value. This correction occurs before any other processing, ensuring that other modules (such as ",(0,a.jsx)(s.a,{href:"/modules/rbl",children:"rbl"}),", ",(0,a.jsx)(s.a,{href:"/modules/spf",children:"spf"})," etc) receive the updated values."]}),"\n",(0,a.jsxs)(s.p,{children:["Different strategies for identifying mail to tamper with and the point of hand-off are available. While they can be configured in parallel, it is recommended that you select the most suitable strategy for your setup and configure it accordingly. If multiple strategies are configured they are not mutually exclusive & you may wish to adjust ",(0,a.jsx)(s.code,{children:"priority"})," of the rules."]}),"\n",(0,a.jsxs)(s.p,{children:["If the strategies are too broad to be used in your setup you might limit them using ",(0,a.jsx)(s.code,{children:"rspamd_config:add_condition()"}),", for example:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-lua",children:"# /etc/rspamd/rspamd.local.lua\n-- add some condition for the symbol called EXTERNAL_RELAY_COUNT\nrspamd_config:add_condition('EXTERNAL_RELAY_COUNT', function(task)\n  -- only apply this rule if authenticated user is postmaster@example.net\n  return task:get_user() == 'postmaster@example.net'\nend)\n"})}),"\n",(0,a.jsx)(s.p,{children:"The available strategies are as follows:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"authenticated"})," : use the first unauthenticated hop in a message"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"count"})," : identify Received header by set position"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"hostname_map"})," : use the first sender with an unrecognised hostname"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"ip_map"})," : use the first sender with an unrecognised IP address"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"local"})," : use the first non-local hop in a message"]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"rule-syntax",children:"Rule syntax"}),"\n",(0,a.jsx)(s.p,{children:"Because this module is disabled by default it should be explicitly enabled."}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-hcl",children:'## /etc/rspamd/local.d/external_relay.conf\n\n# enable the module\nenabled = true;\n\n# rules are defined inside rules {} block\nrules {\n  # this is the name of the symbol we will register\n  EXTERNAL_RELAY_AUTHENTICATED {\n    # a recognised strategy MUST be defined\n    strategy = "hostname_map";\n    # there may be additional non/optional settings available particular to the strategy\n    hostname_map = "/var/lib/rspamd/external_relay_hostname.map";\n  }\n}\n'})}),"\n",(0,a.jsx)(s.p,{children:"The following settings are valid for all rules:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"priority"})," (optional) : prefilter priority, default 20 (higher value implies higher priority)."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"symbol"})," (optional) : Name of symbol to insert, defaults to label of enclosing block"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"strategy"})," (required) : The name of the strategy to apply"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"The following strategy-specific settings are defined:"}),"\n",(0,a.jsx)(s.h3,{id:"authenticated",children:"authenticated"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"user_map"})," (optional): A ",(0,a.jsx)(s.a,{href:"/faq#what-are-maps",children:"map"})," containing a list of usernames. The rule applies only if the local sender uses a username listed in the configuration."]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"count",children:"count"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"count"})," (required): the position of the ",(0,a.jsx)(s.code,{children:"Received"})," header, from top to bottom."]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"hostname_map",children:"hostname_map"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"hostname_map"})," (required): A ",(0,a.jsx)(s.a,{href:"/faq#what-are-maps",children:"map"})," of hostnames which we expect to see from the sender and in ",(0,a.jsx)(s.code,{children:"Received"})," headers."]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"ip_map",children:"ip_map"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"ip_map"})," (required): A ",(0,a.jsx)(s.a,{href:"/faq#what-are-maps",children:"map"})," of IPs which we expect to see from the sender and in ",(0,a.jsx)(s.code,{children:"Received"})," headers."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>l});var t=n(6540);const a={},r=t.createContext(a);function i(e){const s=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);