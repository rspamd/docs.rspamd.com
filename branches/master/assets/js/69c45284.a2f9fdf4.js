"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[9512],{8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>t});var i=s(6540);const a={},r=i.createContext(a);function l(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(r.Provider,{value:n},e.children)}},9348:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"tutorials/multimap_guide","title":"Multimap Module Guide","description":"The multimap module is one of Rspamd\'s most powerful features for creating custom filtering rules without writing Lua code. This tutorial provides practical examples to help you implement real-world filtering scenarios.","source":"@site/docs/tutorials/multimap_guide.md","sourceDirName":"tutorials","slug":"/tutorials/multimap_guide","permalink":"/docs.rspamd.com/branches/master/tutorials/multimap_guide","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/tutorials/multimap_guide.md","tags":[],"version":"current","frontMatter":{"title":"Multimap Module Guide"},"sidebar":"docs","previous":{"title":"Contributing to Rspamd Documentation","permalink":"/docs.rspamd.com/branches/master/tutorials/site_contributing"},"next":{"title":"Settings Module Guide","permalink":"/docs.rspamd.com/branches/master/tutorials/settings_guide"}}');var a=s(4848),r=s(8453);const l={title:"Multimap Module Guide"},t="Multimap Module: Practical Examples and Use Cases",c={},d=[{value:"What is Multimap?",id:"what-is-multimap",level:2},{value:"Basic Concepts",id:"basic-concepts",level:2},{value:"Map Types",id:"map-types",level:3},{value:"Check Types",id:"check-types",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Example 1: Domain Whitelist/Blacklist",id:"example-1-domain-whitelistblacklist",level:3},{value:"Example 2: IP Reputation with Redis",id:"example-2-ip-reputation-with-redis",level:3},{value:"Example 3: Advanced Header Checks",id:"example-3-advanced-header-checks",level:3},{value:"Example 4: URL and Attachment Filtering",id:"example-4-url-and-attachment-filtering",level:3},{value:"Example 5: Per-User/Per-Domain Rules",id:"example-5-per-userper-domain-rules",level:3},{value:"Example 6: Content and URL Filtering",id:"example-6-content-and-url-filtering",level:3},{value:"Example 7: Dynamic HTTP Maps",id:"example-7-dynamic-http-maps",level:3},{value:"Example 8: Advanced Selector Maps",id:"example-8-advanced-selector-maps",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Map Management",id:"map-management",level:3},{value:"Debugging",id:"debugging",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"multimap-module-practical-examples-and-use-cases",children:"Multimap Module: Practical Examples and Use Cases"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"multimap module"})," is one of Rspamd's most powerful features for creating custom filtering rules without writing Lua code. This tutorial provides practical examples to help you implement real-world filtering scenarios."]}),"\n",(0,a.jsx)(n.h2,{id:"what-is-multimap",children:"What is Multimap?"}),"\n",(0,a.jsx)(n.p,{children:'Multimap allows you to create custom symbols based on various message attributes (sender, recipient, URLs, headers) matched against lists (files, HTTP endpoints, Redis). Think of it as a universal "if-then" rule engine.'}),"\n",(0,a.jsx)(n.h2,{id:"basic-concepts",children:"Basic Concepts"}),"\n",(0,a.jsx)(n.h3,{id:"map-types",children:"Map Types"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"File maps"}),": Static lists in files"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"HTTP maps"}),": Dynamic lists from web servers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Redis maps"}),": Key-value lookups in Redis"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Embedded maps"}),": Small lists directly in config"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"check-types",children:"Check Types"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"from"}),": Check sender address"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"rcpt"}),": Check recipient address"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ip"}),": Check sender IP"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"url"}),": Check URLs in message"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"header"}),": Check message headers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"filename"}),": Check attachment names"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,a.jsx)(n.h3,{id:"example-1-domain-whitelistblacklist",children:"Example 1: Domain Whitelist/Blacklist"}),"\n",(0,a.jsx)(n.p,{children:"Create trusted and blocked domain lists:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'# /etc/rspamd/local.d/multimap.conf\n\nTRUSTED_DOMAINS {\n  type = "from";\n  filter = "email:domain";\n  extract_from = "smtp";  # Check SMTP envelope from (default)\n  map = "/etc/rspamd/maps/trusted_domains.map";\n  score = -10.0;\n  description = "Trusted sender domains";\n}\n\nBLOCKED_DOMAINS {\n  type = "from"; \n  filter = "email:domain";\n  extract_from = "smtp";  # Check SMTP envelope from\n  map = "/etc/rspamd/maps/blocked_domains.map";\n  score = 15.0;\n  description = "Blocked sender domains";\n}\n\n# Alternative: Check MIME From header instead of SMTP envelope\nBLOCKED_MIME_DOMAINS {\n  type = "from";\n  filter = "email:domain";\n  extract_from = "mime";  # Check From: header\n  map = "/etc/rspamd/maps/blocked_mime_domains.map";\n  score = 8.0;\n  description = "Blocked domains in From header";\n}\n\nBLOCKED_RECIPIENTS {\n  type = "rcpt";\n  filter = "email:addr";  # Check full email address\n  map = "/etc/rspamd/maps/blocked_recipients.map"; \n  score = 10.0;\n  description = "Block mail to specific recipients";\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Key Concepts:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"SMTP From"})," (",(0,a.jsx)(n.code,{children:'extract_from = "smtp"'}),"): The envelope sender (MAIL FROM command) - what the receiving server sees"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"MIME From"})," (",(0,a.jsx)(n.code,{children:'extract_from = "mime"'}),"): The From: header - what users see in their email client"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Score vs Action"}),": Use ",(0,a.jsx)(n.code,{children:"score"})," for weighted decisions allowing other rules to influence the final action. Use ",(0,a.jsx)(n.code,{children:"action"})," only for prefilter rules that need immediate decisions (like IP whitelisting)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example: Prefilter for immediate decisions:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'TRUSTED_IPS_PREFILTER {\n  type = "ip";\n  map = "/etc/rspamd/maps/trusted_ips.map";\n  prefilter = true;   # Runs before other rules\n  action = "accept";  # Immediately accept, no scoring\n  description = "Trusted IPs - bypass all checks";\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Create the map files:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# /etc/rspamd/maps/trusted_domains.map\nexample.com\npartner-company.org\nbank.com\n\n# /etc/rspamd/maps/blocked_domains.map  \nspam-domain.com\nphishing-site.net\nmalware-host.org\n\n# /etc/rspamd/maps/blocked_recipients.map\nspam-trap@yourdomain.com\nhoneypot@yourdomain.com\n"})}),"\n",(0,a.jsx)(n.h3,{id:"example-2-ip-reputation-with-redis",children:"Example 2: IP Reputation with Redis"}),"\n",(0,a.jsx)(n.p,{children:"Use Redis for dynamic IP scoring:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'IP_WHITELIST {\n  type = "ip";\n  map = "redis://ip_whitelist";\n  score = -5.0;\n  description = "Whitelisted IPs in Redis";\n}\n\nIP_REPUTATION {\n  type = "ip";\n  map = "redis://ip_blacklist";\n  score = 8.0;\n  description = "Bad IP reputation";\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Configure Redis connection in multimap:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'# Also add Redis configuration\nredis {\n  servers = "127.0.0.1:6379";\n  # password = "your_redis_password";  # if needed\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Add IPs to Redis:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'# Whitelist an IP (key in hash = IP, value = description)\nredis-cli HSET ip_whitelist "192.168.1.100" "trusted_server"\n\n# Add bad reputation IP  \nredis-cli HSET ip_blacklist "203.0.113.5" "spam_source"\n\n# You can also use CIDR notation\nredis-cli HSET ip_blacklist "203.0.113.0/24" "spam_network"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"example-3-advanced-header-checks",children:"Example 3: Advanced Header Checks"}),"\n",(0,a.jsx)(n.p,{children:"Check various message headers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'SUSPICIOUS_MAILERS {\n  type = "header";\n  header = "X-Mailer";\n  map = [\n    "/Mass Mailer/i",\n    "/Bulk.*Mail/i", \n    "/spam/i"\n  ];\n  regexp = true;  # Required for regex patterns\n  score = 5.0;\n  description = "Suspicious mail clients";\n}\n\nFORGED_OUTLOOK {\n  type = "from";\n  filter = "email:domain";\n  extract_from = "smtp";\n  map = [\n    "outlook.com",\n    "hotmail.com", \n    "live.com"\n  ];\n  score = 7.0;\n  description = "Checks if sender claims to be from major email providers";\n  # This checks SMTP envelope, combine with DKIM/SPF for spoofing detection\n}\n\nBULK_MAIL_HEADERS {\n  type = "header";\n  header = "Precedence";\n  map = [\n    "bulk",\n    "list",\n    "junk"\n  ];\n  score = 2.0;\n  description = "Bulk mail precedence headers";\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"example-4-url-and-attachment-filtering",children:"Example 4: URL and Attachment Filtering"}),"\n",(0,a.jsx)(n.p,{children:"Filter based on URLs and file attachments:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'BLOCKED_URLS {\n  type = "url";\n  filter = "tld";\n  map = "/etc/rspamd/maps/blocked_tlds.map";\n  score = 10.0;\n  description = "Blocked TLD in URLs";\n}\n\nSUSPICIOUS_ATTACHMENTS {\n  type = "filename";\n  filter = "extension";\n  map = [\n    "exe",\n    "scr",\n    "bat", \n    "com",\n    "pif"\n  ];\n  score = 15.0;\n  description = "Dangerous file extensions";\n}\n\nARCHIVE_WITH_EXE {\n  type = "filename";\n  filter = "full";\n  map = [\n    "/.*\\\\.zip:.*\\\\.exe$/i",\n    "/.*\\\\.rar:.*\\\\.scr$/i"\n  ];\n  regexp = true;  # Required for regex patterns\n  score = 20.0;\n  description = "Archive containing executable";\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Create the TLD map:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# /etc/rspamd/maps/blocked_tlds.map\ntk\nml\nga\ncf\n"})}),"\n",(0,a.jsx)(n.h3,{id:"example-5-per-userper-domain-rules",children:"Example 5: Per-User/Per-Domain Rules"}),"\n",(0,a.jsx)(n.p,{children:"Create different rules for different domains:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'VIP_DOMAINS {\n  type = "rcpt";\n  filter = "email:domain";\n  map = "/etc/rspamd/maps/vip_domains.map";\n  score = -5.0;\n  description = "VIP domain recipients";\n}\n\nVIP_SENDER_WHITELIST {\n  type = "from";\n  filter = "email:domain"; \n  map = "/etc/rspamd/maps/vip_sender_whitelist.map";\n  score = -8.0;\n  description = "VIP sender whitelist";\n  require_symbols = "VIP_DOMAINS";\n}\n\nMARKETING_DOMAINS {\n  type = "rcpt";\n  filter = "email:domain";\n  map = [\n    "marketing.company.com",\n    "newsletter.company.com"\n  ];\n  score = -2.0;\n  description = "Marketing domains - relaxed filtering";\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"example-6-content-and-url-filtering",children:"Example 6: Content and URL Filtering"}),"\n",(0,a.jsx)(n.p,{children:"Filter message content and URLs for security:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'FORBIDDEN_CONTENT {\n  type = "content";\n  filter = "oneline";  # Decoded text without newlines\n  map = [\n    "/urgent.*transfer.*funds/i",\n    "/click.*here.*immediately/i",\n    "/congratulations.*winner/i"\n  ];\n  regexp = true;\n  score = 8.0;\n  description = "Suspicious content patterns";\n}\n\nPHISHING_URLS {\n  type = "url";\n  filter = "host";  # Check hostname part of URLs\n  map = "/etc/rspamd/maps/phishing_domains.map";\n  score = 12.0;\n  description = "Known phishing domains";\n}\n\nSUSPICIOUS_SHORTENERS {\n  type = "url";\n  filter = "host";\n  map = [\n    "bit.ly",\n    "tinyurl.com", \n    "goo.gl",\n    "t.co"\n  ];\n  score = 2.0;\n  description = "URL shortener services";\n}\n\nSENSITIVE_KEYWORDS {\n  type = "content";\n  filter = "text";  # Check all text parts\n  map = [\n    "/\\\\bssn\\\\b/i",           # Social Security Number\n    "/\\\\b\\\\d{3}-\\\\d{2}-\\\\d{4}\\\\b/",  # SSN format\n    "/\\\\bcredit card\\\\b/i",\n    "/\\\\bpassword\\\\b/i"\n  ];\n  regexp = true;\n  score = 5.0;\n  description = "Contains sensitive information";\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"example-7-dynamic-http-maps",children:"Example 7: Dynamic HTTP Maps"}),"\n",(0,a.jsx)(n.p,{children:"Use HTTP endpoints for dynamic lists:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'DYNAMIC_IP_BLACKLIST {\n  type = "ip";\n  map = "http://security.company.com/rspamd/bad_ips.txt";\n  score = 10.0;\n  description = "Dynamic IP blacklist";\n  upstreams = "http://security.company.com";\n}\n\nPHISHING_DOMAINS {\n  type = "url";\n  filter = "host";\n  map = "http://threat-intel.company.com/phishing_domains.json";\n  score = 15.0;\n  description = "Real-time phishing domains";\n  upstreams = "http://threat-intel.company.com";\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"example-8-advanced-selector-maps",children:"Example 8: Advanced Selector Maps"}),"\n",(0,a.jsx)(n.p,{children:"Use Rspamd selectors for sophisticated matching:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'SPF_FAIL_FREEMAIL {\n  type = "selector";\n  selector = "from:domain";\n  map = "/etc/rspamd/maps/freemail_domains.map";\n  score = 5.0;\n  description = "SPF fail from freemail";\n  require_symbols = "R_SPF_FAIL";\n}\n\nAUTHENTICATED_USER_DOMAIN {\n  type = "selector";\n  selector = "user";  # Gets authenticated username\n  filter = "email:domain";\n  map = "/etc/rspamd/maps/allowed_user_domains.map";\n  score = -3.0;\n  description = "Authenticated user from allowed domain";\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use appropriate map types"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'# For small static lists\nmap = ["item1", "item2", "item3"];\n\n# For large lists\nmap = "file:///etc/rspamd/maps/large_list.map";\n\n# For frequently changing data\nmap = "redis+selector";\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Order rules by frequency"}),":\nPlace frequently matching rules first."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Redis for dynamic data"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'# Instead of file updates\nmap = "redis://hashkey_name";\n# Configure Redis servers in multimap config\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"map-management",children:"Map Management"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Automatic map updates"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Update HTTP maps automatically\n# Rspamd checks If-Modified-Since headers\n\n# For file maps, use inotify or cron:\n*/5 * * * * /usr/bin/rspamc reload\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Map validation"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'# Test map syntax\nrspamadm configtest\n\n# Check map loading\ngrep "multimap" /var/log/rspamd/rspamd.log\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"debugging",children:"Debugging"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Enable debug logging"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'# /etc/rspamd/local.d/logging.inc\ndebug_modules = ["multimap"];\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Test rules"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Test message against rules\nrspamc -v < test_message.eml\n\n# Check symbol details\nrspamc symbols\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Maps not loading"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Check file permissions\nls -la /etc/rspamd/maps/\n\n# Check syntax\nrspamadm configtest\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Rules not matching"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Enable debug logging\n# Check filter and selector syntax\n# Verify map contents\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Performance problems"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Monitor map reload frequency\n# Check Redis connection\n# Use appropriate map types\n"})}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);