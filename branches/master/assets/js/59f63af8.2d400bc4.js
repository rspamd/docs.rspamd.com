"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[5439],{18729:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>t});const r=JSON.parse('{"id":"modules/rbl","title":"RBL module","description":"{:.no_toc}","source":"@site/docs/modules/rbl.md","sourceDirName":"modules","slug":"/modules/rbl","permalink":"/docs.rspamd.com/branches/master/modules/rbl","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/modules/rbl.md","tags":[],"version":"current","frontMatter":{"title":"RBL module"},"sidebar":"docs","previous":{"title":"Ratelimit module","permalink":"/docs.rspamd.com/branches/master/modules/ratelimit"},"next":{"title":"Regexp module","permalink":"/docs.rspamd.com/branches/master/modules/regexp"}}');var i=n(74848),l=n(28453);const o={title:"RBL module"},c="RBL module",d={},t=[{value:"Configuration structure",id:"configuration-structure",level:2},{value:"Configuration parameters",id:"configuration-parameters",level:2},{value:"Global parameters",id:"global-parameters",level:3},{value:"RBL-specific parameters",id:"rbl-specific-parameters",level:3},{value:"Returncodes Matchers",id:"returncodes-matchers",level:2},{value:"URL rules",id:"url-rules",level:2},{value:"URL rules configuration",id:"url-rules-configuration",level:2},{value:"Monitoring",id:"monitoring",level:2},{value:"Principles of operation",id:"principles-of-operation",level:2},{value:"TLD composition",id:"tld-composition",level:3},{value:"Specific URL composition rules",id:"specific-url-composition-rules",level:3},{value:"DNS composition",id:"dns-composition",level:3},{value:"Results parsing",id:"results-parsing",level:3},{value:"IP lists",id:"ip-lists",level:2},{value:"Disabling rules",id:"disabling-rules",level:2},{value:"Use of URL redirectors",id:"use-of-url-redirectors",level:2},{value:"Selectors",id:"selectors",level:2}];function a(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"rbl-module",children:"RBL module"})}),"\n",(0,i.jsx)(s.p,{children:"{:.no_toc}"}),"\n",(0,i.jsx)(s.p,{children:"The RBL module offers support for checking various message elements, such as the sender's IP addresses, URLs, emails, Received headers chains, SMTP data (e.g. HELO domain), and more, against a set of Runtime Black Lists (RBL) typically provided through dedicated DNS zones."}),"\n",(0,i.jsx)(s.p,{children:"By default, Rspamd comes with a set of RBL rules pre-configured for popular resources that are often free for non-profit usage, subject to fair usage policies. If you require a different level of support or access, please contact the relevant vendors."}),"\n",(0,i.jsxs)(s.p,{children:["For example, you can use ",(0,i.jsx)(s.a,{href:"https://abusix.com/docs/rspamd/",children:"Abusix Mail Intelligence"})," or ",(0,i.jsx)(s.a,{href:"https://github.com/spamhaus/rspamd-dqs",children:"Spamhaus DQS"})," or any other RBL provider that suits your needs."]}),"\n",(0,i.jsx)(s.h2,{id:"configuration-structure",children:"Configuration structure"}),"\n",(0,i.jsx)(s.p,{children:"Configuration for this module is structured as following:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'# local.d/rbl.conf\n\n# \'rbls\' subsection under which the RBL definitions are nested\nrbls {\n  # rbl-specific subsection\n  an_rbl {\n    ## required settings\n    # checks to enable for this RBL\n    checks = ["from"];\n    # Address used for RBL-testing\n    rbl = "rbl.example.net";\n\n    ## some optional settings\n    # Explicitly defined symbol\n    symbol = "SOME_SYMBOL";\n\n    # redefined defaults for IPv6 only RBL\n    ipv4 = false;\n    ipv6 = true; # Define IPv6 only RBL\n\n    # Possible responses from RBL and symbols to yield\n    returncodes = {\n      # Name_of_symbol = "address";\n      EXAMPLE_ONE = "127.0.0.1";\n      EXAMPLE_TWO = "127.0.0.2";\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(s.h2,{id:"configuration-parameters",children:"Configuration parameters"}),"\n",(0,i.jsx)(s.h3,{id:"global-parameters",children:"Global parameters"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"local_exclude_ip_map"}),": map containing additional IPv4/IPv6 addresses/subnets that should be considered private and excluded from checks where ",(0,i.jsx)(s.code,{children:"exclude_local"})," is ",(0,i.jsx)(s.code,{children:"true"})," (the default)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"url_whitelist"}),": map containing host names which should be skipped by URL checks."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"rbl-specific-parameters",children:"RBL-specific parameters"}),"\n",(0,i.jsxs)(s.p,{children:["The required parameters ",(0,i.jsx)(s.code,{children:"rbl"})," and ",(0,i.jsx)(s.code,{children:"checks"})," set the address used for testing and the checks to be performed respectively. Valid values for ",(0,i.jsx)(s.code,{children:"checks"})," can include any of the following:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"content_urls"})," - URLs extracted by ",(0,i.jsx)(s.code,{children:"lua_content"})," (eg. from PDFs)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"dkim"})," - domain that provided DKIM signature for a message"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"emails"})," - email addresses found in a message-body"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"from"})," - the sending IP that sent the message"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"helo"})," - HELO provided by the sender"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"images"})," - URLs of images linked in message body"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"numeric_urls"})," - IP addresses featuring in the hostname part of URLs (since 3.7)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"rdns"})," - sender's hostname as provided to Rspamd (expected to be forward-confirmed)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"received"})," - IP addresses found in ",(0,i.jsx)(s.code,{children:"Received"})," headers"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"replyto"})," - address from the ",(0,i.jsx)(s.code,{children:"Reply-To"})," header of a message"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"urls"})," - URLs extracted from message body"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"You can use selectors to look up arbitrary data. Please refer to the section on selectors for more information."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'# /etc/rspamd/local.d/rbl.conf\nrules {\n  # minimal configuration example\n  SIMPLE_RBL {\n    rbl = "rbl.example.net";\n    checks = ["from"];\n  }\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"Optional parameters (and their defaults if applicable) are as follows:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"dkim_domainonly"})," (true) - lookup eSLD associated with DKIM signature rather than full label"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"dkim_match_from"})," (false) - only check DKIM signatures matching the ",(0,i.jsx)(s.code,{children:"From"})," header"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"emails_domainonly"})," (false) - lookup domain of address instead of full address"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"enabled"})," (true) - allow for disabling of RBLs"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"exclude_local"})," (true) - do not check messages from private IPs against this RBL (for ",(0,i.jsx)(s.code,{children:"received"})," check: do not check private IPs at all)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"exclude_users"})," (false) - do not check this RBL if sender is an authenticated user"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"hash"})," - valid for ",(0,i.jsx)(s.code,{children:"helo"})," and ",(0,i.jsx)(s.code,{children:"emails"})," RBL types - lookup hashes instead of literal strings. Possible values for this parameter are ",(0,i.jsx)(s.code,{children:"sha1"}),", ",(0,i.jsx)(s.code,{children:"sha256"}),", ",(0,i.jsx)(s.code,{children:"sha384"}),", ",(0,i.jsx)(s.code,{children:"sha512"})," and ",(0,i.jsx)(s.code,{children:"md5"})," or any other value for the default hashing algorithm."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"hash_format"})," - encoding to use for hash: ",(0,i.jsx)(s.code,{children:"hex"}),", ",(0,i.jsx)(s.code,{children:"base32"})," or ",(0,i.jsx)(s.code,{children:"base64"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"ignore_whitelist"})," (false) - allow whitelists to neutralise this RBL"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"images"})," (false) - whether image URLs should be checked by ",(0,i.jsx)(s.code,{children:"urls"})," check"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"ipv4"})," (true) - if IPv4 addresses should be checked"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"ipv6"})," (true) - if IPv6 addresses should be checked"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"is_whitelist"})," (false) - denotes that this RBL is an whitelist"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"local_exclude_ip_map"})," - map containing IPv4/IPv6 addresses/subnets which should be considered private (and treated as local by ",(0,i.jsx)(s.code,{children:"exclude_local"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"monitored_address"})," (",(0,i.jsx)(s.code,{children:"1.0.0.127"}),") - fixed address to check for absence; see section on monitoring for more information"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"no_ip"})," (false) - do not look up IP addresses in this RBL"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"requests_limit"})," (9999) - maximum number of entities extracted by URL checks"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"resolve_ip"})," - resolve the domain to IP address"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"returnbits"})," - dictionary of symbols mapped to bit positions; if the bit in the specified position is set the symbol will be returned"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"returncodes"})," - dictionary of symbols mapped to lua patterns; if result returned by the RBL matches the pattern the symbol will be returned"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"returncodes_matcher"})," - a specific mechanism for testing ",(0,i.jsx)(s.code,{children:"returncodes"}),", see ",(0,i.jsx)(s.a,{href:"/modules/rbl#returncodes-matchers",children:"details"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"selector_flatten"})," (true) - when disabled will lookup result of chained selector as a single label without any separator"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"selector"})," - one or more selectors producing data to look up in this RBL; see section on selectors for more information"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"unknown"})," (false) - yield default symbol if ",(0,i.jsx)(s.code,{children:"returncodes"})," or ",(0,i.jsx)(s.code,{children:"returnbits"})," is specified and RBL returns unrecognised result"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"whitelist_exception"})," - for whitelists; list of symbols which will not act as whitelists"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Some examples of using RBL:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'rbls {\n\n    blocklist {\n      symbol = "BLOCKLIST";\n      rbl = "blocklist.bl";\n      checks = [\'from\', \'received\'];\n    }\n    \n    WHITELIST_BASE {\n      checks = [\'from\', \'received\'];\n      is_whitelist = true;\n      rbl = "whitelist.wl";\n      symbol = "WL_RBL_UNKNOWN";\n      unknown = true;\n      returncodes = {\n        "WL_RBL_CODE_2" = "127.0.0.2";\n        "WL_RBL_CODE_3" = "127.0.0.3";\n      }\n    }\n      \n    DNS_WL {\n      symbol = "DNS_WL";\n      rbl = "dnswl.test";\n      checks = [\'dkim\'];\n      dkim_domainonly = false;\n      dkim_match_from = true;\n      ignore_whitelist = true;\n      unknown = false;\n      returncodes_matcher = "luapattern";\n\n      returncodes {\n        DNS_WL_NONE = "127.0.%d+.0";\n        DNS_WL_LOW = "127.0.%d+.1";\n        DNS_WL_MED = "127.0.%d+.2";\n        DNS_WL_HI = "127.0.%d+.3";\n        DNS_WL_BLOCKED = "127.0.0.255";\n      }\n    }\n  }\n  \n'})}),"\n",(0,i.jsx)(s.h2,{id:"returncodes-matchers",children:"Returncodes Matchers"}),"\n",(0,i.jsxs)(s.p,{children:["From version 3.7.2 Rspamd supports different strategies for handling ",(0,i.jsx)(s.code,{children:"returncodes"})," via the ",(0,i.jsx)(s.code,{children:"returncodes_matcher"})," setting."]}),"\n",(0,i.jsxs)(s.p,{children:["By default return codes are tested for equality with the result of the DNS query. For backwards compatibility values containing the percent character implicitly enable the ",(0,i.jsx)(s.code,{children:"luapattern"})," matcher if one is not set."]}),"\n",(0,i.jsx)(s.p,{children:"Matcher types:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"equality"}),": the default, not useful for actual configuration"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"luapattern"}),": match query results using ",(0,i.jsx)(s.a,{href:"http://lua-users.org/wiki/PatternsTutorial",children:"Lua patterns"}),", the old default"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"radix"}),": check for query results inside collection of subnets and IP addresses"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"glob"}),': match query results against "globbed" strings']}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"regexp"}),": match query results using regular expressions"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Examples:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'  returncodes_matcher = "radix";\n  returncodes {\n    SYMBOL_ONE = "127.0.0.0/24";\n    SYMBOL_TWO = ["192.168.0.0/16", "1.2.3.4"];\n  }\n\n  returncodes_matcher = "glob";\n  returncodes {\n    SYMBOL_ONE = "127.0.0.*";\n    SYMBOL_TWO = ["192.168.*.*", "1.2.3.4"];\n  }\n\n  returncodes_matcher = "regexp";\n  returncodes {\n    # regexp is not automatically anchored\n    SYMBOL_ONE = \'^127\\.0\\.0\\.\\d+$\';\n    SYMBOL_TWO = [\'^192\\.168\\.\\d+\\.\\d+$", \'^1\\.2\\.3\\.4$\'];\n  }\n\n  returncodes_matcher = "luapattern";\n  returncodes {\n    # lua patterns are automatically anchored by ^ and $\n    SYMBOL_ONE = \'127%.0%.0%.%d+\';\n    SYMBOL_TWO = [\'192%.168%.%d+%.%d+", \'1%.2%.3%.4\'];\n  }\n'})}),"\n",(0,i.jsx)(s.h2,{id:"url-rules",children:"URL rules"}),"\n",(0,i.jsxs)(s.p,{children:["Starting from version 2.0, both the ",(0,i.jsx)(s.code,{children:"Emails"})," and ",(0,i.jsx)(s.code,{children:"SURBL"})," modules are deprecated in favour of the rules for the RBL module. Rspamd automatically converts the old rules on start. If you have custom rules in either the ",(0,i.jsx)(s.code,{children:"SURBL"})," or ",(0,i.jsx)(s.code,{children:"Emails"})," module, they are converted to have priority over RBL modules for a smooth transition. However, new rules should only be written for the RBL module, as the transition phase for the ",(0,i.jsx)(s.code,{children:"SURBL"})," and ",(0,i.jsx)(s.code,{children:"Emails"})," modules will not last forever."]}),"\n",(0,i.jsxs)(s.p,{children:["Previously, the ",(0,i.jsx)(s.code,{children:"SURBL"})," module was responsible for scanning URLs found in messages against a list of known RBLs. However, these functions are now transferred to the RBL module."]}),"\n",(0,i.jsxs)(s.p,{children:["URLs extracted from the message body & URLs extracted from content such as PDFs can be checked by adding ",(0,i.jsx)(s.code,{children:"urls"})," and/or ",(0,i.jsx)(s.code,{children:"content_urls"})," respectively to the ",(0,i.jsx)(s.code,{children:"checks"})," setting."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Image URLs are not extracted by default"}),", to include image URLs, add ",(0,i.jsx)(s.code,{children:"images"})," to the ",(0,i.jsx)(s.code,{children:"checks"})," setting. If ",(0,i.jsx)(s.code,{children:"images"})," is used in ",(0,i.jsx)(s.code,{children:"checks"})," without ",(0,i.jsx)(s.code,{children:"urls"})," only image URLs are extracted."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Numeric URLs (IP addresses) are extracted by default"})," and are looked up in reverse notation, to exclude them set ",(0,i.jsx)(s.code,{children:"no_ip = true"}),"; or to extract IP addresses only set ",(0,i.jsx)(s.code,{children:'checks = ["numeric_urls"]'})," (since 3.7). Combining this check with the ",(0,i.jsx)(s.code,{children:"urls"})," check doesn't make logical sense; if combined with ",(0,i.jsx)(s.code,{children:"content_urls"})," or ",(0,i.jsx)(s.code,{children:"images"})," then numeric URLs from content and images are respectively included (by default they are excluded as with ",(0,i.jsx)(s.code,{children:"urls"})," check)."]}),"\n",(0,i.jsx)(s.h2,{id:"url-rules-configuration",children:"URL rules configuration"}),"\n",(0,i.jsx)(s.p,{children:"Rspamd defines a set of URL lists in the configuration by default. However, their terms of usage typically prohibit commercial or extensive usage without purchasing a specific type of license."}),"\n",(0,i.jsx)(s.p,{children:"Nevertheless, these lists can be used free of charge by personal services or low-volume requests."}),"\n",(0,i.jsx)(s.p,{children:"Here are the default lists specified:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'# local.d/rbl.conf\n\n# List of domains that are not checked by surbl\nurl_whitelist = "file://$CONFDIR/local.d/maps.d/surbl-whitelist.inc.local";\n\n# \'rbls\' subsection under which the SURBL definitions are nested\nrbls {\n\n    "SURBL_MULTI" {\n      ignore_defaults = true; # for compatibility with old defaults\n      rbl = "multi.surbl.org";\n      checks = [\'emails\', \'dkim\', \'urls\'];\n      emails_domainonly = true;\n      urls = true;\n\n      returnbits = {\n        CRACKED_SURBL = 128; # From February 2016\n        ABUSE_SURBL = 64;\n        CT_SURBL = 32;\n        MW_SURBL_MULTI = 16;\n        PH_SURBL_MULTI = 8;\n        DM_SURBL = 4;\n        SURBL_BLOCKED = 1;\n      }\n    }\n    \n    "URIBL_MULTI" {\n      ignore_defaults = true; # for compatibility with old defaults\n      rbl = "multi.uribl.com";\n      checks = [\'emails\', \'dkim\', \'urls\'];\n      emails_domainonly = true;\n\n      returnbits = {\n        URIBL_BLOCKED = 1;\n        URIBL_BLACK = 2;\n        URIBL_GREY = 4;\n        URIBL_RED = 8;\n      }\n    }\n    \n    "RSPAMD_URIBL" {\n      ignore_defaults = true; # for compatibility with old defaults\n      rbl = "uribl.rspamd.com";\n      checks = [\'emails\', \'dkim\', \'urls\'];\n      # Also check images\n      images = true;\n      # Check emails for URLs\n      emails_domainonly = true;\n      # Hashed BL\n      hash = \'blake2\';\n      hash_len = 32;\n      hash_format = \'base32\';\n\n      returncodes = {\n        RSPAMD_URIBL = [\n          "127.0.0.2",\n        ];\n      }\n    }\n    \n    "DBL" {\n      ignore_defaults = true; # for compatibility with old defaults\n      rbl = "dbl.spamhaus.org";\n      no_ip = true;\n      checks = [\'emails\', \'dkim\', \'urls\'];\n      emails_domainonly = true;\n\n      returncodes = {\n        # spam domain\n        DBL_SPAM = "127.0.1.2";\n        # phish domain\n        DBL_PHISH = "127.0.1.4";\n        # malware domain\n        DBL_MALWARE = "127.0.1.5";\n        # botnet C&C domain\n        DBL_BOTNET = "127.0.1.6";\n        # abused legit spam\n        DBL_ABUSE = "127.0.1.102";\n        # abused spammed redirector domain\n        DBL_ABUSE_REDIR = "127.0.1.103";\n        # abused legit phish\n        DBL_ABUSE_PHISH = "127.0.1.104";\n        # abused legit malware\n        DBL_ABUSE_MALWARE = "127.0.1.105";\n        # abused legit botnet C&C\n        DBL_ABUSE_BOTNET = "127.0.1.106";\n        # error - IP queries prohibited!\n        DBL_PROHIBIT = "127.0.1.255";\n        # issue #3074\n        DBL_BLOCKED_OPENRESOLVER = "127.255.255.254";\n        DBL_BLOCKED = "127.255.255.255";\n      }\n    }\n    \n    "SEM_URIBL_UNKNOWN" {\n      ignore_defaults = true; # for compatibility with old defaults\n      rbl = "uribl.spameatingmonkey.net";\n      no_ip = true;\n      checks = [\'emails\', \'dkim\', \'urls\'];\n      emails_domainonly = true;\n      returnbits {\n        SEM_URIBL = 2;\n      }\n    }\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["Each list should have a ",(0,i.jsx)(s.code,{children:"suffix"})," parameter that defines the list itself, and optionally, some replies processing logic either by ",(0,i.jsx)(s.code,{children:"returnbits"})," or ",(0,i.jsx)(s.code,{children:"returncodes"})," sections."]}),"\n",(0,i.jsxs)(s.p,{children:["As some URL lists do not accept ",(0,i.jsx)(s.code,{children:"IP"})," addresses, it is possible to disable the sending of URLs with IP addresses in the host to such lists. This can be done by specifying the ",(0,i.jsx)(s.code,{children:"no_ip = true"})," option."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'"DBL" {\n    rbl = "dbl.spamhaus.org";\n    # Do not check numeric URLs\n    no_ip = true;\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"URL blacklists can also be used to check DKIM signature domains, HTML image URLs, and email addresses (domain part) in the mail's body part for URLs."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:"    \"RSPAMD_URIBL\" {\n      ignore_defaults = true; # for compatibility with old defaults\n      rbl = \"uribl.rspamd.com\";\n      checks = ['emails', 'dkim', 'urls'];\n      # Also check images\n      images = true;\n      # Check emails for URLs\n      emails_domainonly = true;\n      # Hashed BL\n      hash = 'blake2';\n      hash_len = 32;\n      hash_format = 'base32';\n\n      returncodes = {\n        RSPAMD_URIBL = [\n          \"127.0.0.2\",\n        ];\n      }\n    }\n"})}),"\n",(0,i.jsx)(s.p,{children:"In this example, we also enable privacy for requests by hashing all elements before sending. This feature is supported by a limited number of RBLs, such as Rspamd URL blacklist or MSBL EBL."}),"\n",(0,i.jsx)(s.h2,{id:"monitoring",children:"Monitoring"}),"\n",(0,i.jsxs)(s.p,{children:["Rspamd checks each RBL rule to ensure it's a valid DNS list as defined in ",(0,i.jsx)(s.a,{href:"https://datatracker.ietf.org/doc/html/rfc5782",children:"RFC 5782"})," by default. This is done to avoid situations where a single RBL blacklists the entire world or becomes unresponsive. For the IP-based rules, meaning that an IP address is queried, Rspamd will query for the ",(0,i.jsx)(s.code,{children:"127.0.0.1"})," address, as per the RFC, this must return an ",(0,i.jsx)(s.code,{children:"NXDOMAIN"})," response. However, some DNS lists are non RFC compatible, so you can disable monitoring for them as follows:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'    "HOSTKARMA_URIBL" {\n      rbl = "hostkarma.junkemailfilter.com";\n      no_ip = true;\n      enabled = false;\n      \n      returncodes = {\n        URIBL_HOSTKARMA_WHITE = "127.0.0.1";\n        URIBL_HOSTKARMA_BLACK = "127.0.0.2";\n        URIBL_HOSTKARMA_YELLOW = "127.0.0.3";\n        URIBL_HOSTKARMA_BROWN = "127.0.0.4";\n        URIBL_HOSTKARMA_NOBLACK = "127.0.0.5";\n        URIBL_HOSTKARMA_24_48H = "127.0.2.1";\n        URIBL_HOSTKARMA_LAST_10D = "127.0.2.2";\n        URIBL_HOSTKARMA_OLDER_10D = "127.0.2.3";\n      }\n      disable_monitoring = true;\n    }\n'})}),"\n",(0,i.jsxs)(s.p,{children:["For non IP lists (DKIM, URL, Email and so on), Rspamd will just produce some long random string to query expecting that this random string will ",(0,i.jsx)(s.em,{children:"very likely"})," return ",(0,i.jsx)(s.code,{children:"NXDOMAIN"})," by its nature."]}),"\n",(0,i.jsx)(s.h2,{id:"principles-of-operation",children:"Principles of operation"}),"\n",(0,i.jsxs)(s.p,{children:["In this section, we define how ",(0,i.jsx)(s.code,{children:"RBL"})," module performs its checks."]}),"\n",(0,i.jsx)(s.h3,{id:"tld-composition",children:"TLD composition"}),"\n",(0,i.jsxs)(s.p,{children:["By default, we want to check some top level domain, however, many domains contain\ntwo components while others can have 3 or even more components to check against the\nlist. By default, rspamd takes top level domain as defined in the ",(0,i.jsx)(s.a,{href:"https://publicsuffix.org",children:"public suffixes"}),".\nThen one more component is prepended, for example:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"sub.example.com -> [.com] -> example.com\nsub.co.uk -> [.co.uk] -> sub.co.uk\n"})}),"\n",(0,i.jsxs)(s.p,{children:["However, sometimes even more levels of domain components are required. In this case,\nthe ",(0,i.jsx)(s.code,{children:"exceptions"})," map can be used. For example, if we want to check all subdomains of\n",(0,i.jsx)(s.code,{children:"example.com"})," and ",(0,i.jsx)(s.code,{children:"example.co.uk"}),", then we can define the following list:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"example.com\nexample.co.uk\n"})}),"\n",(0,i.jsx)(s.p,{children:"Here are new composition rules:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"sub.example.com -> [.example.com] -> sub.example.com\nsub1.sub2.example.co.uk -> [.example.co.uk] -> sub2.example.co.uk\n"})}),"\n",(0,i.jsx)(s.h3,{id:"specific-url-composition-rules",children:"Specific URL composition rules"}),"\n",(0,i.jsxs)(s.p,{children:["Starting from Rspamd 2.5, it is now possible to define custom composition rules per RBL rule, using the ",(0,i.jsx)(s.code,{children:"lua_urls_compose"})," library. Below is a basic explanation of how these composition rules work:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-lua",children:"-- First one is the input hostname, the second is the expected results\ncases = {\n  {'example.com', 'example.com'},\n  {'baz.example.com', 'baz.example.com'},\n  {'3.baz.example.com', 'baz.example.com'},\n  {'bar.example.com', 'example.com'},\n  {'foo.example.com', 'foo.example.com'},\n  {'3.foo.example.com', '3.foo.example.com'},\n}\n-- Just a domain means domain + 1 level\n-- *.domain means the full hostname if the last part matches\n-- !domain means exclusion\n-- !*.domain means the same in fact :)\n-- More rules can be added easily...\nlocal excl_rules1 = {\n  'example.com',\n  '*.foo.example.com',\n  '!bar.example.com'\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"To define a specific map for these rules, the following syntax can be used:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:"# local.d/rbl.conf\nrules {\n  EXAMPLE_RBL = {\n      suffix = \"example.url.bl.com\";\n      url_compose_map = \"${CONFDIR}/maps.d/url_compose_map.list\";\n      checks = ['emails', 'dkim', 'urls'];\n      emails_domainonly = true;\n      ignore_defaults = true;\n  }\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"Where in maps you can use something like this:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"*.dirty.sanchez.com\n!not.dirty.sanchez.com\n41.black.sanchez.com\n"})}),"\n",(0,i.jsxs)(s.p,{children:["So it will check 5 hostname components for all urls in ",(0,i.jsx)(s.code,{children:"dirty.sanchez.com"})," (e.g. ",(0,i.jsx)(s.code,{children:"sub.some.dirty.sanchez.com"})," will be transformed to just ",(0,i.jsx)(s.code,{children:"some.dirty.sanchez.com"}),") but not for ",(0,i.jsx)(s.code,{children:"not.dirty.sanchez.com"})," where the normal tld rules will apply (e.g. ",(0,i.jsx)(s.code,{children:"some.not.dirty.sanchez.com"})," -> ",(0,i.jsx)(s.code,{children:"sanchez.com"}),"), and for ",(0,i.jsx)(s.code,{children:"41.black.sanchez.com"})," all 5 components will be checked, e.g. ",(0,i.jsx)(s.code,{children:"something.41.black.sanchez.com"}),"."]}),"\n",(0,i.jsx)(s.h3,{id:"dns-composition",children:"DNS composition"}),"\n",(0,i.jsx)(s.p,{children:"SURBL module composes the DNS request of two parts:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"TLD component as defined in the previous section;"}),"\n",(0,i.jsx)(s.li,{children:"DNS list suffix"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"For example, to form a request to multi.surbl.org, the following applied:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"example.com -> example.com.multi.surbl.com\n"})}),"\n",(0,i.jsx)(s.h3,{id:"results-parsing",children:"Results parsing"}),"\n",(0,i.jsxs)(s.p,{children:["Normally, DNS blacklists encode reply in A record from some private network\n(namely, ",(0,i.jsx)(s.code,{children:"127.0.0.0/8"}),"). Encoding varies from one service to another. Some lists\nuse bits encoding, where a single DNS list or error message is encoded as a bit\nin the least significant octet of the IP address. For example, if bit 1 encodes ",(0,i.jsx)(s.code,{children:"LISTA"}),"\nand bit 2 encodes ",(0,i.jsx)(s.code,{children:"LISTB"}),", then we need to perform bitwise ",(0,i.jsx)(s.code,{children:"OR"})," for each specific bit\nto decode reply:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:" 127.0.0.3 -> LISTA | LISTB -> both bit symbols are added\n 127.0.0.2 -> LISTB only\n 127.0.0.1 -> LISTA only\n"})}),"\n",(0,i.jsx)(s.p,{children:"The use of this encoding can reduce DNS requests needed to query multiple lists individually."}),"\n",(0,i.jsxs)(s.p,{children:["However, some lists use a direct encoding method where specific addresses are assigned to each list. In such cases, the decoding principle for the results should be defined in the ",(0,i.jsx)(s.code,{children:"ips"})," section instead of the ",(0,i.jsx)(s.code,{children:"bits"})," section since bitwise rules do not apply to these lists. In the ",(0,i.jsx)(s.code,{children:"ips"})," section, the IP address returned by a list is explicitly matched with its corresponding meaning."]}),"\n",(0,i.jsx)(s.h2,{id:"ip-lists",children:"IP lists"}),"\n",(0,i.jsx)(s.p,{children:"Starting from rspamd 1.1, it is also possible to perform two-step checks:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Resolve IP addresses of each URL"}),"\n",(0,i.jsx)(s.li,{children:"Check each IP resolved against SURBL list"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"In general, this procedure can be represented as follows:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Check ",(0,i.jsx)(s.code,{children:"A"})," or ",(0,i.jsx)(s.code,{children:"AAAA"})," records for ",(0,i.jsx)(s.code,{children:"example.com"})]}),"\n",(0,i.jsxs)(s.li,{children:["For each IP address resolve it using reverse octets composition: so if IP address of ",(0,i.jsx)(s.code,{children:"example.com"})," is ",(0,i.jsx)(s.code,{children:"1.2.3.4"}),", then checks would be for ",(0,i.jsx)(s.code,{children:"4.3.2.1.uribl.tld"})]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"disabling-rules",children:"Disabling rules"}),"\n",(0,i.jsxs)(s.p,{children:["To disable a rule in SURBL, you can set the ",(0,i.jsx)(s.code,{children:"enabled"})," setting to ",(0,i.jsx)(s.code,{children:"false"}),". This makes it easy to disable specific SURBLs without overriding the entire default configuration. For instance, if you want to disable the ",(0,i.jsx)(s.code,{children:"RAMBLER_URIBL"})," URIBL, you can add the following example to ",(0,i.jsx)(s.code,{children:"/etc/rspamd/local.d/surbl.conf"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'rules {\n  "RAMBLER_URIBL" {\n    enabled = false;\n  }\n}\n'})}),"\n",(0,i.jsx)(s.h2,{id:"use-of-url-redirectors",children:"Use of URL redirectors"}),"\n",(0,i.jsxs)(s.p,{children:["The SURBL module is designed to work in conjunction with the ",(0,i.jsx)(s.a,{href:"/modules/url_redirector",children:"url_redirector module"})," which is capable of resolving known redirectors and extracting the actual URL for the SURBL module to check. You can refer to the url_redirector module's documentation for more information on how to use it. Once the url_redirector module has resolved the actual URL, the SURBL module will automatically use the results to perform its checks."]}),"\n",(0,i.jsx)(s.h2,{id:"selectors",children:"Selectors"}),"\n",(0,i.jsx)(s.p,{children:"Selectors can be used to look up arbitrary values in RBLs."}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"selector"})," field could be configured as a string in the rule settings if only one selector is needed:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'checks = ["replyto"];\nselector = "from(\'mime\'):addr";\nhash = "sha1";\nsymbols_prefixes {\n  replyto = "REPLYTO";\n  selector = "FROM";\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"Or they could be specified as a map of user-specified names to selectors if more than one is needed:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:'selector = {\n  mime_domain = "from(\'mime\'):domain";\n  subject_digest = "header(\'subject\').lower.digest(\'hex\')";\n}\nsymbols_prefixes {\n  mime_domain = "MIME_DOMAIN";\n  subject_digest = "SUBJECT_DIGEST"\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["To combine multiple selectors in one query you can set ",(0,i.jsx)(s.code,{children:"selector_flatten"})," to ",(0,i.jsx)(s.code,{children:"false"}),". For example to create query to RBL like: ",(0,i.jsx)(s.code,{children:"from-sha256.rcpt-sha256"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-hcl",children:"selector_flatten = false;\nselector = \"from('mime').lower.digest('hex','sha256').append('.');rcpts('smtp').first.lower.digest('hex','sha256')\";\n"})})]})}function h(e={}){const{wrapper:s}={...(0,l.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>c});var r=n(96540);const i={},l=r.createContext(i);function o(e){const s=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(l.Provider,{value:s},e.children)}}}]);