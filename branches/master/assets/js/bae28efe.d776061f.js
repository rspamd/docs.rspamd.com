"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[2091],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var r=s(96540);const i={},l=r.createContext(i);function t(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(l.Provider,{value:n},e.children)}},51418:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"developers/writing_rules","title":"Writing Rspamd rules","description":"In this tutorial, we describe how to create new rules for Rspamd - both using Lua and regular expressions.","source":"@site/docs/developers/writing_rules.md","sourceDirName":"developers","slug":"/developers/writing_rules","permalink":"/docs.rspamd.com/branches/master/developers/writing_rules","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/developers/writing_rules.md","tags":[],"version":"current","frontMatter":{"title":"Writing Rspamd rules"},"sidebar":"docs","previous":{"title":"Coroutines and async calls","permalink":"/docs.rspamd.com/branches/master/developers/sync_async"},"next":{"title":"Writing tests for Rspamd","permalink":"/docs.rspamd.com/branches/master/developers/writing_tests"}}');var i=s(74848),l=s(28453);const t={title:"Writing Rspamd rules"},a="Writing Rspamd rules",o={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Configuration files",id:"configuration-files",level:2},{value:"Writing rules",id:"writing-rules",level:2},{value:"Rule weights",id:"rule-weights",level:3},{value:"Regexp rules",id:"regexp-rules",level:2},{value:"Lua rules",id:"lua-rules",level:2},{value:"Return values",id:"return-values",level:3},{value:"Rule conditions",id:"rule-conditions",level:3},{value:"Useful task manipulations",id:"useful-task-manipulations",level:3},{value:"Rspamd symbols",id:"rspamd-symbols",level:2},{value:"Asynchronous actions",id:"asynchronous-actions",level:3},{value:"Redis requests",id:"redis-requests",level:2},{value:"Using maps from Lua plugin",id:"using-maps-from-lua-plugin",level:2},{value:"Difference between <code>config</code> and <code>rspamd_config</code>",id:"difference-between-config-and-rspamd_config",level:2},{value:"Configuration order",id:"configuration-order",level:2},{value:"Rules check order",id:"rules-check-order",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"writing-rspamd-rules",children:"Writing Rspamd rules"})}),"\n",(0,i.jsx)(n.p,{children:"In this tutorial, we describe how to create new rules for Rspamd - both using Lua and regular expressions."}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Rules play a vital role in a spam filtering system, and Rspamd comes equipped with a set of default rules. However, if you operate your own system, you may want to create your own rules for more effective spam filtering or a lower false positive rate. Rules are typically written in Lua, where you can define both custom logic and generic regular expressions."}),"\n",(0,i.jsx)(n.h2,{id:"configuration-files",children:"Configuration files"}),"\n",(0,i.jsx)(n.p,{children:"It is advisable to store your custom rules and configuration in separate files to avoid conflicts with the default rules, which may change from version to version. Rspamd comes with its own set of rules, so keeping your customizations separate can help to ensure that they are not overwritten or disrupted when updating the software."}),"\n",(0,i.jsx)(n.p,{children:"There are several ways to achieve this:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Local rules, both in Lua and regular expression format, should be stored in the file ${CONFDIR}/rspamd.local.lua, where ${CONFDIR} is the directory where your configuration files are located (e.g. /etc/rspamd or /usr/local/etc/rspamd on some systems)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Lua local configuration can be used to both override and extend existing rules. For example, if the main lua file includes the following line:"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rspamd.lua"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Regular expression rule defined in the main Rspamd configuration\nconfig['regexp']['symbol'] = '/some_re/'\n"})}),"\n",(0,i.jsxs)(n.p,{children:["then you can define additional rules in ",(0,i.jsx)(n.code,{children:"rspamd.local.lua"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Regular expression rules defined in a local configuration\nconfig['regexp']['symbol1'] = '/other_re/' -- add 'symbol1' key to the table\nconfig['regexp']['symbol'] = '/override_re/' -- replace regexp for 'symbol'\n"})}),"\n",(0,i.jsx)(n.p,{children:"Please note that this method is different from the standard configuration files, which use a different syntax (UCL-based) and typically include two special files:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'.include(try=true,priority=1) "$CONFDIR/local.d/config.conf"\n.include(try=true,priority=1) "$CONFDIR/override.d/config.conf"\n'})}),"\n",(0,i.jsx)(n.p,{children:"With this approach, you can either modify or add to the existing settings in the Rspamd configuration (using local.d) or completely override them (using override.d)."}),"\n",(0,i.jsx)(n.p,{children:'For instance, you can override some default symbols provided by Rspamd by creating and editing the file etc/rspamd/local.d/metrics.conf.":'}),"\n",(0,i.jsx)(n.h2,{id:"writing-rules",children:"Writing rules"}),"\n",(0,i.jsx)(n.p,{children:"Rspamd typically defines two types of rules:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lua"})," rules: code written in Lua"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Regexp"})," rules: regular expressions and combinations of regular expressions to match specific patterns"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Lua rules are useful for performing complex tasks, such as checking DNS, querying Redis or HTTP, and examining task-specific details. Regexp rules are optimized by Rspamd (especially when Hyperscan is enabled) and can be used to match custom patterns in headers, URLs, text parts, and even the entire message body."}),"\n",(0,i.jsxs)(n.p,{children:["There is another option called ",(0,i.jsx)(n.a,{href:"/configuration/selectors",children:"selectors"})," that allows you to combine data extraction and transformation routines, so you don't have to write custom Lua code. The selectors framework is also useful for reusing custom extraction/transformation routines in different plugins and even in regular expression constructions."]}),"\n",(0,i.jsx)(n.h3,{id:"rule-weights",children:"Rule weights"}),"\n",(0,i.jsxs)(n.p,{children:["Rule weights are usually defined in the ",(0,i.jsx)(n.code,{children:"metrics"})," section and contain the following data:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"score triggers for different actions"}),"\n",(0,i.jsx)(n.li,{children:"symbol scores"}),"\n",(0,i.jsx)(n.li,{children:"symbol descriptions"}),"\n",(0,i.jsxs)(n.li,{children:["symbol group definitions:\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"symbols in group"}),"\n",(0,i.jsx)(n.li,{children:"description of group"}),"\n",(0,i.jsx)(n.li,{children:"joint group score limit"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For built-in rules scores are placed in the file called ",(0,i.jsx)(n.code,{children:"${CONFDIR}/metrics.conf"}),", however, you have two possibilities to define scores for your rules:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Define scores in ",(0,i.jsx)(n.code,{children:"local.d/groups.conf"})," as following:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hcl",children:'symbol "MY_SYMBOL" {\n  description = "my cool rule";\n  score = 1.5;\n}\n# Or, if you want to include it into a group:\ngroup "mygroup" {\n\tsymbol "MY_SYMBOL" {\n\t  description = "my cool rule";\n\t  score = 1.5;\n\t}\n}\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Define scores directly in Lua when describing symbol:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- regexp rule\nconfig['regexp']['MY_SYMBOL'] = {\n\tre = '/a/M & From=/blah/',\n\tscore = 1.5,\n\tdescription = 'my cool rule',\n\tgroup = 'my symbols'\n}\n\n-- lua rule\nrspamd_config.MY_LUA_SYMBOL = {\n\tcallback = function(task)\n\t\t-- Do something\n\t\treturn true\n\tend,\n\tscore = -1.5,\n\tdescription = 'another cool rule',\n\tgroup = 'my symbols'\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Keep in mind that the scores you define directly from Lua have lower priority and will be overridden by scores defined in the groups.conf file. Scores defined in the WebUI have even higher priority."}),"\n",(0,i.jsx)(n.h2,{id:"regexp-rules",children:"Regexp rules"}),"\n",(0,i.jsxs)(n.p,{children:["Regexp rules are executed by the ",(0,i.jsx)(n.code,{children:"regexp"})," module of Rspamd. You can find a detailed description of the syntax in ",(0,i.jsx)(n.a,{href:"/modules/regexp",children:"the regexp module documentation"})]}),"\n",(0,i.jsx)(n.p,{children:"To maximize the performance of your regexp rules, consider the following:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prefer lightweight regexps, such as those for headers or URLs, over heavy ones like those for MIME or the body (unless you are using Hyperscan, which is the default for all Intel-based platforms)."}),"\n",(0,i.jsxs)(n.li,{children:["Avoid complex regexps, backtracking (e.g. ",(0,i.jsx)(n.code,{children:"/*+a?"}),"), lookaheads/lookbehinds, potentially empty patterns, and large boundary constraints (e.g. ",(0,i.jsx)(n.code,{children:"a{1000,100000}"}),"). These constructions can increase scan complexity, especially when using Hyperscan, and even PCRE can experience exponential growth for some of these cases."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By following these guidelines, you can create fast and efficient rules. To add regexp rules, you can use the config global table defined in any Lua file used by Rspamd:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local reconf = config['regexp'] -- Create alias for regexp configs\n\nlocal re1 = 'From=/foo@/H' -- Mind local here\nlocal re2 = '/blah/P'\n\nreconf['SYMBOL'] = {\n\tre = string.format('(%s) && !(%s)', re1, re2), -- use string.format to create expression\n\tscore = 1.2,\n\tdescription = 'some description',\n\n\tcondition = function(task) -- run this rule only if some condition is satisfied\n\t\treturn true\n\tend,\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"lua-rules",children:"Lua rules"}),"\n",(0,i.jsx)(n.p,{children:"While Lua rules are more powerful than regexp rules, they are not as heavily optimized and can impact performance if written improperly. All Lua rules accept a special parameter called task, which represents the message being scanned."}),"\n",(0,i.jsx)(n.h3,{id:"return-values",children:"Return values"}),"\n",(0,i.jsxs)(n.p,{children:["Each Lua rule can return 0 or false, indicating that the rule did not match, or true if the symbol should be inserted. You can also return any positive or negative number, which will be multiplied by the rule's static score. For example, if the rule score is 1.2, a return value of 1 will result in a symbol score of 1.2, while a return value of 0.5 will result in a symbol score of 0.6. It is common to return a ",(0,i.jsx)(n.strong,{children:"confidence factor"})," ranging from 0 to 1.0. Any other return values are treated as options for the symbol, and can be either in a single table:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"return true,1.0,{'option1', 'option2'}\n"})}),"\n",(0,i.jsx)(n.p,{children:"or as a list of return values:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"return true,1.0,'option1','option2'\n"})}),"\n",(0,i.jsx)(n.p,{children:"There is no difference in these notations. Tables are usually more convenient if you form list of options during the rule progressing."}),"\n",(0,i.jsx)(n.h3,{id:"rule-conditions",children:"Rule conditions"}),"\n",(0,i.jsx)(n.p,{children:"Like regexp rules, conditions are allowed for Lua regexps, for example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"rspamd_config.SYMBOL = {\n\tcallback = function(task)\n\t\treturn true\n\tend,\n\tscore = 1.2,\n\tdescription = 'some description',\n\n\tcondition = function(task) -- run this rule only if some condition is satisfied\n\t\treturn true\n\tend,\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"useful-task-manipulations",children:"Useful task manipulations"}),"\n",(0,i.jsxs)(n.p,{children:["There are a number of methods in ",(0,i.jsx)(n.a,{href:"/lua/rspamd_task",children:"task"})," objects. For example, you can get any part of a message:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"rspamd_config.HTML_MESSAGE = {\n  callback = function(task)\n    local parts = task:get_text_parts()\n\n    if parts then\n      for i,p in ipairs(parts) do\n        if p:is_html() then\n          return true\n        end\n      end\n    end\n\n    return false\n  end,\n  score = -0.1,\n  description = 'HTML included in message',\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can get HTML information:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local function check_html_image(task, min, max)\n  local tp = task:get_text_parts()\n\n  for _,p in ipairs(tp) do\n    if p:is_html() then\n      local hc = p:get_html()\n      local len = p:get_length()\n\n\n      if len >= min and len < max then\n        local images = hc:get_images()\n        if images then\n          for _,i in ipairs(images) do\n            if i['embedded'] then\n              return true\n            end\n          end\n        end\n      end\n    end\n  end\nend\n\nrspamd_config.HTML_SHORT_LINK_IMG_1 = {\n  callback = function(task)\n    return check_html_image(task, 0, 1024)\n  end,\n  score = 3.0,\n  group = 'html',\n  description = 'Short html part (0..1K) with a link to an image'\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can get message headers with full information passed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"\nrspamd_config.SUBJ_ALL_CAPS = {\n  callback = function(task)\n    local util = require \"rspamd_util\"\n    local sbj = task:get_header('Subject')\n\n    if sbj then\n      local stripped_subject = subject_re:search(sbj, false, true)\n      if stripped_subject and stripped_subject[1] and stripped_subject[1][2] then\n        sbj = stripped_subject[1][2]\n      end\n\n      if util.is_uppercase(sbj) then\n        return true\n      end\n    end\n\n    return false\n  end,\n  score = 3.0,\n  group = 'headers',\n  description = 'All capital letters in subject'\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can also access HTTP headers, URLs and other useful properties of Rspamd tasks. Moreover, you can use global convenience modules exported by Rspamd, such as ",(0,i.jsx)(n.a,{href:"/lua/rspamd_util",children:"rspamd_util"})," or ",(0,i.jsx)(n.a,{href:"/lua/rspamd_logger",children:"rspamd_logger"})," by requiring them in your rules:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'rspamd_config.SUBJ_ALL_CAPS = {\n  callback = function(task)\n    local util = require "rspamd_util"\n    local logger = require "rspamd_logger"\n    ...\n  end,\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"rspamd-symbols",children:"Rspamd symbols"}),"\n",(0,i.jsx)(n.p,{children:"Rspamd rules fall under three categories:"}),"\n",(0,i.jsxs)(n.ol,{start:"0",children:["\n",(0,i.jsx)(n.li,{children:"Connection filters - are executed before a message has been processed (e.g. on a connection stage)"}),"\n",(0,i.jsx)(n.li,{children:"Pre-filters - run before other rules"}),"\n",(0,i.jsx)(n.li,{children:"Filters - run normally"}),"\n",(0,i.jsx)(n.li,{children:"Post-filters - run after all checks"}),"\n",(0,i.jsx)(n.li,{children:"Idempotent filters - performs statistical checks and are NOT allowed to change scan result in any way"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The most common type of rule is the generic filter. Essentially, a filter is a callback that is executed by Rspamd at a specific time, along with an optional symbol name associated with the callback. There are three options for registering symbols:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Register a callback and an associated symbol"}),"\n",(0,i.jsx)(n.li,{children:"Register just a plain callback (the symbol is not expected to be inserted into the result)"}),"\n",(0,i.jsx)(n.li,{children:"Register a virtual symbol with no callback, but with an associated callback rule"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The last option is useful when you have a single callback with different possible results, such as SYMBOL_ALLOW or SYMBOL_DENY. Filters are registered using the following method:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"rspamd_config:register_symbol{\n  type = 'normal', -- or virtual, callback, prefilter or postfilter\n  name = 'MY_SYMBOL',\n  callback = function(task) -- Main logic\n  end,\n  score = 1.0, -- Metric score\n  group = 'some group', -- Metric group\n  description = 'My super symbol',\n  flags = 'fine', -- fine: symbol is always checked, skip: symbol is always skipped, empty: symbol allows to be executed with no message\n  --priority = 2, -- useful for postfilters and prefilters to define order of execution\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local id = rspamd_config:register_symbol({\n  name = 'DMARC_CALLBACK',\n  type = 'callback',\n  callback = dmarc_callback\n})\nrspamd_config:register_symbol({\n  name = dmarc_symbols['allow'],\n  flags = 'nice',\n  parent = id,\n  type = 'virtual'\n})\nrspamd_config:register_symbol({\n  name = dmarc_symbols['reject'],\n  parent = id,\n  type = 'virtual'\n})\nrspamd_config:register_symbol({\n  name = dmarc_symbols['quarantine'],\n  parent = id,\n  type = 'virtual'\n})\nrspamd_config:register_symbol({\n  name = dmarc_symbols['softfail'],\n  parent = id,\n  type = 'virtual'\n})\nrspamd_config:register_symbol({\n  name = dmarc_symbols['dnsfail'],\n  parent = id,\n  type = 'virtual'\n})\nrspamd_config:register_symbol({\n  name = dmarc_symbols['na'],\n  parent = id,\n  type = 'virtual'\n})\n\nrspamd_config:register_dependency(id, symbols['spf_allow_symbol'])\nrspamd_config:register_dependency(id, symbols['dkim_allow_symbol'])\n"})}),"\n",(0,i.jsx)(n.p,{children:"The registration function with a callback returns a numeric id, which can be used to link symbols in the following ways:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Add virtual symbols associated with the callback"}),"\n",(0,i.jsx)(n.li,{children:"Correctly display the average time for symbols without callbacks"}),"\n",(0,i.jsx)(n.li,{children:"Properly sort symbols"}),"\n",(0,i.jsx)(n.li,{children:"Register dependencies on virtual symbols (in reality, the true dependency is based on the parent symbol, but it can be simpler to use virtual symbols in some cases)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"asynchronous-actions",children:"Asynchronous actions"}),"\n",(0,i.jsxs)(n.p,{children:["For asynchronous actions, such as accessing Redis or performing DNS checks, it is recommended to use dedicated callbacks called symbol handlers. Unlike generic Lua rules, symbol handlers are not required to return a value. Instead, they use the method ",(0,i.jsx)(n.code,{children:"task:insert_result(symbol, weight)"})," to indicate a match. All Lua plugins are implemented as symbol handlers. Here is a simple example of a symbol handler that performs a DNS check:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"rspamd_config:register_symbol('SOME_SYMBOL', 1.0,\n\tfunction(task)\n\t\tlocal to_resolve = 'google.com'\n\t\tlocal logger = require \"rspamd_logger\"\n\n\t\tlocal dns_cb = function(resolver, to_resolve, results, err)\n\t\t\tif results then\n\t\t\t\tlogger.infox(task, '<%1> host: [%2] resolved for symbol: %3',\n\t\t\t\t\ttask:get_message_id(), to_resolve, 'RULE')\n\t\t\t\ttask:insert_result(rule['symbol'], 1)\n\t\t\tend\n\t\tend\n\t\ttask:get_resolver():resolve_a({\n\t\t\ttask=task,\n\t\t\tname = to_resolve,\n\t\t\tcallback = dns_cb})\n\tend)\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can also set the desired score and description:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"rspamd_config:set_metric_symbol('SOME_SYMBOL', 1.2, 'some description')\n-- Table version\nif rule['score'] then\n  if not rule['group'] then\n    rule['group'] = 'whitelist'\n  end\n  rule['name'] = symbol\n  rspamd_config:set_metric_symbol(rule)\nend\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can also use ",(0,i.jsx)(n.a,{href:"/developers/sync_async",children:(0,i.jsx)(n.code,{children:"coroutines"})})," to simplify your asynchronous code."]}),"\n",(0,i.jsx)(n.h2,{id:"redis-requests",children:"Redis requests"}),"\n",(0,i.jsxs)(n.p,{children:["Rspamd relies heavily on Redis for various purposes. A couple of useful functions for working with Redis are defined in the file ",(0,i.jsx)(n.code,{children:"lua_redis.lua"})," and should be globally available in all Lua modules. Here is an example of how to parse the Redis configuration for a module and make requests:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local redis_params\nlocal lua_redis = require \"lua_redis\"\n\nlocal function symbol_cb(task)\n  local function redis_set_cb(err)\n    if err ~=nil then\n      rspamd_logger.errx(task, 'redis_set_cb received error: %1', err)\n    end\n  end\n  -- Create hash of message-id and store to redis\n  local key = make_key(task)\n  local ret = lua_redis.redis_make_request(task,\n    redis_params, -- connect params\n    key, -- hash key\n    true, -- is write\n    redis_set_cb, --callback\n    'SETEX', -- command\n    {key, tostring(settings['expire']), \"1\"} -- arguments\n  )\nend\n\n-- Load redis server for module named 'module'\nredis_params = lua_redis.parse_redis_server('module')\nif redis_params then\n  -- Register symbol\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"using-maps-from-lua-plugin",children:"Using maps from Lua plugin"}),"\n",(0,i.jsx)(n.p,{children:"Maps hold dynamically loaded data like lists or IP trees. It is possible to use 3 types of maps:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"radix"})," stores IP addresses"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"hash"})," stores plain strings and values"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"set"})," stores plain strings with no values"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"regexp"})," stores regular expressions (powered by hyperscan if possible)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"regexp_multi"})," stores regular expressions and returns *",(0,i.jsx)(n.em,{children:"all"})," matches using ",(0,i.jsx)(n.code,{children:"get_key"})," method"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"glob"})," stores glob expressions (powered by hyperscan if possible)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"glob_multi"})," stores glob expressions and returns *",(0,i.jsx)(n.em,{children:"all"})," matches using ",(0,i.jsx)(n.code,{children:"get_key"})," method"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"callback"})," call for a specified Lua callback when a map is loaded or changed, map's content is passed to that callback as a parameter"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here is a sample of using maps from Lua API:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local rspamd_logger = require \"rspamd_logger\"\n\n-- Add two maps in configuration section\nlocal hash_map = rspamd_config:add_map{\n  type = \"hash\",\n  urls = ['file:///path/to/file'],\n  description = 'sample map'\n}\nlocal radix_tree = rspamd_config:add_map{\n  type = 'radix', \n  urls = ['http://somehost.com/test.dat', 'fallback+file:///path/to/file'], \n  description = 'sample ip map'\n}\nlocal generic_map = rspamd_config:add_map{\n  type = 'callback',\n  urls = ['file:///path/to/file']\n  description = 'sample generic map',\n  callback = function(str)\n    -- This callback is called when a map is loaded or changed\n    -- Str contains map content\n    rspamd_logger.info('Got generic map content: ' .. str)\n  end\n}\n\nlocal function sample_symbol_cb(task)\n    -- Check whether hash map contains from address of message\n    if hash_map:get_key(task:get_from()) then\n        -- Check whether radix map contains client's ip\n        if radix_map:get_key(task:get_from_ip_num()) then\n        ...\n        end\n    end\nend\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"difference-between-config-and-rspamd_config",children:["Difference between ",(0,i.jsx)(n.code,{children:"config"})," and ",(0,i.jsx)(n.code,{children:"rspamd_config"})]}),"\n",(0,i.jsx)(n.p,{children:"It may be confusing that there are two variables with a similar meaning. This is a legacy from older versions of Rspamd. However, currently, rspamd_config represents an object that can be used for most configuration tasks:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Get configuration options:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"rspamd_config:get_all_opts('section')\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Add maps:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"rule['map'] = rspamd_config:add_kv_map(rule['domains'],\n            \"Whitelist map for \" .. symbol)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Register callbacks for symbols:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"rspamd_config:register_symbol('SOME_SYMBOL', 1.0, some_functions)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Register lua rules (note that ",(0,i.jsx)(n.code,{children:"__newindex"})," metamethod is actually used here):"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"rspamd_config.SYMBOL = {...}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Register composites, pre-filters, post-filters and so on"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"On the other hand, the config global is a very simple table of configuration options that is exactly the same as defined in rspamd.conf (and rspamd.conf.local or rspamd.conf.override). However, you can also use Lua tables and even functions for some options. For example, the regexp module can also accept a callback argument:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"config['regexp']['SYMBOL'] = {\n  callback = function(task) ... end,\n  ...\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"You cannot use neither async requests nor coroutines in such callbacks - it will cause Rspamd to crash."}),"\n",(0,i.jsx)(n.h2,{id:"configuration-order",children:"Configuration order"}),"\n",(0,i.jsx)(n.p,{children:"Configuration application follows a strict order:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Configuration files are loaded"}),"\n",(0,i.jsx)(n.li,{children:"Lua rules are loaded and can override most previous settings, with the exception of rule scores, which are not overridden if the relevant symbol is defined in a metric section"}),"\n",(0,i.jsx)(n.li,{children:"Dynamic configuration options defined in the WebUI (usually) are loaded and can override rule scores or action scores from previous steps."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"rules-check-order",children:"Rules check order"}),"\n",(0,i.jsx)(n.p,{children:"Rules in Rspamd are checked in the following order:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Stage"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.strong,{children:"Connection filters"})," (from 2.7)"]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"initial stage just after a connection has been established (these rules should not rely on any body content)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Message processing"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"a stage where Rspamd performs text extraction, htm parsing, language detection etc"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Pre-filters"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"checked before all normal filters and are executed in order from high priority to low priority ones (e.g. a prefilter with priority 10 is executed before a prefilter with priority 1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Normal filters"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["normal rules that form dependency graph on each other by calling ",(0,i.jsx)(n.code,{children:"rspamd_config:register_dependency(from, to)"}),", otherwise the order of execution is not defined"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Statistics"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"checked only when all normal symbols are checked"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Composites"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"combined symbols to adjust the final results; pass 1"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Post-filters"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"rules that are called after normal filters and composites pass, the order of execution is from low priority to high priority (e.g. a postfilter with priority 10 is executed after a postfilter with priority 1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Composites"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"combined symbols to adjust the final results (including postfilter results); pass 2"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Idempotent filters"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"rules that cannot change result in any way (so adding symbols or changing scores are not allowed on this stage), the order of execution is from low priority to high priority, same as postfilters"})]})]})]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);