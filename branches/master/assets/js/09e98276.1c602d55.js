"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[3569],{7496:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"modules/ratelimit","title":"Ratelimit module","description":"{:.no_toc}","source":"@site/docs/modules/ratelimit.md","sourceDirName":"modules","slug":"/modules/ratelimit","permalink":"/docs.rspamd.com/branches/master/modules/ratelimit","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/modules/ratelimit.md","tags":[],"version":"current","frontMatter":{"title":"Ratelimit module"},"sidebar":"docs","previous":{"title":"Phishing module","permalink":"/docs.rspamd.com/branches/master/modules/phishing"},"next":{"title":"RBL module","permalink":"/docs.rspamd.com/branches/master/modules/rbl"}}');var t=i(4848),r=i(8453);const l={title:"Ratelimit module"},a="Ratelimit plugin",d={},o=[{value:"Module configuration",id:"module-configuration",level:2},{value:"Ratelimit record",id:"ratelimit-record",level:3},{value:"Principles of operation",id:"principles-of-operation",level:2},{value:"User-defined ratelimits",id:"user-defined-ratelimits",level:3},{value:"Legacy ratelimit record",id:"legacy-ratelimit-record",level:3},{value:"Changes in the module",id:"changes-in-the-module",level:2}];function c(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"ratelimit-plugin",children:"Ratelimit plugin"})}),"\n",(0,t.jsx)(s.p,{children:"{:.no_toc}"}),"\n",(0,t.jsx)(s.p,{children:"Ratelimit plugin is designed to limit messages coming from certain senders, to\ncertain recipients from certain IP addresses combining these parameters into\na separate limits."}),"\n",(0,t.jsxs)(s.p,{children:["To enable a shared cache across multiple scanners, all the established limits are securely stored within a ",(0,t.jsx)(s.a,{href:"https://redis.io",children:"Redis server"})," (or a cluster of servers)."]}),"\n",(0,t.jsx)(s.h2,{id:"module-configuration",children:"Module configuration"}),"\n",(0,t.jsxs)(s.p,{children:["By default, no cache servers are specified in the configuration, meaning that the module ",(0,t.jsx)(s.strong,{children:"will not work"})," until this option is added."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"Ratelimit"})," module supports the following configuration options:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"servers"})," - list of servers where ratelimit data is stored; ",(0,t.jsx)(s.a,{href:"/configuration/redis",children:"global settings"})," used if not set"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"symbol"})," - if this option is specified, then ",(0,t.jsx)(s.code,{children:"ratelimit"})," plugin just adds the corresponding symbol instead of setting pre-result, the value is scaled as $$ 2 * tanh(\\frac{bucket}{threshold * 2}) $$, where ",(0,t.jsx)(s.code,{children:"tanh"})," is the hyperbolic tangent function"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"info_symbol"})," (1.7.0+) - if this option is specified the corresponding symbol is inserted ",(0,t.jsx)(s.em,{children:"in addition to"})," setting pre-result."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"whitelisted_rcpts"})," - comma separated list of whitelisted recipients. By default\nthe value of this option is 'postmaster, mailer-daemon'. Supported entries are:\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"user part of the address"}),"\n",(0,t.jsx)(s.li,{children:"full address part of the address (1.7.0+)."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"whitelisted_ip"})," - a map of ip addresses or networks whitelisted"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"whitelisted_user"})," - a map of usernames which are excluded from user ratelimits"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"expire"})," - maximum lifetime for any limit bucket (2 days by default)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"dynamic_rate_limit"})," (3.9.0+) - enable dynamic ratelimit multipliers (default: false)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"ham_factor_rate"})," - multiplier for rate when a ham message arrives (default: 1.01)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"spam_factor_rate"})," - multiplier for rate when a spam message arrives (default: 0.99)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"ham_factor_burst"})," - multiplier for burst when a ham message arrives (default: 1.02)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"spam_factor_burst"})," - multiplier for burst when a spam message arrives (default: 0.98)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"max_rate_mult"})," - maximum and minimum (1/X) dynamic multiplier for rate (default: 5)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"max_bucket_mult"})," -  maximum and minimum (1/X) dynamic multiplier for rate (default: 10)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"allow_local"})," - a boolean that enables rate-limiting of local requests from rspamc or controller, including WebUI (default: false)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"rates"})," - a table of allowed rates in several forms"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"ratelimit-record",children:"Ratelimit record"}),"\n",(0,t.jsxs)(s.p,{children:["Starting from version 1.8.2, it is possible to define ratelimit buckets using the ",(0,t.jsx)(s.a,{href:"/configuration/selectors",children:"selectors framework"}),".\nThis means that you can opt to use either a selector or one of the predefine ratelimits:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"bounce_to"}),": limit bounces per recipient"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"bounce_to_ip"}),": limit bounces per recipient per ip"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"selector"}),": limit per arbitrary string returned by selector"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"to"}),": limit per recipient"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"to_ip"}),": limit per pair of recipient and sender's IP address"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"to_ip_from"}),": limit per triplet: recipient, sender's envelope from and sender's IP"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"user"}),": limit per authenticated user (useful for outbound limits)"]}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-hcl",children:'# local.d/ratelimit.conf\n  rates {\n    # Selector based ratelimit\n    some_limit = {\n      selector = \'user.lower\';\n      # You can define more than one bucket, however, you need to use array syntax only\n      bucket = [\n      {\n        burst = 100;\n        rate = "10 / 1min";\n      },\n      {\n        burst = 10;\n        rate = "100 / 1min";\n      }]\n    }\n    # Predefined ratelimit\n    to = {\n      bucket = {\n        burst = 100;\n        rate = 0.01666666666666666666; # 1 message per minute\n      }\n    }\n    # or define it with selector\n    other_limit_alt = {\n      selector = \'rcpts:addr.take_n(5)\';\n      bucket = {\n        burst = 100;\n        rate = "1 / 1m"; # 1 message per minute\n      }\n    }\n  }\n'})}),"\n",(0,t.jsxs)(s.p,{children:["The following settings are valid inside ",(0,t.jsx)(s.code,{children:"bucket"})," configuration:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"burst"}),": numeric value specifying the capacity of the bucket"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"rate"}),": rate at which tokens are added to the bucket, expressed as numeric value (equivalent to messages per second) or string (number per period)\nSince version 2.0:"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"skip_recipients"}),": if set to ",(0,t.jsx)(s.code,{children:"true"}),", the number of recipients is not used as a multiplier\nSince version 3.1:"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"message"}),": Message to use for soft-reject"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"symbol"}),": like the top-level ",(0,t.jsx)(s.code,{children:"symbol"})," option but per-bucket; indicated symbol is inserted instead of applying ",(0,t.jsx)(s.code,{children:"soft reject"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"skip_soft_reject"}),": if set to ",(0,t.jsx)(s.code,{children:"true"}),", ",(0,t.jsx)(s.code,{children:"soft reject"})," is not applied"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"principles-of-operation",children:"Principles of operation"}),"\n",(0,t.jsxs)(s.p,{children:["Rspamd utilizes the ",(0,t.jsx)(s.strong,{children:"token bucket"})," algorithm for rate-limiting, a mechanism that can be visualized as a finite-capacity bucket. This bucket is periodically replenished with tokens at set intervals. Each message processed by Rspamd expends one token. If the bucket is empty, the message is delayed (soft rejected). This design permits a burst of messages as long as tokens remain in the bucket. Once the bucket reaches its limit (full), no further tokens are added until some of existing ones are consumed. Once the tokens are depleted, subsequent messages are delayed until tokens are replenished over time. This strategy ensures that the flow of messages does not exceed a predefined rate."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.strong,{children:"token bucket"})," algorithm operates as follows:"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Checking phase"}),": During this phase, tokens are incrementally added to the specified bucket at a constant rate. If the bucket is full, incoming tokens are discarded. When a message arrives, Rspamd checks if the message can acquire a token from the designated rate bucket, and if there are sufficient tokens, the message is processed immediately; otherwise, the it is temporarily deferred (leading to a soft reject action)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Bucket state update"}),": After a message has been processed, whether delivered or rejected, Rspamd updates the bucket's state, removing a token per processed message. This phase also includes the adjustment of dynamic multipliers to adapt to varying traffic patterns."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Before version 3.9.0, the dynamic rate-limit feature was enabled by default. Starting from version 3.9.0, this feature is disabled by default and requires explicit activation in the configuration. Alternatively, you can configure the ",(0,t.jsx)(s.code,{children:"ham_factor_rate"}),"/",(0,t.jsx)(s.code,{children:"spam_factor_rate"})," and/or ",(0,t.jsx)(s.code,{children:"ham_factor_burst"}),"/",(0,t.jsx)(s.code,{children:"spam_factor_burst"})," multipliers for individual buckets as needed."]}),"\n",(0,t.jsx)(s.p,{children:"To better illustrate the concept of dynamic multipliers, refer to the sample graph below. It demonstrates how the burst multiplier varies depending on the number of received ham messages (x > 0) and spam messages (x < 0):"}),"\n",(0,t.jsx)(s.img,{className:"img-fluid",width:"75%",src:"/img/ratelimit.png"}),"\n",(0,t.jsxs)(s.p,{children:["Specialized buckets are used for managing bounce messages, which lack a ",(0,t.jsx)(s.code,{children:"from"})," component and have stricter limits. Rspamd recognizes the following as bounce senders:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"'postmaster'"}),"\n",(0,t.jsx)(s.li,{children:"'mailer-daemon'"}),"\n",(0,t.jsx)(s.li,{children:"'' (empty sender)"}),"\n",(0,t.jsx)(s.li,{children:"'null'"}),"\n",(0,t.jsx)(s.li,{children:"'fetchmail-daemon'"}),"\n",(0,t.jsx)(s.li,{children:"'mdaemon'"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Each recipient is associated with own set of three buckets, making it advantageous to limit the number of recipients that are being checked."}),"\n",(0,t.jsx)(s.p,{children:"Each bucket is defined by four parameters:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"capacity"})," - the total number of tokens a bucket can hold, corresponding to the maximum number of messages that can be processed before reaching the limit."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"rate"})," - the frequency of token insertion into the bucket, measured in tokens (messages) per unit of time, reflecting the steady message rate."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"dynamic_rate"})," - the current dynamic rate multiplier, which adjusts the token addition rate based on traffic patterns."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"dynamic_burst"})," - the current dynamic burst multiplier, which affects the maximum burst size under certain conditions."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["For example, a bucket with a ",(0,t.jsx)(s.strong,{children:"capacity"})," of ",(0,t.jsx)(s.code,{children:"100"})," and a ",(0,t.jsx)(s.strong,{children:"rate"})," of ",(0,t.jsx)(s.code,{children:"1"})," can handle up an initial burst up to 100 messages, and subsequently maintains a steady throughput of one message per second once the bucket is empty."]}),"\n",(0,t.jsx)(s.p,{children:"It is important to note that the ratelimit module does not define any rates that could effectively disable the module by default."}),"\n",(0,t.jsx)(s.h3,{id:"user-defined-ratelimits",children:"User-defined ratelimits"}),"\n",(0,t.jsxs)(s.p,{children:["Users can define their own keywords to create ratelimits by following steps as below. Consider using ",(0,t.jsx)(s.code,{children:"selectors"})," instead."]}),"\n",(0,t.jsxs)(s.p,{children:["First, add the ",(0,t.jsx)(s.code,{children:"custom_keywords"})," setting to the configuration file, pointing to a Lua script that will be created:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-hcl",children:'   custom_keywords = "/etc/rspamd/custom_ratelimit.lua";\n   # other settings ...\n'})}),"\n",(0,t.jsx)(s.p,{children:'Next, create a Lua script that returns a table containing the custom function(s). For instance, the following table ("custom_keywords") contains a function ("customrl") that applies ratelimits to users only when the user is found in a map:'}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-lua",children:"local custom_keywords = {}\nlocal d = {}\n\n-- create map\nd['badusers'] = rspamd_config:add_map({\n  ['url']= '/etc/rspamd/badusers.map',\n  ['type'] = 'set',\n  ['description'] = 'Bad users'\n})\n\ncustom_keywords.customrl = function(task)\n  local rspamd_logger = require \"rspamd_logger\"\n  -- get authenticated user\n  local user = task:get_user()\n  -- define a ratelimit\n  -- a ratelimit can be defined in simplified form (10 / 1m) or as a bucket config (table)\n  local crl = \"10 / 1m\"\n  if not user then return end -- no user, return nil\n  if d['badusers']:get_key(user) then\n    rspamd_logger.infox(rspamd_config, \"User %s is bad, returning custom ratelimit %s\", user, crl)\n    -- return redis hash to store rl data and a ratelimit\n    -- our redis hash will be \"rs_custom_rl_john.doe\" assuming user == john.doe\n    return \"rs_customrl_\" .. user, crl\n  else\n    return -- user is not in map, return nil\n  end\nend\n\nreturn custom_keywords\n"})}),"\n",(0,t.jsxs)(s.p,{children:['The "custom_keywords" table should define one or more functions that receive the ',(0,t.jsx)(s.a,{href:"/lua/rspamd_task",children:"task object"})," as input. Each function should return a Redis hash ",(0,t.jsx)(s.em,{children:"and"})," a limit, for example ",(0,t.jsx)(s.code,{children:'return my_redis_hash, "10 / 1m"'}),". Alternatively, a function can return ",(0,t.jsx)(s.code,{children:"nil"})," to indicate that the ratelimit should not be applied. The ratelimit returned can be in simplified form or a bucket config table."]}),"\n",(0,t.jsx)(s.h3,{id:"legacy-ratelimit-record",children:"Legacy ratelimit record"}),"\n",(0,t.jsx)(s.p,{children:"In versions of Rspamd prior to 1.8, ratelimits were defined as follows:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-hcl",children:"type = [burst,rate];\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Where ",(0,t.jsx)(s.code,{children:"type"})," refers to the type of ratelimit, which could be:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"bounce_to"}),": limit bounces per recipient"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"bounce_to_ip"}),": limit bounces per recipient per ip"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"to"}),": limit per recipient"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"to_ip"}),": limit per pair of recipient and sender's IP address"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"to_ip_from"}),": limit per triplet: recipient, sender's envelope from and sender's IP"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"user"}),": limit per authenticated user (useful for outbound limits)"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"burst"})," attribute represents the bucket's capacity, while ",(0,t.jsx)(s.code,{children:"rate"})," indicates the frequency of token replenishment, measured in messages per second. Both values are expressed as floating-point numbers."]}),"\n",(0,t.jsxs)(s.p,{children:["From version ",(0,t.jsx)(s.code,{children:"1.5"}),", it became possible to define limits using a simplified form. For example:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-hcl",children:'bounce_to = "2 / 5m";\n'})}),"\n",(0,t.jsx)(s.p,{children:"This line defines a bucket capable of a 2-message burst and a steady rate of 2 messages within each 5-minute interval."}),"\n",(0,t.jsx)(s.p,{children:"Suffixes may be used to specify both time and message quantities."}),"\n",(0,t.jsx)(s.p,{children:"Valid suffixes for periods are:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"s"}),": seconds"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"m"}),": minutes"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"h"}),": hours"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"d"}),": days"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Valid suffixes for amounts are:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"k"}),": thousands"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"m"}),": millions"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"g"}),": billions"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"changes-in-the-module",children:"Changes in the module"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"From version 3.1"}),", buckets can also define their custom symbols or messages, for example like this:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-hcl",children:'# local.d/ratelimit.conf\nrates = {\n  my_bucket = { symbol = "SOME_NAME"; selector = ...; rate = ...;}  # inserts SOME_NAME symbol\n  my_other_bucket = { symbol = "OTHER_NAME"; selector = ...; rate = ...;}  # inserts OTHER_NAME symbol\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"From version 3.9.0"}),", the ",(0,t.jsx)(s.code,{children:"dynamic_rate_limit"})," option was introduced, which enables dynamic ratelimit multipliers. This option is disabled by default."]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,s,i)=>{i.d(s,{R:()=>l,x:()=>a});var n=i(6540);const t={},r=n.createContext(t);function l(e){const s=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);