"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[755],{3558:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"modules/arc","title":"ARC module","description":"This module verifies ARC signatures and seals for scanned emails, which demonstrate the message\'s authenticity through a series of trusted relays. The ARC standard is explained in detail at .","source":"@site/docs/modules/arc.md","sourceDirName":"modules","slug":"/modules/arc","permalink":"/docs.rspamd.com/branches/master/modules/arc","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/modules/arc.md","tags":[],"version":"current","frontMatter":{"title":"ARC module"},"sidebar":"docs","previous":{"title":"Antivirus module","permalink":"/docs.rspamd.com/branches/master/modules/antivirus"},"next":{"title":"ASN module","permalink":"/docs.rspamd.com/branches/master/modules/asn"}}');var a=s(4848),r=s(8453);const t={title:"ARC module"},o="ARC module",l={},d=[{value:"Configuration",id:"configuration",level:2},{value:"Principles of operation",id:"principles-of-operation",level:2},{value:"Configuration",id:"configuration-1",level:2},{value:"Trusted ARC forwarders",id:"trusted-arc-forwarders",level:2},{value:"Configuration examples",id:"configuration-examples",level:3},{value:"ARC chain validation and broken forwarders",id:"arc-chain-validation-and-broken-forwarders",level:2},{value:"ARC keys in Redis",id:"arc-keys-in-redis",level:2},{value:"Using maps",id:"using-maps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"arc-module",children:"ARC module"})}),"\n",(0,a.jsxs)(n.p,{children:["This module verifies ",(0,a.jsx)(n.a,{href:"https://arc-spec.org/",children:"ARC"})," signatures and seals for scanned emails, which demonstrate the message's authenticity through a series of trusted relays. The ARC standard is explained in detail at ",(0,a.jsx)(n.a,{href:"https://dmarc.org/presentations/ARC-Overview-2016Q2-v03.pdf",children:"https://dmarc.org/presentations/ARC-Overview-2016Q2-v03.pdf"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Rspamd, starting from version 1.6, offers support for both checking and signing ARC signatures and seals. It utilizes the ",(0,a.jsx)(n.a,{href:"/modules/dkim",children:"dkim"})," module to manage signatures."]}),"\n",(0,a.jsxs)(n.p,{children:["The configuration of this module is similar to the ",(0,a.jsx)(n.a,{href:"/modules/dkim",children:"dkim"})," and ",(0,a.jsx)(n.a,{href:"/modules/dkim_signing",children:"dkim_signing"})," modules."]}),"\n",(0,a.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"whitelist"})," - a map of domains with known broken ARC implementations that should be trusted despite validation failures. When ARC validation fails for a domain in this list, the chain continues as if that step was valid"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"whitelisted_signers_map"})," - a map of trusted ARC forwarders. When a valid ARC chain from one of these domains is found, the ",(0,a.jsx)(n.code,{children:"ARC_ALLOW_TRUSTED"})," symbol is added with a score of -2.0"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"adjust_dmarc"})," (",(0,a.jsx)(n.strong,{children:"true"})," by default) - a boolean flag that enables fixing of DMARC issues when a trusted ARC forwarder is in the chain. This is useful in situations where a domain, ",(0,a.jsx)(n.code,{children:"X"}),", uses a signer, ",(0,a.jsx)(n.code,{children:"Y"}),", to forward emails, but ",(0,a.jsx)(n.code,{children:"X"})," has a strict DMARC policy while ",(0,a.jsx)(n.code,{children:"Y"})," alters the message in a legitimate way. By trusting ",(0,a.jsx)(n.code,{children:"Y"}),", this option allows fixing DMARC rejection for ",(0,a.jsx)(n.code,{children:"X"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"principles-of-operation",children:"Principles of operation"}),"\n",(0,a.jsx)(n.p,{children:"The ARC signing module follows a configurable policy for choosing signing domains and selectors. The policy can be modified using various settings, as described below:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["A mail is eligible for signing if it is received from an authenticated user, a reserved IP address, or an address in the ",(0,a.jsx)(n.code,{children:"sign_networks"})," map (if defined)"]}),"\n",(0,a.jsx)(n.li,{children:"If the envelope from address is not empty, the second-level domain must match the MIME header From"}),"\n",(0,a.jsx)(n.li,{children:"If an authenticated user is present, it must be suffixed with @domain, where domain is the envelope/header From address"}),"\n",(0,a.jsx)(n.li,{children:"Selector and path to key are selected from domain-specific config if present, falling back to global config"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"configuration-1",children:"Configuration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'# local.d/arc.conf\n\n# Allowed settings id\nallowed_ids = nil;\n# If false, messages with empty envelope from are not signed\nallow_envfrom_empty = true;\n# If true, envelope/header domain mismatch is ignored\nallow_hdrfrom_mismatch = false;\n# Domain mismatch allowed for local IP\nallow_hdrfrom_mismatch_local = false;\n# Domain mismatch allowed for sign_networks\nallow_hdrfrom_mismatch_sign_networks = false;\n# If true, multiple from headers are allowed (but only first is used)\nallow_hdrfrom_multiple = false;\n# If true, username does not need to contain matching domain\nallow_username_mismatch = false;\n# Banned settings id\nforbidden_ids = nil;\n# Default path to key, can include \'$domain\' and \'$selector\' variables\npath = "${DBDIR}/arc/$domain.$selector.key";\n# Default selector to use\nselector = "arc";\n# If false, messages from authenticated users are not selected for signing\nsign_authenticated = true;\n# If false, inbound messages are not selected for signing\nsign_inbound = true;\n# If false, messages from local networks are not selected for signing\nsign_local = true;\n# Symbol to add when message is signed\nsign_symbol = "ARC_SIGNED";\n# Whether to fallback to global config\ntry_fallback = true;\n# Domain to use for ARC signing: can be "header" (MIME From), "envelope" (SMTP From), "recipient" (SMTP To), "auth" (SMTP username) or directly specified domain name\nuse_domain = "header";\n# Whether to normalise domains to eSLD\nuse_esld = true;\n# Whether to get keys from Redis\nuse_redis = false;\n# Hash for ARC keys in Redis\nkey_prefix = "ARC_KEYS";\n# Reuse the existing authentication results\nreuse_auth_results = false;\n# map of domains -> names of selectors (since rspamd 1.5.3)\n#selector_map = "/etc/rspamd/arc_selectors.map";\n# map of domains -> paths to keys (since rspamd 1.5.3)\n#path_map = "/etc/rspamd/arc_paths.map";\n# Map of trusted ARC forwarders. Symbol ARC_ALLOW_TRUSTED is added to messages\n# with valid ARC chains from these domains. A failed DMARC result is removed/ignored.\n# Can be configured as inline array, file map, or URL map:\n# whitelisted_signers_map = ["example.org", "example.com"];  # inline array\n# whitelisted_signers_map = "file:///etc/rspamd/maps/arc_trusted_signers.map";  # file map\n# whitelisted_signers_map = "http://example.com/maps/arc_trusted_signers.txt";  # URL map\n\n# Map of domains with broken ARC implementations to trust despite validation failures\n# whitelist = ["broken-forwarder.com", "buggy-arc.example"];  # inline array\n# whitelist = "file:///etc/rspamd/maps/arc_whitelist.map";  # file map\n\n# From version 1.8.4, Rspamd uses a different set of sign_headers for ARC:\nsign_headers = "(o)from:(o)sender:(o)reply-to:(o)subject:(o)date:(o)message-id:(o)to:(o)cc:(o)mime-version:(o)content-type:(o)content-transfer-encoding:resent-to:resent-cc:resent-from:resent-sender:resent-message-id:(o)in-reply-to:(o)references:list-id:list-owner:list-unsubscribe:list-subscribe:list-post:dkim-signature"\n\n# Domain specific settings\ndomain {\n  example.com {\n    # Private key path\n    path = "${DBDIR}/arc/example.key";\n    # Selector\n    selector = "ds";\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"trusted-arc-forwarders",children:"Trusted ARC forwarders"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"whitelisted_signers_map"})," setting allows you to configure trusted ARC forwarders. When an email has a valid ARC chain that includes a signature from one of these trusted domains, Rspamd will:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Add the ",(0,a.jsx)(n.code,{children:"ARC_ALLOW_TRUSTED"})," symbol with a score of -2.0"]}),"\n",(0,a.jsxs)(n.li,{children:["Optionally adjust DMARC policy violations if ",(0,a.jsx)(n.code,{children:"adjust_dmarc"})," is enabled"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This is particularly useful for legitimate email forwarding services that may alter messages in ways that break DMARC alignment, but can be trusted based on their ARC signatures."}),"\n",(0,a.jsx)(n.h3,{id:"configuration-examples",children:"Configuration examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'# local.d/arc.conf\n\n# Inline array (simple list)\nwhitelisted_signers_map = ["mailgun.org", "sendgrid.net", "amazonses.com"];\n\n# File-based map\nwhitelisted_signers_map = "file:///etc/rspamd/maps/arc_trusted_signers.map";\n\n# URL-based map (updated dynamically)\nwhitelisted_signers_map = "http://example.com/maps/arc_trusted_signers.txt";\n'})}),"\n",(0,a.jsx)(n.p,{children:"For file-based maps, create a simple text file with one domain per line:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"mailgun.org\nsendgrid.net\namazonses.com\n"})}),"\n",(0,a.jsx)(n.h2,{id:"arc-chain-validation-and-broken-forwarders",children:"ARC chain validation and broken forwarders"}),"\n",(0,a.jsx)(n.p,{children:"ARC validation works by verifying a chain of signatures and seals (i=1, i=2, i=3, etc.). If any step in this chain fails validation, the entire ARC chain is considered broken. However, in real-world deployments, you may encounter legitimate email forwarders that have buggy ARC implementations."}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"whitelist"})," feature addresses this by allowing ARC chain validation to continue despite failures from trusted domains. For example:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Message has ARC chain: i=1 (good.example), i=2 (broken-forwarder.com), i=3 (final.example)"}),"\n",(0,a.jsx)(n.li,{children:"i=2 fails validation due to broken ARC implementation at broken-forwarder.com"}),"\n",(0,a.jsx)(n.li,{children:"If broken-forwarder.com is in the whitelist, validation continues treating i=2 as valid"}),"\n",(0,a.jsx)(n.li,{children:"i=3 validation proceeds normally, preserving the overall chain integrity"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'This is different from traditional whitelisting which would skip ARC checks entirely. Instead, it "patches over" known broken implementations while maintaining the ARC chain\'s security properties.'}),"\n",(0,a.jsx)(n.h2,{id:"arc-keys-in-redis",children:"ARC keys in Redis"}),"\n",(0,a.jsx)(n.p,{children:"To use ARC keys stored in Redis you should add the following to configuration:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'# local.d/arc.conf\nuse_redis = true;\nkey_prefix = "ARC_KEYS";\nselector = "myselector";\n'})}),"\n",(0,a.jsxs)(n.p,{children:["... and populate the hash with the ARC keys. For example, you can run the following Lua script using ",(0,a.jsx)(n.code,{children:"redis-cli --eval"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:"local key = [[-----BEGIN PRIVATE KEY-----\nMIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBANe3EETkiI1Exyrb\n+VzbMSt90K8MXJA0GcyNs6MFCs9JPaTh90Zu2l7ki7m5LTUx6350AR/3hcvwjSHC\nZjD6fvQ8/zfjN8kaLZ6DAaqtqSlpawIM+8glkuTEkIkpBED/OtDrba4Rd29iLFVu\nwQZXDtTjAAZKZPmtTZ5TXLrcCU6VAgMBAAECgYEA1BFvmBsIN8Gu/+6kNupya2xU\nNVM0yLu/xT5lpNV3LBO325oejAq8+d87kkl/LTW3a2jGFlQ0ICuLw+2mo24QUWRy\nv8if3oeBMlnLqHE+6wNjFVqo5sOjKzjO363xSXwXNUrBT7jDhnZcDN8w3/FecYKj\nifGTVtUs1SLsYwhlc8ECQQDuCRymLZQ/imPn5eFVIydwUzg8ptZlvoA7bfIxUL9B\nQRX33s59kLCilA0tTed8Dd+GnxsT93XOj1ApIfBwmTSlAkEA5/63PDsN7fH+WInq\nVD8nU07M9S8LcGDlPbVVBr2S2I78/iwrSDAYtbkU2vEbhFK/JuKNML2j8OkzV3v1\nQulfMQJBALDzhx+l/HHr3+8RPhx7QKNIyiKUaAdEwbDsP8IXY8YPq1QThu9jM1v4\nsX7/TdkzuvoppwiFykbe1NlvCH279p0CQCmTg4Ee0DtBcCSr6rvYaZLLf329RZ6J\nLuwlMCy6ErQOxBZFEiiovfTrS2qFZToMnkc4uLbwdY36LQJTq7unGTECQCCok8Lz\nBeZtAw+TJofpOM3F2Rlm2qXiBVBeubhRedsiljG0hpvvLJBMppnQ6r27p5Jk39Sm\naTRkxEKrxPWWLNM=\n-----END PRIVATE KEY-----]]\nredis.call('HMSET', 'ARC_KEYS', 'myselector.example.com', key)\n"})}),"\n",(0,a.jsx)(n.p,{children:"The selector will be selected according to the usual process. If a domain-specific selector is configured, it will be used; otherwise, the global setting will be applied."}),"\n",(0,a.jsx)(n.h2,{id:"using-maps",children:"Using maps"}),"\n",(0,a.jsxs)(n.p,{children:["You can use either ",(0,a.jsx)(n.code,{children:"selector_map"})," or ",(0,a.jsx)(n.code,{children:"path_map"})," to access selectors and private key paths respectively, with the ARC signing domain serving as the key. If a match is found, it will override the default settings."]}),"\n",(0,a.jsx)(n.p,{children:"Our configuration defines a templated path for the ARC signing key, a default selector, and an optional selector map that can override the default. All eligible emails will be signed if a key with the appropriate name is present on the disk."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'# local.d/arc.conf\ntry_fallback = true;\npath = "${DBDIR}/arc/$domain.$selector.key";\nselector_map = "/etc/rspamd/arc_selectors.map";\nselector = "arc";\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In the following configuration, we attempt to sign only domains which are present in both ",(0,a.jsx)(n.code,{children:"selector_map"})," and ",(0,a.jsx)(n.code,{children:"path_map"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'# local.d/arc.conf\ntry_fallback = false;\nselector_map = "/etc/rspamd/arc_selectors.map";\npath_map = "/etc/rspamd/arc_paths.map";\n'})}),"\n",(0,a.jsx)(n.p,{children:"Format of the maps should be as shown:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"$ head -1 /etc/rspamd/dkim_selectors.map\nexample.net dkim\n$ head -1 /etc/rspamd/dkim_paths.map\nexample.net /var/lib/rspamd/dkim/example.net.$selector.key\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var i=s(6540);const a={},r=i.createContext(a);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);