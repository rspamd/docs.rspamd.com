"use strict";(self.webpackChunkrspamd_docs=self.webpackChunkrspamd_docs||[]).push([[6491],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>d});var i=s(96540);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},68426:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"modules/mime_types","title":"Mime types modules","description":"This module is intended to do some mime types sanity checks. That includes the following:","source":"@site/docs/modules/mime_types.md","sourceDirName":"modules","slug":"/modules/mime_types","permalink":"/docs.rspamd.com/branches/master/modules/mime_types","draft":false,"unlisted":false,"editUrl":"https://github.com/rspamd/docs.rspamd.com/edit/master/docs/modules/mime_types.md","tags":[],"version":"current","frontMatter":{"title":"Mime types modules"},"sidebar":"docs","previous":{"title":"Milter headers module","permalink":"/docs.rspamd.com/branches/master/modules/milter_headers"},"next":{"title":"Multimap module","permalink":"/docs.rspamd.com/branches/master/modules/multimap"}}');var t=s(74848),o=s(28453);const r={title:"Mime types modules"},d="Rspamd mime types module",a={},l=[{value:"Configuration",id:"configuration",level:2},{value:"Archives support",id:"archives-support",level:2},{value:"User settings usage",id:"user-settings-usage",level:2},{value:"Filename whitelist",id:"filename-whitelist",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"rspamd-mime-types-module",children:"Rspamd mime types module"})}),"\n",(0,t.jsx)(n.p,{children:"This module is intended to do some mime types sanity checks. That includes the following:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Checks whether mime type is from the ",(0,t.jsx)(n.code,{children:"good"})," list (e.g. ",(0,t.jsx)(n.code,{children:"multipart/alternative"})," or ",(0,t.jsx)(n.code,{children:"text/html"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Checks if a mime type is from the ",(0,t.jsx)(n.code,{children:"bad"})," list (e.g. ",(0,t.jsx)(n.code,{children:"multipart/form-data"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"Checks if an attachment filename extension is different from the intended mime type"}),"\n",(0,t.jsx)(n.li,{children:"Checks for archives content (rar and zip are supported) and find certain bad files inside"}),"\n",(0,t.jsxs)(n.li,{children:["Checks for some other bad patterns commonly used by spammers, e.g. extensions hiding (e.g. ",(0,t.jsx)(n.code,{children:".pdf.exe"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"mime_types"})," module reads mime types map specified in ",(0,t.jsx)(n.code,{children:"file"})," option. This map contains binding"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"type/subtype score\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When score is more than ",(0,t.jsx)(n.code,{children:"0"})," then it is considered as ",(0,t.jsx)(n.code,{children:"bad"})," if it is less than ",(0,t.jsx)(n.code,{children:"0"})," it is considered as ",(0,t.jsx)(n.code,{children:"good"})," (with the corresponding multiplier).\nWhen mime type is not listed then ",(0,t.jsx)(n.code,{children:"MIME_UNKNOWN"})," symbol is inserted."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"extension_map"})," option allows to specify map from a known extension to a specific mime type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-hcl",children:'extension_map = {\n  html = "text/html";\n  txt = "text/plain";\n  pdf = "application/pdf";\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["When an attachment extension matches left part but the content type does not match the right part then symbol ",(0,t.jsx)(n.code,{children:"MIME_BAD_ATTACHMENT"})," is inserted."]}),"\n",(0,t.jsx)(n.h2,{id:"archives-support",children:"Archives support"}),"\n",(0,t.jsx)(n.p,{children:"Since 1.3, this module supports archives processing (rar and zip formats) and can check files inside archives. There are additional options added for more precise archives checks, for example, a special symbol for nested archives. Here is the default configuration of mime_types with comments:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-hcl",children:"extension_map = {\n  html = 'text/html',\n  txt = 'text/plain',\n  pdf = 'application/pdf'\n};\n\n# Extensions that are treated as 'bad'\n# Number is score multiply factor\nbad_extensions = {\n  scr = 4,\n  lnk = 4,\n  exe = 1,\n  jar = 2,\n  com = 2,\n  bat = 2,\n  ace = 4,\n  arj = 4,\n  cab = 3,\n};\n\n# Extensions that are particularly penalized for archives\nbad_archive_extensions = {\n  pptx = 0.1,\n  docx = 0.1,\n  xlsx = 0.1,\n  pdf = 0.1,\n  jar = 3,\n  js = 0.5,\n  vbs = 4,\n};\n\n# Used to detect another archive in archive\narchive_extensions = {\n  zip = 1,\n  arj = 1,\n  rar = 1,\n  ace = 1,\n  7z = 1,\n  cab = 1,\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"user-settings-usage",children:"User settings usage"}),"\n",(0,t.jsxs)(n.p,{children:["From version 1.9.1, it is possible to tune this module via ",(0,t.jsx)(n.a,{href:"/configuration/settings",children:"Users settings"}),". To use that, one can apply the following settings:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-hcl",children:'test {\n  from = "user@example.com";\n\n  apply {\n    plugins {\n      mime_types = {\n        bad_extensions = {\n          exe = 100500,\n        },\n        bad_archive_extensions = {\n          js = 100500,\n        },\n      }\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"filename-whitelist",children:"Filename whitelist"}),"\n",(0,t.jsx)(n.p,{children:"It's possible to add a regex whitelist map of filenames you want to bypass the mime_type scanning:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-hcl",children:'# local.d/mime_types.conf\n\n  filename_whitelist = "$LOCAL_CONFDIR/maps.d/mime_types.wl";\n'})}),"\n",(0,t.jsx)(n.p,{children:"The map file should look like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"/^hello_world\\.exe$/\n"})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);